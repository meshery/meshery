diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js
index 50d12f0..6c12354 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js
@@ -292,8 +292,15 @@ class AJV6Validator {
 
   validateFormData(formData, schema, customValidate, transformErrors) {
     // Include form data with undefined values, which is required for validation.
-    const rootSchema = schema;
-    const newFormData = utils.getDefaultFormState(this, schema, formData, rootSchema, true);
+    // const rootSchema = schema;
+    // const newFormData = getDefaultFormState<T>(
+    //   this,
+    //   schema,
+    //   formData,
+    //   rootSchema,
+    //   true
+    // ) as T;
+    const newFormData = formData;
     let validationError = null;
 
     try {
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js.map b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js.map
index b10b0d7..2b64f0a 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js.map
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"validator-ajv6.cjs.development.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    const rootSchema = schema;\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","rootSchema","newFormData","getDefaultFormState","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"validator-ajv6.cjs.development.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  // getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    // const rootSchema = schema;\n    // const newFormData = getDefaultFormState<T>(\n    //   this,\n    //   schema,\n    //   formData,\n    //   rootSchema,\n    //   true\n    // ) as T;\n    const newFormData = formData;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js
index 30b4455..9c0a4df 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js
@@ -1,2 +1,2 @@
-"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("lodash/toPath"),e=require("@rjsf/utils"),t=require("ajv"),a=require("lodash/isObject");function s(r){return r&&"object"==typeof r&&"default"in r?r:{default:r}}var o=s(r),i=s(t),n=s(a);const c={errorDataPath:"property",allErrors:!0,multipleOfPrecision:8,schemaId:"auto",unknownFormats:"ignore"},d=/^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,h=/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;class u{constructor(r){this.ajv=void 0;const{additionalMetaSchemas:e,customFormats:t,ajvOptionsOverrides:a}=r;this.ajv=function(r,e,t){void 0===t&&(t={});const a=new i.default({...c,...t});return a.addFormat("data-url",h),a.addFormat("color",d),Array.isArray(r)&&a.addMetaSchema(r),n.default(e)&&Object.keys(e).forEach((r=>{a.addFormat(r,e[r])})),a}(e,t,a)}toErrorSchema(r){return r.length?r.reduce(((r,e)=>{const{property:t,message:a}=e,s=o.default(t);let i=r;s.length>0&&""===s[0]&&s.splice(0,1);for(const r of s.slice(0))r in i||(i[r]={}),i=i[r];return Array.isArray(i.__errors)?i.__errors=i.__errors.concat(a):a&&(i.__errors=[a]),r}),{}):{}}toErrorList(r,t){if(void 0===t&&(t=[]),!r)return[];let a=[];return e.ERRORS_KEY in r&&(a=a.concat(r.__errors.map((r=>{const e="."+t.join(".");return{property:e,message:r,stack:e+" "+r}})))),Object.keys(r).reduce(((a,s)=>(s!==e.ERRORS_KEY&&(a=a.concat(this.toErrorList(r[s],[...t,s]))),a)),a)}createErrorHandler(r){const t={__errors:[],addError(r){this.__errors.push(r)}};if(e.isObject(r)){const e=r;return Object.keys(e).reduce(((r,t)=>({...r,[t]:this.createErrorHandler(e[t])})),t)}return Array.isArray(r)?r.reduce(((r,e,t)=>({...r,[t]:this.createErrorHandler(e)})),t):t}unwrapErrorHandler(r){return Object.keys(r).reduce(((t,a)=>"addError"===a?t:a===e.ERRORS_KEY?{...t,[a]:r[a]}:{...t,[a]:this.unwrapErrorHandler(r[a])}),{})}transformRJSFValidationErrors(r){return void 0===r&&(r=[]),null===r?[]:r.map((r=>{const{dataPath:e,keyword:t,message:a,params:s,schemaPath:o}=r,i=""+e;return{name:t,property:i,message:a,params:s,stack:(i+" "+a).trim(),schemaPath:o}}))}validateFormData(r,t,a,s){const o=e.getDefaultFormState(this,t,r,t,!0);let i=null;try{this.ajv.validate(t,o)}catch(r){i=r}let n=this.transformRJSFValidationErrors(this.ajv.errors);this.ajv.errors=null;const c=i&&i.message&&"string"==typeof i.message&&i.message.includes("no schema with key or ref ");c&&(n=[...n,{stack:i.message}]),"function"==typeof s&&(n=s(n));let d=this.toErrorSchema(n);if(c&&(d={...d,$schema:{__errors:[i.message]}}),"function"!=typeof a)return{errors:n,errorSchema:d};const h=a(o,this.createErrorHandler(o)),u=this.unwrapErrorHandler(h);return e.mergeValidationData(this,{errors:n,errorSchema:d},u)}withIdRefPrefixObject(r){for(const t in r){const a=r[t];r[t]=t===e.REF_KEY&&"string"==typeof a&&a.startsWith("#")?"__rjsf_rootSchema"+a:this.withIdRefPrefix(a)}return r}withIdRefPrefixArray(r){for(let e=0;e<r.length;e++)r[e]=this.withIdRefPrefix(r[e]);return r}isValid(r,e,t){try{return this.ajv.addSchema(t,"__rjsf_rootSchema").validate(this.withIdRefPrefix(r),e)}catch(r){return!1}finally{this.ajv.removeSchema("__rjsf_rootSchema")}}withIdRefPrefix(r){return r.constructor===Object?this.withIdRefPrefixObject({...r}):Array.isArray(r)?this.withIdRefPrefixArray([...r]):r}}function l(r){return void 0===r&&(r={}),new u(r)}var f=l();exports.customizeValidator=l,exports.default=f;
+"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var r=require("lodash/toPath"),e=require("@rjsf/utils"),t=require("ajv"),a=require("lodash/isObject");function s(r){return r&&"object"==typeof r&&"default"in r?r:{default:r}}var o=s(r),i=s(t),n=s(a);const c={errorDataPath:"property",allErrors:!0,multipleOfPrecision:8,schemaId:"auto",unknownFormats:"ignore"},d=/^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,h=/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;class u{constructor(r){this.ajv=void 0;const{additionalMetaSchemas:e,customFormats:t,ajvOptionsOverrides:a}=r;this.ajv=function(r,e,t){void 0===t&&(t={});const a=new i.default({...c,...t});return a.addFormat("data-url",h),a.addFormat("color",d),Array.isArray(r)&&a.addMetaSchema(r),n.default(e)&&Object.keys(e).forEach((r=>{a.addFormat(r,e[r])})),a}(e,t,a)}toErrorSchema(r){return r.length?r.reduce(((r,e)=>{const{property:t,message:a}=e,s=o.default(t);let i=r;s.length>0&&""===s[0]&&s.splice(0,1);for(const r of s.slice(0))r in i||(i[r]={}),i=i[r];return Array.isArray(i.__errors)?i.__errors=i.__errors.concat(a):a&&(i.__errors=[a]),r}),{}):{}}toErrorList(r,t){if(void 0===t&&(t=[]),!r)return[];let a=[];return e.ERRORS_KEY in r&&(a=a.concat(r.__errors.map((r=>{const e="."+t.join(".");return{property:e,message:r,stack:e+" "+r}})))),Object.keys(r).reduce(((a,s)=>(s!==e.ERRORS_KEY&&(a=a.concat(this.toErrorList(r[s],[...t,s]))),a)),a)}createErrorHandler(r){const t={__errors:[],addError(r){this.__errors.push(r)}};if(e.isObject(r)){const e=r;return Object.keys(e).reduce(((r,t)=>({...r,[t]:this.createErrorHandler(e[t])})),t)}return Array.isArray(r)?r.reduce(((r,e,t)=>({...r,[t]:this.createErrorHandler(e)})),t):t}unwrapErrorHandler(r){return Object.keys(r).reduce(((t,a)=>"addError"===a?t:a===e.ERRORS_KEY?{...t,[a]:r[a]}:{...t,[a]:this.unwrapErrorHandler(r[a])}),{})}transformRJSFValidationErrors(r){return void 0===r&&(r=[]),null===r?[]:r.map((r=>{const{dataPath:e,keyword:t,message:a,params:s,schemaPath:o}=r,i=""+e;return{name:t,property:i,message:a,params:s,stack:(i+" "+a).trim(),schemaPath:o}}))}validateFormData(r,t,a,s){const o=r;let i=null;try{this.ajv.validate(t,o)}catch(r){i=r}let n=this.transformRJSFValidationErrors(this.ajv.errors);this.ajv.errors=null;const c=i&&i.message&&"string"==typeof i.message&&i.message.includes("no schema with key or ref ");c&&(n=[...n,{stack:i.message}]),"function"==typeof s&&(n=s(n));let d=this.toErrorSchema(n);if(c&&(d={...d,$schema:{__errors:[i.message]}}),"function"!=typeof a)return{errors:n,errorSchema:d};const h=a(o,this.createErrorHandler(o)),u=this.unwrapErrorHandler(h);return e.mergeValidationData(this,{errors:n,errorSchema:d},u)}withIdRefPrefixObject(r){for(const t in r){const a=r[t];r[t]=t===e.REF_KEY&&"string"==typeof a&&a.startsWith("#")?"__rjsf_rootSchema"+a:this.withIdRefPrefix(a)}return r}withIdRefPrefixArray(r){for(let e=0;e<r.length;e++)r[e]=this.withIdRefPrefix(r[e]);return r}isValid(r,e,t){try{return this.ajv.addSchema(t,"__rjsf_rootSchema").validate(this.withIdRefPrefix(r),e)}catch(r){return!1}finally{this.ajv.removeSchema("__rjsf_rootSchema")}}withIdRefPrefix(r){return r.constructor===Object?this.withIdRefPrefixObject({...r}):Array.isArray(r)?this.withIdRefPrefixArray([...r]):r}}function l(r){return void 0===r&&(r={}),new u(r)}var f=l();exports.customizeValidator=l,exports.default=f;
 //# sourceMappingURL=validator-ajv6.cjs.production.min.js.map
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js.map b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js.map
index 0b66da3..57c07c1 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js.map
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.cjs.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"validator-ajv6.cjs.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    const rootSchema = schema;\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","AJV6Validator","constructor","options","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","getDefaultFormState","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","addSchema","removeSchema","schemaNode","customizeValidator","index"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"validator-ajv6.cjs.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  // getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    // const rootSchema = schema;\n    // const newFormData = getDefaultFormState<T>(\n    //   this,\n    //   schema,\n    //   formData,\n    //   rootSchema,\n    //   true\n    // ) as T;\n    const newFormData = formData;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","AJV6Validator","constructor","options","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","addSchema","removeSchema","schemaNode","customizeValidator","index"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js
index e36ea9a..c9fa156 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js
@@ -1,5 +1,5 @@
 import toPath from 'lodash-es/toPath';
-import { ERRORS_KEY, isObject as isObject$1, getDefaultFormState, mergeValidationData, REF_KEY } from '@rjsf/utils';
+import { ERRORS_KEY, isObject as isObject$1, mergeValidationData, REF_KEY } from '@rjsf/utils';
 import Ajv from 'ajv';
 import isObject from 'lodash-es/isObject';
 
@@ -282,8 +282,15 @@ class AJV6Validator {
 
   validateFormData(formData, schema, customValidate, transformErrors) {
     // Include form data with undefined values, which is required for validation.
-    const rootSchema = schema;
-    const newFormData = getDefaultFormState(this, schema, formData, rootSchema, true);
+    // const rootSchema = schema;
+    // const newFormData = getDefaultFormState<T>(
+    //   this,
+    //   schema,
+    //   formData,
+    //   rootSchema,
+    //   true
+    // ) as T;
+    const newFormData = formData;
     let validationError = null;
 
     try {
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js.map b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js.map
index 310e025..5c21231 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js.map
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"validator-ajv6.esm.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    const rootSchema = schema;\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","rootSchema","newFormData","getDefaultFormState","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"validator-ajv6.esm.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  // getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    // const rootSchema = schema;\n    // const newFormData = getDefaultFormState<T>(\n    //   this,\n    //   schema,\n    //   formData,\n    //   rootSchema,\n    //   true\n    // ) as T;\n    const newFormData = formData;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js
index d3578f5..1082c51 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js
@@ -289,8 +289,15 @@
 
     validateFormData(formData, schema, customValidate, transformErrors) {
       // Include form data with undefined values, which is required for validation.
-      const rootSchema = schema;
-      const newFormData = utils.getDefaultFormState(this, schema, formData, rootSchema, true);
+      // const rootSchema = schema;
+      // const newFormData = getDefaultFormState<T>(
+      //   this,
+      //   schema,
+      //   formData,
+      //   rootSchema,
+      //   true
+      // ) as T;
+      const newFormData = formData;
       let validationError = null;
 
       try {
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js.map b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js.map
index edec0e2..b30333c 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js.map
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.development.js.map
@@ -1 +1 @@
-{"version":3,"file":"validator-ajv6.umd.development.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    const rootSchema = schema;\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","rootSchema","newFormData","getDefaultFormState","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"validator-ajv6.umd.development.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  // getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    // const rootSchema = schema;\n    // const newFormData = getDefaultFormState<T>(\n    //   this,\n    //   schema,\n    //   formData,\n    //   rootSchema,\n    //   true\n    // ) as T;\n    const newFormData = formData;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","createAjvInstance","additionalMetaSchemas","customFormats","ajvOptionsOverrides","ajv","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","realObj","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","result","addSchema","removeSchema","schemaNode","customizeValidator"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js
index 87a908d..f0cfd1d 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js
@@ -1,2 +1,2 @@
-!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("lodash-es/toPath"),require("@rjsf/utils"),require("ajv"),require("lodash-es/isObject")):"function"==typeof define&&define.amd?define(["exports","lodash-es/toPath","@rjsf/utils","ajv","lodash-es/isObject"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self)["@rjsf/validator-ajv6"]={},r.toPath,r.utils,r.Ajv,r.isObject)}(this,(function(r,e,t,a,s){"use strict";function o(r){return r&&"object"==typeof r&&"default"in r?r:{default:r}}var i=o(e),n=o(a),c=o(s);const d={errorDataPath:"property",allErrors:!0,multipleOfPrecision:8,schemaId:"auto",unknownFormats:"ignore"},l=/^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,u=/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/,h="__rjsf_rootSchema";class f{constructor(r){this.ajv=void 0;const{additionalMetaSchemas:e,customFormats:t,ajvOptionsOverrides:a}=r;this.ajv=function(r,e,t){void 0===t&&(t={});const a=new n.default({...d,...t});return a.addFormat("data-url",u),a.addFormat("color",l),Array.isArray(r)&&a.addMetaSchema(r),c.default(e)&&Object.keys(e).forEach((r=>{a.addFormat(r,e[r])})),a}(e,t,a)}toErrorSchema(r){return r.length?r.reduce(((r,e)=>{const{property:t,message:a}=e,s=i.default(t);let o=r;s.length>0&&""===s[0]&&s.splice(0,1);for(const r of s.slice(0))r in o||(o[r]={}),o=o[r];return Array.isArray(o.__errors)?o.__errors=o.__errors.concat(a):a&&(o.__errors=[a]),r}),{}):{}}toErrorList(r,e){if(void 0===e&&(e=[]),!r)return[];let a=[];return t.ERRORS_KEY in r&&(a=a.concat(r.__errors.map((r=>{const t="."+e.join(".");return{property:t,message:r,stack:t+" "+r}})))),Object.keys(r).reduce(((a,s)=>(s!==t.ERRORS_KEY&&(a=a.concat(this.toErrorList(r[s],[...e,s]))),a)),a)}createErrorHandler(r){const e={__errors:[],addError(r){this.__errors.push(r)}};if(t.isObject(r)){const t=r;return Object.keys(t).reduce(((r,e)=>({...r,[e]:this.createErrorHandler(t[e])})),e)}return Array.isArray(r)?r.reduce(((r,e,t)=>({...r,[t]:this.createErrorHandler(e)})),e):e}unwrapErrorHandler(r){return Object.keys(r).reduce(((e,a)=>"addError"===a?e:a===t.ERRORS_KEY?{...e,[a]:r[a]}:{...e,[a]:this.unwrapErrorHandler(r[a])}),{})}transformRJSFValidationErrors(r){return void 0===r&&(r=[]),null===r?[]:r.map((r=>{const{dataPath:e,keyword:t,message:a,params:s,schemaPath:o}=r,i=""+e;return{name:t,property:i,message:a,params:s,stack:(i+" "+a).trim(),schemaPath:o}}))}validateFormData(r,e,a,s){const o=t.getDefaultFormState(this,e,r,e,!0);let i=null;try{this.ajv.validate(e,o)}catch(r){i=r}let n=this.transformRJSFValidationErrors(this.ajv.errors);this.ajv.errors=null;const c=i&&i.message&&"string"==typeof i.message&&i.message.includes("no schema with key or ref ");c&&(n=[...n,{stack:i.message}]),"function"==typeof s&&(n=s(n));let d=this.toErrorSchema(n);if(c&&(d={...d,$schema:{__errors:[i.message]}}),"function"!=typeof a)return{errors:n,errorSchema:d};const l=a(o,this.createErrorHandler(o)),u=this.unwrapErrorHandler(l);return t.mergeValidationData(this,{errors:n,errorSchema:d},u)}withIdRefPrefixObject(r){for(const e in r){const a=r[e];r[e]=e===t.REF_KEY&&"string"==typeof a&&a.startsWith("#")?h+a:this.withIdRefPrefix(a)}return r}withIdRefPrefixArray(r){for(let e=0;e<r.length;e++)r[e]=this.withIdRefPrefix(r[e]);return r}isValid(r,e,t){try{return this.ajv.addSchema(t,h).validate(this.withIdRefPrefix(r),e)}catch(r){return!1}finally{this.ajv.removeSchema(h)}}withIdRefPrefix(r){return r.constructor===Object?this.withIdRefPrefixObject({...r}):Array.isArray(r)?this.withIdRefPrefixArray([...r]):r}}function m(r){return void 0===r&&(r={}),new f(r)}var y=m();r.customizeValidator=m,r.default=y,Object.defineProperty(r,"__esModule",{value:!0})}));
+!function(r,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("lodash-es/toPath"),require("@rjsf/utils"),require("ajv"),require("lodash-es/isObject")):"function"==typeof define&&define.amd?define(["exports","lodash-es/toPath","@rjsf/utils","ajv","lodash-es/isObject"],e):e((r="undefined"!=typeof globalThis?globalThis:r||self)["@rjsf/validator-ajv6"]={},r.toPath,r.utils,r.Ajv,r.isObject)}(this,(function(r,e,t,a,s){"use strict";function o(r){return r&&"object"==typeof r&&"default"in r?r:{default:r}}var i=o(e),n=o(a),c=o(s);const d={errorDataPath:"property",allErrors:!0,multipleOfPrecision:8,schemaId:"auto",unknownFormats:"ignore"},l=/^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/,u=/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/,h="__rjsf_rootSchema";class f{constructor(r){this.ajv=void 0;const{additionalMetaSchemas:e,customFormats:t,ajvOptionsOverrides:a}=r;this.ajv=function(r,e,t){void 0===t&&(t={});const a=new n.default({...d,...t});return a.addFormat("data-url",u),a.addFormat("color",l),Array.isArray(r)&&a.addMetaSchema(r),c.default(e)&&Object.keys(e).forEach((r=>{a.addFormat(r,e[r])})),a}(e,t,a)}toErrorSchema(r){return r.length?r.reduce(((r,e)=>{const{property:t,message:a}=e,s=i.default(t);let o=r;s.length>0&&""===s[0]&&s.splice(0,1);for(const r of s.slice(0))r in o||(o[r]={}),o=o[r];return Array.isArray(o.__errors)?o.__errors=o.__errors.concat(a):a&&(o.__errors=[a]),r}),{}):{}}toErrorList(r,e){if(void 0===e&&(e=[]),!r)return[];let a=[];return t.ERRORS_KEY in r&&(a=a.concat(r.__errors.map((r=>{const t="."+e.join(".");return{property:t,message:r,stack:t+" "+r}})))),Object.keys(r).reduce(((a,s)=>(s!==t.ERRORS_KEY&&(a=a.concat(this.toErrorList(r[s],[...e,s]))),a)),a)}createErrorHandler(r){const e={__errors:[],addError(r){this.__errors.push(r)}};if(t.isObject(r)){const t=r;return Object.keys(t).reduce(((r,e)=>({...r,[e]:this.createErrorHandler(t[e])})),e)}return Array.isArray(r)?r.reduce(((r,e,t)=>({...r,[t]:this.createErrorHandler(e)})),e):e}unwrapErrorHandler(r){return Object.keys(r).reduce(((e,a)=>"addError"===a?e:a===t.ERRORS_KEY?{...e,[a]:r[a]}:{...e,[a]:this.unwrapErrorHandler(r[a])}),{})}transformRJSFValidationErrors(r){return void 0===r&&(r=[]),null===r?[]:r.map((r=>{const{dataPath:e,keyword:t,message:a,params:s,schemaPath:o}=r,i=""+e;return{name:t,property:i,message:a,params:s,stack:(i+" "+a).trim(),schemaPath:o}}))}validateFormData(r,e,a,s){const o=r;let i=null;try{this.ajv.validate(e,o)}catch(r){i=r}let n=this.transformRJSFValidationErrors(this.ajv.errors);this.ajv.errors=null;const c=i&&i.message&&"string"==typeof i.message&&i.message.includes("no schema with key or ref ");c&&(n=[...n,{stack:i.message}]),"function"==typeof s&&(n=s(n));let d=this.toErrorSchema(n);if(c&&(d={...d,$schema:{__errors:[i.message]}}),"function"!=typeof a)return{errors:n,errorSchema:d};const l=a(o,this.createErrorHandler(o)),u=this.unwrapErrorHandler(l);return t.mergeValidationData(this,{errors:n,errorSchema:d},u)}withIdRefPrefixObject(r){for(const e in r){const a=r[e];r[e]=e===t.REF_KEY&&"string"==typeof a&&a.startsWith("#")?h+a:this.withIdRefPrefix(a)}return r}withIdRefPrefixArray(r){for(let e=0;e<r.length;e++)r[e]=this.withIdRefPrefix(r[e]);return r}isValid(r,e,t){try{return this.ajv.addSchema(t,h).validate(this.withIdRefPrefix(r),e)}catch(r){return!1}finally{this.ajv.removeSchema(h)}}withIdRefPrefix(r){return r.constructor===Object?this.withIdRefPrefixObject({...r}):Array.isArray(r)?this.withIdRefPrefixArray([...r]):r}}function m(r){return void 0===r&&(r={}),new f(r)}var y=m();r.customizeValidator=m,r.default=y,Object.defineProperty(r,"__esModule",{value:!0})}));
 //# sourceMappingURL=validator-ajv6.umd.production.min.js.map
diff --git a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js.map b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js.map
index 9a837b1..34a7f48 100644
--- a/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js.map
+++ b/node_modules/@rjsf/validator-ajv6/dist/validator-ajv6.umd.production.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"validator-ajv6.umd.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    const rootSchema = schema;\n    const newFormData = getDefaultFormState<T>(\n      this,\n      schema,\n      formData,\n      rootSchema,\n      true\n    ) as T;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","getDefaultFormState","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","addSchema","removeSchema","schemaNode","customizeValidator","index"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"validator-ajv6.umd.production.min.js","sources":["../src/createAjvInstance.ts","../src/validator.ts","../src/customizeValidator.ts","../src/index.ts"],"sourcesContent":["import Ajv from \"ajv\";\nimport isObject from \"lodash/isObject\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\n\nexport const AJV_CONFIG = {\n  errorDataPath: \"property\",\n  allErrors: true,\n  multipleOfPrecision: 8,\n  schemaId: \"auto\",\n  unknownFormats: \"ignore\",\n} as const;\nexport const COLOR_FORMAT_REGEX =\n  /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/;\nexport const DATA_URL_FORMAT_REGEX =\n  /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;\n\n/** Creates an Ajv version 6 implementation object with standard support for the 'color` and `data-url` custom formats.\n * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the\n * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If\n * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing\n * the `Ajv` instance.\n *\n * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access\n * @param [customFormats] - The set of additional custom formats that the validator will support\n * @param [ajvOptionsOverrides={}] - The set of validator config override options\n */\nexport default function createAjvInstance(\n  additionalMetaSchemas?: CustomValidatorOptionsType[\"additionalMetaSchemas\"],\n  customFormats?: CustomValidatorOptionsType[\"customFormats\"],\n  ajvOptionsOverrides: CustomValidatorOptionsType[\"ajvOptionsOverrides\"] = {}\n) {\n  const ajv = new Ajv({ ...AJV_CONFIG, ...ajvOptionsOverrides });\n\n  // add custom formats\n  ajv.addFormat(\"data-url\", DATA_URL_FORMAT_REGEX);\n  ajv.addFormat(\"color\", COLOR_FORMAT_REGEX);\n\n  // add more schemas to validate against\n  if (Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n  }\n\n  // add more custom formats to validate against\n  if (isObject(customFormats)) {\n    Object.keys(customFormats).forEach((formatName) => {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n  }\n\n  return ajv;\n}\n","import { Ajv, ErrorObject } from \"ajv\";\nimport toPath from \"lodash/toPath\";\nimport {\n  CustomValidator,\n  ErrorSchema,\n  ErrorTransformer,\n  FieldValidation,\n  FormValidation,\n  GenericObjectType,\n  RJSFSchema,\n  RJSFValidationError,\n  ValidationData,\n  ValidatorType,\n  // getDefaultFormState,\n  isObject,\n  mergeValidationData,\n  ERRORS_KEY,\n  REF_KEY,\n} from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport createAjvInstance from \"./createAjvInstance\";\n\nconst ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\n\n/** `ValidatorType` implementation that uses the AJV 6 validation mechanism.\n */\nexport default class AJV6Validator<T = any> implements ValidatorType<T> {\n  /** The AJV instance to use for all validations\n   *\n   * @private\n   */\n  private ajv: Ajv;\n\n  /** Constructs an `AJV6Validator` instance using the `options`\n   *\n   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance\n   */\n  constructor(options: CustomValidatorOptionsType) {\n    const { additionalMetaSchemas, customFormats, ajvOptionsOverrides } =\n      options;\n    this.ajv = createAjvInstance(\n      additionalMetaSchemas,\n      customFormats,\n      ajvOptionsOverrides\n    );\n  }\n\n  /** Transforms a ajv validation errors list:\n   * [\n   *   {property: '.level1.level2[2].level3', message: 'err a'},\n   *   {property: '.level1.level2[2].level3', message: 'err b'},\n   *   {property: '.level1.level2[4].level3', message: 'err b'},\n   * ]\n   * Into an error tree:\n   * {\n   *   level1: {\n   *     level2: {\n   *       2: {level3: {errors: ['err a', 'err b']}},\n   *       4: {level3: {errors: ['err b']}},\n   *     }\n   *   }\n   * };\n   *\n   * @param errors - The list of RJSFValidationError objects\n   * @private\n   */\n  private toErrorSchema(errors: RJSFValidationError[]): ErrorSchema<T> {\n    if (!errors.length) {\n      return {} as ErrorSchema<T>;\n    }\n    return errors.reduce(\n      (errorSchema: ErrorSchema<T>, error): ErrorSchema<T> => {\n        const { property, message } = error;\n        const path = toPath(property);\n        let parent: GenericObjectType = errorSchema;\n\n        // If the property is at the root (.level1) then toPath creates\n        // an empty array element at the first index. Remove it.\n        if (path.length > 0 && path[0] === \"\") {\n          path.splice(0, 1);\n        }\n\n        for (const segment of path.slice(0)) {\n          if (!(segment in parent)) {\n            parent[segment] = {};\n          }\n          parent = parent[segment];\n        }\n\n        if (Array.isArray(parent.__errors)) {\n          // We store the list of errors for this node in a property named __errors\n          // to avoid name collision with a possible sub schema field named\n          // 'errors' (see `validate.createErrorHandler`).\n          parent.__errors = parent.__errors.concat(message!);\n        } else {\n          if (message) {\n            parent.__errors = [message];\n          }\n        }\n        return errorSchema;\n      },\n      {} as ErrorSchema<T>\n    );\n  }\n\n  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`\n   *\n   * @param errorSchema - The `ErrorSchema` instance to convert\n   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified\n   */\n  toErrorList(errorSchema?: ErrorSchema<T>, fieldPath: string[] = []) {\n    if (!errorSchema) {\n      return [];\n    }\n    let errorList: RJSFValidationError[] = [];\n    if (ERRORS_KEY in errorSchema) {\n      errorList = errorList.concat(\n        errorSchema.__errors!.map((message: string) => {\n          const property = `.${fieldPath.join(\".\")}`;\n          return {\n            property,\n            message,\n            stack: `${property} ${message}`,\n          };\n        })\n      );\n    }\n    return Object.keys(errorSchema).reduce((acc, key) => {\n      if (key !== ERRORS_KEY) {\n        acc = acc.concat(\n          this.toErrorList((errorSchema as GenericObjectType)[key], [\n            ...fieldPath,\n            key,\n          ])\n        );\n      }\n      return acc;\n    }, errorList);\n  }\n\n  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it\n   *\n   * @param formData - The form data around which the error handler is created\n   * @private\n   */\n  private createErrorHandler(formData: T): FormValidation<T> {\n    const handler: FieldValidation = {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // 'errors' (see `utils.toErrorSchema`).\n      __errors: [],\n      addError(message: string) {\n        this.__errors!.push(message);\n      },\n    };\n    if (isObject(formData)) {\n      const formObject: GenericObjectType = formData as GenericObjectType;\n      return Object.keys(formObject).reduce((acc, key) => {\n        return { ...acc, [key]: this.createErrorHandler(formObject[key]) };\n      }, handler as FormValidation<T>);\n    }\n    if (Array.isArray(formData)) {\n      return formData.reduce((acc, value, key) => {\n        return { ...acc, [key]: this.createErrorHandler(value) };\n      }, handler);\n    }\n    return handler as FormValidation<T>;\n  }\n\n  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it\n   *\n   * @param errorHandler - The `FormValidation` error handling structure\n   * @private\n   */\n  private unwrapErrorHandler(errorHandler: FormValidation<T>): ErrorSchema<T> {\n    return Object.keys(errorHandler).reduce((acc, key) => {\n      if (key === \"addError\") {\n        return acc;\n      } else if (key === ERRORS_KEY) {\n        return { ...acc, [key]: (errorHandler as GenericObjectType)[key] };\n      }\n      return {\n        ...acc,\n        [key]: this.unwrapErrorHandler(\n          (errorHandler as GenericObjectType)[key]\n        ),\n      };\n    }, {} as ErrorSchema<T>);\n  }\n\n  /** Transforming the error output from ajv to format used by @rjsf/utils.\n   * At some point, components should be updated to support ajv.\n   *\n   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`\n   * @private\n   */\n  private transformRJSFValidationErrors(\n    errors: Ajv[\"errors\"] = []\n  ): RJSFValidationError[] {\n    if (errors === null) {\n      return [];\n    }\n\n    return errors.map((e: ErrorObject) => {\n      const { dataPath, keyword, message, params, schemaPath } = e;\n      const property = `${dataPath}`;\n\n      // put data in expected format\n      return {\n        name: keyword,\n        property,\n        message,\n        params, // specific to ajv\n        stack: `${property} ${message}`.trim(),\n        schemaPath,\n      };\n    });\n  }\n\n  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives\n   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also\n   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and\n   * transform them in what ever way it chooses.\n   *\n   * @param formData - The form data to validate\n   * @param schema - The schema against which to validate the form data\n   * @param [customValidate] - An optional function that is used to perform custom validation\n   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation\n   */\n  validateFormData(\n    formData: T,\n    schema: RJSFSchema,\n    customValidate?: CustomValidator<T>,\n    transformErrors?: ErrorTransformer\n  ): ValidationData<T> {\n    // Include form data with undefined values, which is required for validation.\n    // const rootSchema = schema;\n    // const newFormData = getDefaultFormState<T>(\n    //   this,\n    //   schema,\n    //   formData,\n    //   rootSchema,\n    //   true\n    // ) as T;\n    const newFormData = formData;\n\n    let validationError: Error | null = null;\n    try {\n      this.ajv.validate(schema, newFormData);\n    } catch (err) {\n      validationError = err as Error;\n    }\n\n    let errors = this.transformRJSFValidationErrors(this.ajv.errors);\n    // Clear errors to prevent persistent errors, see #1104\n\n    this.ajv.errors = null;\n\n    const noProperMetaSchema =\n      validationError &&\n      validationError.message &&\n      typeof validationError.message === \"string\" &&\n      validationError.message.includes(\"no schema with key or ref \");\n\n    if (noProperMetaSchema) {\n      errors = [...errors, { stack: validationError!.message }];\n    }\n    if (typeof transformErrors === \"function\") {\n      errors = transformErrors(errors);\n    }\n\n    let errorSchema = this.toErrorSchema(errors);\n\n    if (noProperMetaSchema) {\n      errorSchema = {\n        ...errorSchema,\n        ...{\n          $schema: {\n            __errors: [validationError!.message],\n          },\n        },\n      };\n    }\n\n    if (typeof customValidate !== \"function\") {\n      return { errors, errorSchema };\n    }\n\n    const errorHandler = customValidate(\n      newFormData,\n      this.createErrorHandler(newFormData)\n    );\n    const userErrorSchema = this.unwrapErrorHandler(errorHandler);\n    return mergeValidationData<T>(\n      this,\n      { errors, errorSchema },\n      userErrorSchema\n    );\n  }\n\n  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixObject(node: object) {\n    for (const key in node) {\n      const realObj: { [k: string]: any } = node;\n      const value = realObj[key];\n      if (\n        key === REF_KEY &&\n        typeof value === \"string\" &&\n        value.startsWith(\"#\")\n      ) {\n        realObj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        realObj[key] = this.withIdRefPrefix(value);\n      }\n    }\n    return node;\n  }\n\n  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling\n   * `withIdRefPrefix` for any other elements.\n   *\n   * @param nodeThe - list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @private\n   */\n  private withIdRefPrefixArray(node: object[]): RJSFSchema {\n    for (let i = 0; i < node.length; i++) {\n      node[i] = this.withIdRefPrefix(node[i]);\n    }\n    return node as RJSFSchema;\n  }\n\n  /** Validates data against a schema, returning true if the data is valid, or\n   * false otherwise. If the schema is invalid, then this function will return\n   * false.\n   *\n   * @param schema - The schema against which to validate the form data   * @param schema\n   * @param formData- - The form data to validate\n   * @param rootSchema - The root schema used to provide $ref resolutions\n   */\n  isValid(schema: RJSFSchema, formData: T, rootSchema: RJSFSchema) {\n    try {\n      // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n      // then rewrite the schema ref's to point to the rootSchema\n      // this accounts for the case where schema have references to models\n      // that lives in the rootSchema but not in the schema in question.\n      const result = this.ajv\n        .addSchema(rootSchema, ROOT_SCHEMA_PREFIX)\n        .validate(this.withIdRefPrefix(schema), formData);\n      return result as boolean;\n    } catch (e) {\n      return false;\n    } finally {\n      // make sure we remove the rootSchema from the global ajv instance\n      this.ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n    }\n  }\n\n  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n   * This is used in isValid to make references to the rootSchema\n   *\n   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it\n   * @protected\n   */\n  protected withIdRefPrefix(schemaNode: RJSFSchema): RJSFSchema {\n    if (schemaNode.constructor === Object) {\n      return this.withIdRefPrefixObject({ ...schemaNode });\n    }\n    if (Array.isArray(schemaNode)) {\n      return this.withIdRefPrefixArray([...schemaNode]);\n    }\n    return schemaNode;\n  }\n}\n","import { ValidatorType } from \"@rjsf/utils\";\n\nimport { CustomValidatorOptionsType } from \"./types\";\nimport AJV6Validator from \"./validator\";\n\n/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if\n * provided.\n *\n * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance\n */\nexport default function customizeValidator<T = any>(\n  options: CustomValidatorOptionsType = {}\n): ValidatorType<T> {\n  return new AJV6Validator<T>(options);\n}\n","import customizeValidator from \"./customizeValidator\";\n\nexport { customizeValidator };\nexport * from \"./types\";\n\nexport default customizeValidator();\n"],"names":["AJV_CONFIG","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","COLOR_FORMAT_REGEX","DATA_URL_FORMAT_REGEX","ROOT_SCHEMA_PREFIX","AJV6Validator","constructor","options","this","ajv","additionalMetaSchemas","customFormats","ajvOptionsOverrides","Ajv","addFormat","Array","isArray","addMetaSchema","isObject","Object","keys","forEach","formatName","createAjvInstance","toErrorSchema","errors","length","reduce","errorSchema","error","property","message","path","toPath","parent","splice","segment","slice","__errors","concat","toErrorList","fieldPath","errorList","ERRORS_KEY","map","join","stack","acc","key","createErrorHandler","formData","handler","addError","push","formObject","value","unwrapErrorHandler","errorHandler","transformRJSFValidationErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","newFormData","validationError","validate","err","noProperMetaSchema","includes","$schema","userErrorSchema","mergeValidationData","withIdRefPrefixObject","node","REF_KEY","startsWith","withIdRefPrefix","withIdRefPrefixArray","i","isValid","rootSchema","addSchema","removeSchema","schemaNode","customizeValidator","index"],"mappings":"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"}
\ No newline at end of file
