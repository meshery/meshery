<!DOCTYPE html>
<html lang="en" class="no-js">
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>
  <head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.55.6" />

<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

<link rel="alternate" type="application/rss&#43;xml" href="/v0.4/index.xml">

<link rel="shortcut icon" href="/v0.4/assets/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/v0.4/assets/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="36x36">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="48x48">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="72x72">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="96x196">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-192x192.png"sizes="192x192">

<title>Documentation</title>
<meta property="og:title" content="Documentation" />
<meta property="og:description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:4000" />
<meta property="og:site_name" content="http://localhost:4000" />

<meta itemprop="name" content="Documentation">
<meta itemprop="description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Documentation"/>
<meta name="twitter:description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
"/>

<link rel="stylesheet" href="/v0.4/assets/css/main.css">
<link rel="stylesheet" href="/v0.4/assets/css/palette.css">
<link rel="stylesheet" href="/v0.4/assets/css/anchorjs.css">
<link rel="stylesheet" href="/v0.4/assets/css/sass.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">

<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>
  <!-- Anchorjs included for adding hover anchor links to headings -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs  /anchor-js/4.2.2/anchor.min.js"></script>
  <script>
    $(function() {
  /** AnchorJS options and selector */
   anchors.options = {
      visible : 'hover',
      placement: 'left'
   };
   anchors.add('h1, h2, h3, h4, h5');
   });
   </script>
</head>
<style>

</style>
  <body class="td-section">
    <header>
  <nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
    <a class="navbar-brand" href="/v0.4/">
      <div class="navbar-logo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 279.49 51.83"><defs><style>.cls-1{fill:#00d3a9}.cls-2{fill:#00b39f}.cls-3{fill:#fff}</style></defs><title>Asset 14</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polygon points="26.68 12.21 26.68 24.59 37.4 18.38 26.68 12.21" class="cls-1"/><polygon points="26.68 27.18 26.68 39.62 37.5 33.43 26.68 27.18" class="cls-1"/><polygon points="25.13 24.51 25.13 12.32 14.54 18.39 25.13 24.51" class="cls-2"/><path d="M3.88,39.58a26,26,0,0,0,8.22,8.27v-13Z" class="cls-2"/><polygon points="25.13 39.56 25.13 27.27 14.51 33.42 25.13 39.56" class="cls-2"/><polygon points="13.64 47.07 24.4 40.92 13.64 34.7 13.64 47.07" class="cls-1"/><polygon points="38.24 47.14 38.24 34.79 27.5 40.93 38.24 47.14" class="cls-2"/><path d="M48.76,38.14A25.71,25.71,0,0,0,51.8,27L40.6,33.44Z" class="cls-2"/><polygon points="39.78 32.13 50.58 25.95 39.78 19.75 39.78 32.13" class="cls-1"/><polygon points="38.24 17.08 38.24 4.81 27.55 10.94 38.24 17.08" class="cls-2"/><polygon points="38.24 32.07 38.24 19.68 27.52 25.89 38.24 32.07" class="cls-2"/><polygon points="25.9 51.83 25.91 51.83 25.9 51.83 25.9 51.83" class="cls-2"/><polygon points="13.64 19.66 13.64 32.14 24.43 25.89 13.64 19.66" class="cls-1"/><path d="M25.13,0A25.75,25.75,0,0,0,13.75,3L25.13,9.55Z" class="cls-2"/><polygon points="13.64 4.72 13.64 17.13 24.44 10.93 13.64 4.72" class="cls-1"/><path d="M12.1,4a26,26,0,0,0-8.22,8.27L12.1,17Z" class="cls-2"/><path d="M38.17,3.07A25.8,25.8,0,0,0,26.68,0V9.65Z" class="cls-1"/><path d="M0,26.82A25.76,25.76,0,0,0,3.1,38.24l8.32-4.82Z" class="cls-1"/><path d="M3.1,13.58A25.67,25.67,0,0,0,0,24.94l11.44-6.55Z" class="cls-1"/><path d="M13.73,48.8a25.81,25.81,0,0,0,11.4,3V42.28Z" class="cls-2"/><path d="M48,12.28A25.91,25.91,0,0,0,39.78,4V17Z" class="cls-1"/><path d="M39.78,47.8A26,26,0,0,0,48,39.48l-8.21-4.73Z" class="cls-1"/><path d="M51.8,24.88a25.84,25.84,0,0,0-3.07-11.27l-8.24,4.77Z" class="cls-2"/><path d="M26.68,51.82a25.81,25.81,0,0,0,11.37-3L26.68,42.24Z" class="cls-1"/><polygon points="12.1 32.03 12.1 19.79 1.47 25.88 12.1 32.03" class="cls-2"/><polygon points="197.13 19 197.13 20.13 197.13 25.45 197.13 31.94 197.13 41.41 222.35 41.41 222.35 36.09 202.45 36.09 202.45 31.94 202.45 30.77 217.74 30.77 217.74 25.45 202.45 25.45 202.45 20.13 222.35 20.13 222.35 14.81 197.13 14.81 197.13 19" class="cls-3"/><polygon points="100.14 19 100.14 20.13 100.14 25.45 100.14 31.94 100.14 41.41 125.35 41.41 125.35 36.09 105.46 36.09 105.46 31.94 105.46 30.77 120.74 30.77 120.74 25.45 105.46 25.45 105.46 20.13 125.35 20.13 125.35 14.81 100.14 14.81 100.14 19" class="cls-3"/><path d="M160.26,34.46a6.61,6.61,0,0,1-.55,2.69,7,7,0,0,1-1.51,2.22A7.34,7.34,0,0,1,156,40.86a6.7,6.7,0,0,1-2.71.55H128.38v-5.6h24.89a1.35,1.35,0,0,0,1.35-1.35V32.29A1.33,1.33,0,0,0,153.27,31H135.36a6.78,6.78,0,0,1-2.69-.55,7.19,7.19,0,0,1-2.24-1.51,7,7,0,0,1-1.5-2.23,6.62,6.62,0,0,1-.55-2.7V21.8a6.75,6.75,0,0,1,.55-2.72,7,7,0,0,1,1.5-2.21,7.19,7.19,0,0,1,2.24-1.51,6.61,6.61,0,0,1,2.69-.55h24.9v5.64h-24.9a1.27,1.27,0,0,0-1,.39,1.31,1.31,0,0,0-.4,1V24a1.31,1.31,0,0,0,.4,1,1.27,1.27,0,0,0,1,.39h17.91a6.7,6.7,0,0,1,2.71.55,7.11,7.11,0,0,1,3.73,3.72,6.74,6.74,0,0,1,.55,2.71Z" class="cls-3"/><path d="M193.81,41.41h-5.07V31H169V41.41h-5.08V25.31h24.86V14.81h5.07ZM169,22.81h-5.08v-8H169Z" class="cls-3"/><polygon points="266.19 24.12 259.55 14.81 252.9 14.81 263.54 30.77 263.54 41.41 268.86 41.41 268.86 30.77 279.49 14.81 272.93 14.81 266.19 24.12" class="cls-3"/><path d="M231.4,19.88H245v5.53h-11v5.08h2.52l9.65,10.92h6.57l-9.65-10.92h3.76A4.13,4.13,0,0,0,251,26.36V18.94a4.13,4.13,0,0,0-4.13-4.13H226.19v26.6h5.32Z" class="cls-3"/><path d="M96.05,41.41H90.41V22a1.38,1.38,0,0,0-.13-.6,1.56,1.56,0,0,0-.33-.5,1.77,1.77,0,0,0-.5-.34,1.53,1.53,0,0,0-.6-.12H62.78V14.81H88.85a6.88,6.88,0,0,1,2.78.57,7.08,7.08,0,0,1,3.85,3.85A6.88,6.88,0,0,1,96.05,22Zm-27.63,0H62.78v-21l5.64-1.55Zm13.8,0H76.58v-18h5.64Z" class="cls-3"/></g></g></svg><span class="font-weight-bold" style="vertical-align: bottom"
          >Documentation</span
        >
      </div>
    </a>
    <div class="td-navbar-nav-scroll ml-md-au to" id="main_navbar">
      <ul class="navbar-nav mt-2 mt-lg-0">
        <!--
			<li class="nav-item mr-4 mb-2 mb-lg-0">
        <a class="nav-link" href="https://github.com/layer5io/meshery" target="_        blank"><span>GitHub</span></a>
      </li>  -->

        <!-- Internal links -->

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="/v0.4/inst        allation/quick-start"
            ><span>Quick Start</span></a
          >
        </li>

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="/v        0.4/installation/platforms"
            ><span>All Platforms</span></a
          >
        </li>

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-lin        k"
            href="https://meshery.io"
            ><span>Project</span></a
          >
        </li>

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="n        av-link"
            href="http://slack.layer5.io"
            ><span>Slack</span></a
          >
        </li>

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-lin        k"
            href="https://github.com/layer5io/meshery"
            ><span>GitHub</span></a
          >
        </li>

        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <        a
            class="nav-link"
            href="/v0.4/es"
            ><span>🇲🇽 Español</span></a
          >
        </li>

      </ul>
    </div>
            <!--Version Selector -->

            <select onchange="window.location=this.value" class="appearance-none flex-1 w-full px-0 py-1 placeholder-gray-900 tracking-wide focus:outl              i    ne-none version-selector" name="versioningSelection" id="versioningSelection">
              <!-- <option value="">Versions</option> -->


              <!-- we get the version selected, and put it to the right option  --><option  value="/v0.4" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>v0.4</span>
              </option>
              <!-- we get the version selected, and put it to the right option  --><option  value="/" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>latest</span>
              </option>
              <!-- we get the version selected, and put it to t              he right option  --><opti        on  value="/v0.5" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>v0.5</span>
              </option>

              </select>

            </ul>
        </div>

    <!--Search Bar
    <div class="navbar-nav d-none d-lg-block"><input type="search" class="form-control td-search-input" placeholder="&#xf002 Search this site…" aria-label="Search this site…" autocomplete="off"></div>-->

    <!-- meshery-custom-begin

	<div class="navbar-nav d-none d-lg-block">
          <a class="gh-source" data-gh-source="github" href="https://github.com/layer5io/meshery" title="Go to repository" data-md-state="done">
          <div class="gh-source__repository">
            <i class="fab fa fa-github fa-2x" style='padding-right:20px; float:left; margin-top:5px'></i>
            layer5io/meshery
          <ul class="gh-source__facts"><li class="gh-source__fact" id='stars'></li><li id="forks" class="gh-source__fact"></li></ul></div></a>
        </div>
      </div>

meshery-custom-end -->
  </na v>
</header>

<!-- meshery-custom-begin

<script>
$(document).ready(function() {
  var url = "https://api.github.com/search/repositories?q=layer5io/meshery";
  fetch(url, {
      headers: {"Accept":"application/vnd.github.preview"}
  }).then(function(e) {
    return e.json()
  }).then(function(r) {
     console.log(r.items[0])
     stars = r.items[0]['stargazers_count']
     forks = r.items[0]['forks_count']
     $('#stars').text(stars + " Stars")
     $('#forks').text(forks + " Forks")
  });
});
</script>

meshery-custom-end -->

    <div class="container-fluid td-outer">
      <  div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          <div id="td-sidebar-menu" class="td-sidebar__inner">
  <form class="td-sidebar__search d-flex align-items-center">
 <input type="search" class="form-control td-search-input fas fa-search" placeholder="&#xf002" aria-label="Search this site…" autocomplete="off">
    <button class="btn btn-link td-sidebar__toggle d-md-none   p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target=  "#td-section-nav" aria-controls="td-docs-nav" ar    i    a-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>

  <nav class="collapse td-sidebar-nav pt-2 pl-4" id="td-section-nav">

  <ul class="td-    sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/" class="align-le              ft pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Documentation</a>
    </li>

      <ul>
        <li class="collapse show" id="documentation">
            <ul class="td-sidebar-nav__se              c            tion pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/overview" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Overview</a>
                          </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/project" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Project</a>
              <              /            li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/installation/quick-start" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Quick Start</a>
              </              l            i>


              <li cl  a        ss="td-si  debar-nav__section-title">
                <a h    r    ef="/v0.4/installation/platforms" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Supported Platforms</a>
              </li>


          </ul>
      </u    l>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section-title">
                    <a  href="/v0.4/concepts" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Concepts</a>
    </li>

      <ul>
        <li class="collapse show" id="concepts">
            <ul class=              "            td-sidebar-nav__section pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/concepts/architecture" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Archi              t            ecture</a>
              </  l        i>


                <li class="td-sidebar-nav__section-    t    itle">
                <a href="/v0.4/concepts/architecture/adapters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Adapters</a>
              </li>


              </ul>
      </ul>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section              -title">
      <a  href="/v0.4/functionality" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Functionality</a>
    </li>

      <ul>
        <li class="collapse show" id="functionality">
            <ul c              l            ass="td-sidebar-nav__section pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/functionality/lifecycle-management" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Lifecyc              l            e Management</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/functionality/performance-management" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Performanc              e             Management</a>
                        </li>


              <li class="td-sidebar-nav__sec    t    ion-title">
                <a href="/v0.4/functionality/service-mesh-interface" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Service Mesh Interface (SMI)</a>
                  </li>


          </ul>
      </ul>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li cl              ass="td-sidebar-nav__section-title">
      <a  href="/v0.4/service-meshes" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Service Meshes</a>
    </li>

      <ul>
        <li class="collapse               s            how" id="service-meshes">
            <ul class="td-sidebar-nav__section pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/app-mesh" class="align-left pl-0                           pr-2 td-sidebar-link td-sidebar-link__section">App Mesh</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/cpx" class="align-left               p            l-0 pr-2 td-sidebar-link td-sidebar-link__section">Citrix Service Mesh</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/consul              "             class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Consul</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapte              r            s/istio" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Istio</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapt              e            rs/kuma" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Kuma</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/linker              d            " class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Linkerd</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/nsm" class="a              l            ign-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Network Service Mesh</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/n              g            inx-sm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">NGINX Service Mesh</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes              /            adapters/octarine" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Octarine</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/servic              e            -meshes/adapters/osm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Open Service Mesh</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/servi              c            e-meshes/adapters/tanzu-sm"   c        lass="ali  gn-left pl-0 pr-2 td-sidebar-link td-sidebar-lin    k    __section">Tanzu</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/traefik-mesh" cl    ass="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Traefik Mesh</a>
              </li>


                        </ul>
      </ul>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/guides" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-lin              k            __section">Guides</a>
    </li>

      <ul>
        <li class="collapse show" id="guides">
            <ul class="td-sidebar-nav__section pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0              .            4/guides/sample-apps" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Deploying Sample Applications</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                                          <a href="/v0.4/guides/meshery-metrics" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Integrating Prometheus and Grafana</a>
              </li>


              <li class="td-sidebar-n              a            v__section-title">
                <a href="/v0.4/guides/upgrade" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Upgrading Meshery</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v  0        .4/guides  /mesheryctl" class="align-left pl-0 pr-2 td-side    b    ar-link td-sidebar-link__section">Using mesheryctl</a>
              </li>


              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/multiple-adap    ters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Using Multiple Meshery Adapters</a>
                            </li>


          </ul>
      </ul>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/extensibility" class="align-left pl-0 pr-2 active                           td-sidebar-link td-sidebar-link__section">Extensibility</a>
    </li>

      <ul>
        <li class="collapse show" id="extensibility">
            <ul class="td-sidebar-nav__section pr-md-3">

              <li class="td-s              i            debar-nav__section-title">
                <a href="/v0.4/extensibility/adapters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Service Mesh Adapters</a>
              </li>


                                        <li class="td-sidebar-nav__s  e        ction-tit  le">
                <a href="/v0.4/extensibili    t    y/load-generators" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Load Generators</a>
              </li>


              <li class="td-sidebar-nav__sectio    n-title">
                <a href="/v0.4/extensibility/providers" class="align-left pl-0 pr-2 td-sidebar-link td-sideb              ar-link__section">Providers</a>
              </li>


          </ul>
      </ul>

  </ul>

  <ul class="td-sidebar-nav__section pr-md-3">


    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/reference"               c            lass="align-left pl-0 pr-2 a  c        tive td-s  idebar-link td-sidebar-link__section">Reference</a>
    </li>

      <ul>
        <li class="collapse show" id="reference">
            <ul class="td-sidebar-nav__section pr-md-3">

              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/reference/mesheryctl" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">mesheryctl Command Reference</a>
              </li>


          </ul>
      </ul>

  </ul>

  </nav>
</div>
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
              <div class="td-page-meta ml-2 pb-1 pt-2 mb-0">
                  <strong>Tools</strong>
<a href="https://github.com/layer5io/meshery/issues/new?assignees=&labels=area/docs&template=documentation.md&title=&#91;Docs&#93;"      target="_blank"><i class="fab fa-github fa-fw"></i> Create doc issue</a>
<a href="https://github.com/layer5io/meshery/blob/master/docs/pages/search.html" target="_blank"><i class="fa fa-edit fa-fw"></i> Edit this page</a>
<strong>Contents</strong>


<!-- this will parse through the header fields and add a button to open
     an issue / ask a question on Github. The editable field should be in
     the post frontend matter, and refer to the label to open the issue for -->


              </div>
              <nav id="TableOfContents"><ul>
              <li>  <ul id =  "TOC">
                <!-- Links will be appended here-->
              </ul></li>
              </ul></nav>
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            <nav aria-label="breadcrumb" class="d-none d-md-block d-print-none">
	      <ol class="breadcrumb spb-1">
                <li class="breadcrumb-item active            " aria-current="page">
      <!-- meshery-custom-begin -->
        <div id="breadcrumbs">

<a href="/v0.4/">home</a>


    /


</div>

<!-- <a href="http://idratherbewriting.com" class="noCrossRef productSubtitle"> Home </a> > <a class="noCrossRef productSubtitle" href="http://localhost:4000">Learn API Doc</a> > search.html -->

	      <!-- <a href="/v0.4/search/"></a> -->
		  <!-- meshery-custom-end -->
                </li>
	      </ol>
           </nav>
           <div class="td-content"		>

					 					           <h1></h1>

	           <input class="form-control td-search-input fa fa-search" type="search" name="q" id="search-input" placeholder="&#xf002 Search this site…"  style="margin-top:5px" autofocus>
<i style="color:white; margin-right:8px; margin-left:5px" class="fa fa-search"></i>

<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>

<ul id="search-results"></ul>

<script>
	window.data = {







					"es-project-contributing-flow": {
						"id": "es-project-contributing-flow",
						"title": "Contribuir Flujo",
						"categories": "",
						"url": " /es/project/contributing-flow",
						"content": "Trabajando por Fork\n\nSimplemente dirígete a la página de GitHub y haz clic en el botón “Fork”. Es así de simple. Una vez que hayas hecho eso, puedes usar tu cliente git favorito para clonar tu repositorio o simplemente dirigirse directamente a la línea de comando:\n\nClona tu fork en tu máquina local\n\ngit clone git@github.com:USERNAME/FORKED-PROJECT.git\n\n\nMantener Tu Fork Actualizado\nSi bien este no es un paso necesario, si planeas hacer algo más que una pequeña solución rápida, querrás asegurarte de mantener tu fork actualizado rastreando el repositorio “upstream” original al que hiciste “fork”. Para hacer esto, deberás agregar un remoto:\n\nAgregar repositorio ‘upstream’ a la lista de remotos\n\ngit remote add upstream https://github.com/layer5io/meshery.git\n\n\n(“meshery” se usa como repositorio de ejemplo. Asegúrate de hacer referencia al repositorio actual al que está contribuyendo, por ejemplo, “meshery-linkerd”).\n\nVerifica el nuevo repositorio remoto llamado ‘upstream’\n\ngit remote -v\n\n\nSiempre que quieras actualizar tu fork con los últimos cambios de ‘upstream’, primero deberás buscar las ramas del repositorio ‘upstream’ y los últimos “commits” para llevarlos a tu repositorio:\n\nObtener desde el remoto ‘upstream’\n\ngit fetch upstream\n\n\nVer todas las ramas, incluidas las de ‘upstream’\n\ngit branch -va\n\n\nAhora, revisa tu rama “master” y combina la rama “master” del repositorio ‘upstream’:\n\nHaz “checkout” a tu rama “master” y haz “merge” de ‘upstream’\n\ngit checkout master\ngit merge upstream/master\n\n\nSi no hay “commits” únicos en la rama “master” local, git simplemente realizará un “fast-forward”. Sin embargo, si has realizado cambios en “master” (en la gran mayoría de los casos, probablemente no deberías hacerlo), consulta la siguiente sección, es posible que tengas que lidiar con conflictos. Al hacerlo, ten cuidado de respetar los cambios realizados anteriormente.\n\nAhora, tu rama “master” local está actualizada con todo lo modificado en ‘upstream’.\n\nCrear una “Branch” (haciendo tu trabajo)\nSiempre que comiences a trabajar en una nueva función o corrección de “bugs”, es importante que crees una nueva rama. No solo es un flujo de trabajo de git adecuado, sino que también mantiene tus cambios organizados y separados de la rama “master” para que puedas enviar y administrar fácilmente múltiples “pull requests” para cada tarea que completes.\n\nPara crear una nueva rama y comenzar a trabajar en ella, realiza el siguiente flujo.\n\nConsulta la rama “master”: quieres que tu nueva rama provenga de la rama “master”.\n\ngit checkout master\n\n\nCrea una nueva rama (dale a tu rama su propio nombre informativo simple)\n\nPara mejoras, utiliza feature/tu_nombre/issue# o feature/tu_nombre/nombre_del_feature\n\nPara “bugs” usa bug/tu_nombre/issue# o bug/tu_nombre/nombre_del_bug\n\ngit branch feature/jdoe/567\n\n\nCambia a tu nueva rama\n\ngit checkout feature/jdoe/567\n\n\nAhora, ve a la ciudad hackeando y haciendo los cambios que quieras.\n\nEnviar tus cambios (un “Pull Request”)\n\nAntes de enviar tu “pull request”, es posible que quieras hacer algunas cosas para limpiar tu rama y hacer que sea lo más simple posible para que el “maintainer” del repositorio original pruebe, acepte y haga “merge” de tu trabajo.\n\nEn el tiempo que has estado trabajando en tus cambios, si se han hecho “commits” en la rama “master” ‘upstream’, deberás hacer “rebase” a tu rama de desarrollo para que al hacerle “merge” sea un “fast-forward” simple que no requiera ninguna trabajo de resolución de conflictos.\n\nObten los cambios de “master” ‘upstream’ y haz “merge” con la rama “master” de tu repositorio\n\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\n\n\nSi hubo nuevos “commits”, haz “rebase” a tu rama de desarrollo\n\ngit checkout feature/jdoe/567\ngit rebase master\n\n\nAhora, puede ser deseable reducir algunos de tus “commits” más pequeños al juntarlos en una pequeña cantidad de “commits” más grandes y cohesivos. Puedes hacer esto con un “rebase” interactivo:\n\nHaz “rebase” a todos tus “commits” en tu rama de desarroll					o				\		n				\ngit ch					eckout\ngit rebase -i master\n\n\nEsto abrirá un editor de texto donde puedes especificar que “commits” aplastar.\n\nEntrega\n\nUna vez que hayas hecho tus “commits” y enviado todos tus cambios a GitHub, ve a la página de tu “fork” en GitHub, selecciona tu rama de desarrollo y haz clic en el botón de “pull request”. Si necesitas realizar algún ajuste en tu “pull request”, simplemente envía las actualizaciones a GitHub. Tu “pull request” rastreará automáticamente los cambios en tu rama de desarrollo y se actualizará."
					}




					,

					"project-faq": {
						"id": "project-faq",
						"title": "FAQ",
						"categories": "",
						"url": " /project/faq",
						"content": "Question: Why was Meshery created?\n\nAnswer: As an open source, vendor neutral project, Meshery was created out the necessity to enable service mesh adopters to overcome the challenge of complex virtual networking; to come to expect more from their infrastruc					t				u		r				e; to en					able the world to understand and operate any service mesh with confidence.\n\n\nDon't find an answer to your question here? Ask in the #support channel in the Layer5 Slack.\n\nWhat is the difference between make run-local and mesheryctl system start? Do they both run Meshery on my local machine?\n\nAnswer: Yes, both of them do run Meshery on your local machine. make run local builds Meshery from source and runs it on your local OS, while mesheryctl system start runs Meshery as a set of containers in Docker on your local machine."
					}




					,

					"concepts-architecture-adapters": {
						"id": "concepts-architecture-adapters",
						"title": "Adapters",
						"categories": "",
						"url": " /concepts/architecture/adapters",
						"content": "As the multi-mesh manager, Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n\nWhat are Meshery Adapters?\n\nAdapters allow Meshery to interface with the different service meshes, exposing their differentiated value to users.\n\nMeshery has adapters for managing the following service meshes.\n\n\n  \n    \n      Adapter Status\n      Service Mesh\n      Service Mesh Version\n      Port\n    \n  \n  \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Consul\n      v1.8.2\n      10002/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Istio\n      v1.8.1\n      10000/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Linkerd\n      v2.5.0\n      10001/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Open Service Mesh\n      v0.5.0\n      10009/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Octarine\n      v1.0\n      10003/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Network Service Mesh\n      v0.2.1\n      10004/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Kuma\n      v1.0\n      10007/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Citrix Service Mesh\n      1.0\n      10008/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Traefik Mesh\n      v1.0\n      10006/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for NGINX Service Mesh\n      v0.6.0\n      10010/tcp\n    \n    \n      alpha\n       Meshery Adapter for Meshery Adapter for Tanzu Service Mesh\n      pre-GA\n      10010/tcp\n    \n    \n      alpha\n       Meshery Adapter for Meshery Adapter for App Mesh\n      v0.1.0\n      10005/tcp\n    \n  \n\n\nAdapter FAQs\n\nIs each service mesh adapter made equal?\nNo, different service mesh adapters are written to expose the unique value of each service mesh. Consequently, they are not equally capable just as each service mesh is not equally capable as the other.\n\nAdapters have a set of operations which are grouped based on predefined operation types. See the extensibility page for more details on adapter operations.\n\nHow can I create a new adapter?\n\nSee the extensibil					i				t		y				 documen					tation for details on how new Meshery adapters are made.\n\nCan I run more than one instance of the same Meshery adapter?\nThe default configuration of a Meshery deployment includes one instance of each of the Meshery adapters (that have reached a stable version status). You may choose to run multiple instances of the same type of Meshery adapter; e.g. two instances of the meshery-istio adapter. To do so, modify ~/.meshery/meshery.yaml to include multiple copies of the given adapter.\n\nSee the “Multiple Adapters” guide for more information."
					}




					,

					"extensibility-adapters": {
						"id": "extensibility-adapters",
						"title": "Extensibility: Service Mesh Adapters",
						"categories": "",
						"url": " /extensibility/adapters",
						"content": "What are Meshery Adapters?\n\nAdapters allow Meshery to interface with the different service meshes. Review the list of all available service mesh adapters. See the Meshery Architecture diagrams for visuals on how adapters relate to other Meshery components.\n\nMeshery upholds the following guiding principles for adapter design:\n\n\n  Adapters allow Meshery to interface with the different service meshes, exposing their differentiated value to users.\n    \n      Service mesh projects should be encouraged to maintain their own adapters. Allowing them to expose their differentiated capabilities encourages this.\n    \n  \n  Adapters should avoid wheel reinvention, but seek to leverage the functionality provided by service meshes under management.\n    \n      This both reduces sustaining costs and improves reliability.\n    \n  \n\n\nAdapter Capabilities\nMeshery communicates with adapters over grpc. Adapters establish communication with the service mesh. Adapters have a predefined set of operations which are grouped based on predefined operation types.\n\nThe predefined operation types are:\n\n\n  Install\n  Sample application\n  Config\n  Validate\n  Custom\n\n\nHow to create new adapter?\n\nMeshery uses adapters to manage and interact with different service meshes. Meshery adapters are written in Go. Whether you are creating a new adapter or modifying an existing adapter, be sure to read the Meshery Adapters design specification.\n\nTip: The Meshery Adapter for Istio is a good reference adapter to use as an example of a Meshery Adapter.\n\nMeshery Adapter Codebase Overview\n\nCommon libraries are used to avoid code duplication and apply DRY.\n\nMeshKit\n\nThe code hierarchy is pluggable and independent from one another. There can be N number of packages depending upon the use case.\n\n  errors/ - holds the implementations and the error handlers and error codes which are used across projects.\n  logger/ - holds the implementations of logging handler and custom attributes to add if any.\n  utils/ - holds all the utility functions that are specific to meshery projects and are to be used generically across all of them.\n  tracing/ - holds the implementations of tracing handlers with different tracing providers like jaeger,newrelic, etc.\n\n\nEach package inside a meshkit is a handler interface implementation, the implementation could be from any third-party packages or the go-kit.\n\nMeshery Adapter Libary\n\nThis section contains a high level overview of the meshery-adapter-library, its purpose and architecture. For details, the reader is referred to the documentation and the code in the repository.\n\nThe main purpose of the meshery-adapter-library is to:\n\n  provide a set of interfaces, some with default implementations, to be used and extended by adapters.\n  implement common cross cutting concerns like logging, errors, and tracing\n  provide a mini framework implementing the gRPC server that allows plugging in the mesh specific configuration and - operations implemented in the adapters.\n  provide middleware extension points\n\n\nOverview and Usage\nThe library consists of interfaces and default implementations for the main and common functionality of an adapter. It also provides a mini-framework that runs the gRPC adapter service, calling the functions of handlers injected by the adapter code. This is represented in an UML-ish style in the figure below. The library is used in all of Meshery’s adapters.\n\nMeshery Adapter for XXX Service Mesh\n\nDevelopment Process\nWith the CONTRIBUTING.md in mind, understand that development follows the usual fork-and-pull request workflow described here, see also GitHub Process. On forking GitHub deactivates all workflows. It is safe and good practice to activate them such that the code is validated on each push. This requires that branches filter for “on push” is set to ‘**’ to be triggered also on branches containing ‘/’  in their name.  The actions are parameterized using secrets (see Build &amp; Release Strategy). The Docker image is only built and pushed to Docker Hub if a tag is pushed and the corresponding authentication information is configured. The only secret that should be set in each fork is GO_VERSION, specified in Build &amp; Release Strategy, otherwise, the corresponding action’s default version is used.\n\nEach commit has to be signed off, see Contributing Overview.\n\nRunning an adapter as a container\nTesting your local changes running as a container can be accomplished in two ways:\n\n\n  Define the adapter’s address in the UI: Unless the running container is named as specified in the docker-run target in the Makefile, the container has to be removed manually first. Then, run make docker followed by make docker-run. Then, connect to the adapter in the UI in “Settings&gt;Service Meshes” using localhost:&lt;port&gt; if the meshery server is running as a binary, or : if it is running as a docker container.\n  Using meshery					c				t		l				: In ~/.					meshery/meshery.yaml, change the tag specifying the image of the adapter to “latest”. Run make docker, followed by mesheryctl system start --skip-update. This assumes mesheryctl system start has been executed at least once before.\n\n\nRunning an adapter as a process\n\nAnother way to test your local changes is to run the adapter as a process. To do this, clone the meshery repository, and start meshery using make run-local-cloud. Start the adapter from your IDE, or by executing make run. Then, in the meshery interface, add the adapter using “localhost:”."
					}




					,

					"installation-platforms-aks": {
						"id": "installation-platforms-aks",
						"title": "AKS",
						"categories": "",
						"url": " /installation/platforms/aks",
						"content": "Quick Start with AKS \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on AKS:\n\n\n  Connect Meshery to your AKS cluster\n    \n      Meshery CLI (mesheryctl)\n      Azure CLI (az)\n    \n  \n  Install Meshery on your AKS cluster\n  Access Meshery’s UI\n\n\nConnect Meshery to Azure Kubernetes Cluster\n\nThe following set of instructions expects you to have created a AKS cluster in your resource group Configure Meshery to connect to your AKS cluster by executing:\n\n\n \n mesheryctl system config aks\n \n \n\nManual Steps\n\nAlternatively, you may execute the following steps to manually configure Meshery to connect to your AKS cluster.\n\n\n  \n    Install Azure CLI(az), and login\nto your azure account using az login.\n  \n  \n    After successfull login, you have to select the subscription with which your AKS is associated with\n  \n\n\n \n az account set --subscription \n \n \n\n  Get the kubeconfig from your AKS cluster\n\n\n \n az aks get-credentials --resource-group  --name \n \n \n\n  Set your cluster context and check your cluster-info\n\n\n \n kubectl set-context \n kubectl cluster-info\n \n \n\nInstall Meshery into your AKS cluster\n\n\n \n $ k					u				b		e				ctl crea					te ns meshery\n $ helm repo add meshery https://meshery.io/charts/\n $ helm install meshery --namespace meshery meshery/meshery\n \n \n\nPort forward to the Meshery UI\n\n\n \n export POD_NAME=$(kubectl get pods --namespace meshery -l \"app.kubernetes.io/name=meshery,app.kubernetes.io/instance=meshery\" -o jsonpath=\"{.items[0].metadata.name}\")\n kubectl --namespace meshery port-forward $POD_NAME 8080:8080\n \n \n\nMeshery should now be running in your AKS cluster and the Meshery UI should be locally accessible. Navigate to http://localhost:9081 to log into Meshery."
					}




					,

					"es-installation-platforms-aks":					 				{
						"					id": "es-installation-platforms-aks",
						"title": "AKS",
						"categories": "",
						"url": " /es/installation/platforms/aks",
						"content": "Inicio rápido con el Servicio Kubernetes de Azure (AKS)\n\nKubernetes administrado\n\nPara ejecutar Meshery en un ambiente administrado de Kubernetes, deberá asignar una ServiceAccount existente o crear una nueva ServiceAccount:\n\nNota: asegúrese de poder acceder a AKS con la CLI(Intérprete de Línes de comandos) de Azure (az) siguiendo la  Guía de inicio rápido de AKS .\n\n¡Las instrucciones completas estarán disponible pronto!"
					}




					,

					"extensibility-api": {
						"id": "extensibility-api",
						"title": "Extensibility: APIs",
						"categories": "",
						"url": " /extensibility/api",
						"content": "Meshery’s APIs\n\nEach of Meshery’s APIs are subject to the following authentication and authorization system.\n\nAuthentication\n\nRequests to any of the API endpoints must be authenticated and include a valid JWT access token in the HTTP headers. Type of authentication is determined by the selected Provider. Use of the Local Provider, 					“				N		o				ne”, put					s Meshery into single-user mode and does not require authentication.\n\nAuthorization\n\nCurrently, Meshery only requires a valid token in order to allow clients to invoke its APIs.\n\nEndpoints\n\nEach of the API endpoints are exposed through server.go. Endpoints are grouped by function (e.g. /api/mesh or /api/perf).\n\nAlternatively, Remote Providers can extend Meshery’s endpoints behind the /api/extensions/ endpoint.\n\nGraphQL\n\nMeshery provides a GraphQl API available through the default port of /tcp.\n\nREST\n\nMeshery provides a REST API available through the default port of 9081/tcp."
					}




					,

					"concepts-architecture": {
						"id": "concepts-architecture",
						"title": "Architecture",
						"categories": "",
						"url": " /concepts/architecture",
						"content": "Architectural Components and Their Languages\n\nMeshery and its components are written using the following languages and technologies.\n\n\n  \n    \n      Components\n      Languages and Technologies\n    \n  \n  \n    \n      Meshery Server\n      Golang, gRPC, GraphQL, SQLlite\n    \n    \n      Meshery Adapters\n      Golang, gRPC\n    \n    \n      Meshery WASM Filters\n      Rust and C++\n    \n    \n      Meshery UI\n      ReactJS, NextJS, BillboardJS\n    \n    \n      Meshery Provider UI\n      ReactJS, NextJS\n    \n    \n      Meshery Remote Providers\n      any - must adhere to Meshery Extension Points\n    \n    \n      Meshery Operator\n      Golang, NATS\n    \n    \n      MeshSync\n      Golang\n    \n    \n      Meshery Database\n      Golang, SQL\n    \n  \n\n\nDeployments\n\nMeshery deploys as a set of containers. Meshery’s containers can be deployed to either Docker or Kubernetes.\n\n\n\nClients\n\nMeshery’s REST API may be consumed by any number of clients. Clients need to present valid JWT token.\n\n\n\nProviders\n\nAs a point of extension, Meshery supports two types of providers: Local and Remote.\n\n\n\nObject Model\n\nThis diagram outlines logical constructs within Meshery and their relationships.\n\n\n\nMeshery Operator and MeshSync\n\nMeshery Operator is the multi-service mesh operator (a Kubernetes custom controller) that manages MeshSync and it’s messaging broker.\n\n\n\nSee the Operator section for more information on the function of an operator and MeshSync section for more information on the function of meshsync.\n\nDatabase\n\nMeshery Server’s database is responsible for collecting and centralizing the state of all elements under management, including infrastructure, application, and Meshery’s own components. Meshery’s database, while persisted to file, is treated as a cache.\n\n\n\nSee the Database section for more information on the function of the database.\n\nNetwork Ports\n\nMeshery uses the following list of network ports to interface with its various components:\n\n\n  \n    \n      Component\n      Port\n    \n  \n  \n    \n      Meshery REST API\n      9081/tcp\n    \n    \n      Meshery GraphQL\n      9081/tcp\n    \n    \n      Meshery Broker\n      4222/tcp, 6222/tcp, 8222/tcp, 7777/tcp, 7422/tcp, 7522/tcp\n    \n    \n      Learn Layer5 Application\n      10011/tcp\n    \n    \n      Meshery Adapters\n      10000+/tcp\n    \n    \n      Meshery Remote Providers\n      443/tcp\n    \n  \n\n\nAdapter Ports\n\n\n  \n    \n      Service Mesh\n      Port\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n                                               10005/tcp\n    \n    \n       Meshery Adapter for Consul\n                                               10002/tcp\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n                                               10008/tcp\n    \n    \n       Meshery Adapter for Istio\n                                               10000/tcp\n    \n    \n       Meshery Adapter for Kuma\n                                               10007/tcp\n    \n    \n       Meshery Adapter for Linkerd\n                                               10001/tcp\n    \n    \n       Meshery Adapter for NGINX Service Mesh\n                                               10010/tcp\n    \n    \n       Meshery Adapter for Network Service Mesh\n                                               10004/tcp\n    \n    \n       Meshery Adapter for Octarine\n                                               10003/tcp\n    \n    \n       Meshery Adapter for Open Service Mesh\n                                               10009/tcp\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n                                               10010/tcp\n    \n    \n       Meshery Adapter for Traefik Mesh\n                                               10006/tcp\n    \n  \n\n\nSee the Adapters section for more information on the function of an adapter.\n\nStatefulness in Meshery components\n\nSome components within Meshery’s architecture are concerned with persisting data while others are only\nconcerned with a long-lived configuration, while others have no state at all.\n\n\n  \n    \n      Components\n      Persistence\n      Description\n    \n  \n  \n    \n      mesheryctl\n      stateless\n      command line interface tha					t				 		h				as a con					figuration file\n    \n    \n      Meshery Adapters\n      stateless\n      interface with service meshes on a transactional basis\n    \n    \n      Meshery Server\n      caches state\n      application cache is stored in user’s $HOME/.meshery/ folder\n    \n    \n      Meshery Providers\n      stateful\n      location of persistent user preferences, environment, tests and so on\n    \n    \n      Meshery Operator\n      stateless\n      operator of Meshery custom controllers, notably MeshSync\n    \n    \n      MeshSync\n      stateless\n      Kubernetes custom controller, continuously running discovery"
					}




					,

					"es-architecture": {
						"id": "es-architecture",
						"title": "Arquitectura de Meshery",
						"categories": "",
						"url": " /es/architecture",
						"content": "Arquitectura\n\nLa arquitectura de Meshery puede ser vista desde dos perspectivas:\n\n1. Clientes\n2. Proveedores\n\n\n\n1. Arquitectura del Client\n\n\n\n2. Arquitectura del Proveedor\n\n\n\nPuertos de Red\n\nMeshery utiliza la siguiente lista de puertos de red para conectarse con sus múltiples componentes:\n\n\n  \n    \n      Applicación de Red\n      Puerto\n    \n  \n  \n    \n      Meshery REST API\n      9081/tcp\n    \n    \n      Learn Layer5 Application\n      10011\n    \n  \n\n\nPuertos del Adaptador\n\n\n  \n    \n      Service Mesh\n      Puerto\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n                                               10005/tcp\n    \n    \n       Meshery Adapter for Consul\n                                               10002/tcp\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n                                               10008/tcp\n    \n    \n       Meshery Adapter for Istio\n                                               10000/tcp\n    \n    \n       Meshery Adapter for Kuma\n                                               10007/tcp\n    \n    \n       Meshery Adapter for Linkerd\n                                               10001/tcp\n    \n    \n       Meshery Adapter for NGINX Service Mesh\n                                               10010/tcp\n    \n    \n       Meshery Adapter for Network Service Mesh\n                                               10004/tcp\n    \n    \n       Meshery Adapter for Octarine\n                                               10003/tcp\n    \n    \n       Meshery Adapter for Open Service Mesh\n                                               10009/tcp\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n                                               10010/tcp\n    \n    \n       Meshery Adapter for Traefik Mesh\n                                               10006/tcp\n    \n  \n\n\nVéase la sección de Adaptadores para más información sobre el funcionamiento de un adaptador.\n\n**Estado en los componentes de Meshery **\n\nAlgunos componentes dentro la arquitectura de Meshery se preocupan por la persistencia de datos mientras que otros se preocupan por una configuración duradera, mien					t				r		a				s		 				que otro					s no lo consideran.\n\n\n  \n    \n      Componentes\n      Persistencia\n      Descripción\n    \n  \n  \n    \n      mesheryctl\n      stateless\n      interface de línea de comando con un archivo de configuración\n    \n    \n      Adaptadores de Meshery\n      stateless\n      interface con service meshes con una base transaccional\n    \n    \n      Servidor de Meshery\n      caché de estado\n      caché de aplicación guardada en la carpeta de usuario $HOME/.meshery/`\n    \n    \n      Proveedores de Meshery\n      stateful\n      ubicación de preferencias persitentes de usuario, ambiente, pruebas, entre otros"
					}






					,

					"concepts-architecture-broker": {
						"id": "concepts-architecture-broker",
						"title": "Broker",
						"categories": "",
						"url": " /concepts/architecture/broker",
						"content": "Broker is a custom kubernetes controller that empowers data streaming across different components of meshery, which are either inside or outside of the kubernetes cluster.\n\nBroker FAQs\n=======\nBroker is a custom Kubernetes controller that provides data streaming across independent components of Meshery whether those components are running inside or outside of the Kubernetes cluster.\n\nBroker FAQs\n\nHow many Brokers can run?\nIt is recommended to run one broker instance for each kubernetes cluster, However the instance itself can be scaled up based on the incoming data volume in each of the cluster. The scaling is independent of the number of instances running.\n\nWhat does an HA configuration look like?\nWe leverage on the kubernetes functionality in terms of the High-Availability behaviour. Meaning, the broker instance gets instantiated/restarted on its own when an issue occurs. In part, Meshery-Operator is also resposible for keeping the broker functional.\n\nWhat stateful characteristics does the Broker have?\nAll the messages that are published to the broker is persisted in					-				m		e				mory wit					hin the broker instance until it get consumed. Persistent-volume/Disk-space is not currently being used by the Broker.\n\nHow do I know if the Broker is working? How do I troubleshoot the Broker?\nThe Broker instance is deployed inside the kubernetes cluster as a Statefulset. In the case where the broker doesnt seem to work, here are a few steps to troubleshoot the instance:\n\n\n  Make sure the pods corresponding to the Statefulset is up and running.\n  Make sure the kubernetes cluster has support for kubernetes Service type LoadBalancer or NodePort.\n  Ensure connectivity between the Meshery-Server and the Broker service endpoint."
					}




					,

					"project-build-and-release": {
						"id": "project-build-and-release",
						"title": "Build &amp; Release (CI)",
						"categories": "",
						"url": " /project/build-and-release",
						"content": "Meshery’s build and release system incorporates many tools, organized into different workflows each triggered by different events. Meshery’s build and release system does not run on a schedule, but is event-driven. GitHub Actions are used to define Meshery’s CI workflows. New builds of Meshery and its various components are automatically generated upon push, release, and other similar events, typically in relation to their respective master branches.\n\nArtifacts\n\nToday, Meshery and Meshery adapters are released as Docker container images, available on Docker Hub. Meshery adapters are out-of-process adapters (meaning not compiled into the main Meshery binary), and as such, are independent build artifacts.The process of creating Docker images, tagging with the git commit SHA and pushing to Docker Hub is being done automatically using GitHub Actions.\n\nArtifact Repositories\n\nArtifacts produced in the build processes are published and persisted in different public repositories and in different formats.\n\n\n  \n    \n      Location\n      Project\n      Repository\n    \n  \n  \n    \n      Docker Hub\n      Meshery\n      https://hub.docker.com/r/layer5/meshery\n    \n    \n      GitHub\n      mesheryctl\n      https://github.com/layer5io/meshery/releases\n    \n    \n      Docker Hub\n      Meshery Adapter for &lt;service-mesh&gt;\n      https://hub.docker.com/r/layer5/meshery-&lt;service-mesh&gt;\n    \n    \n      Docs\n      Meshery Documentation\n      https://docs.meshery.io\n    \n    \n      GitHub\n      Service Mesh Performance\n      https://github.com/layer5io/service-mesh-performance\n    \n  \n\n\nSecrets\n\nSome portions of the workflow require secrets to accomplish their tasks. These secrets are defined within the respective repositories and accessible to workflows during runtime. Currently defined secrets include:\n\n\n  DOCKER_USERNAME: Username of the Docker Hub user with the right privileges to push images\n  DOCKER_PASSWORD: Password for the Docker Hub user\n  GO_VERSION: As of December 9th 2020 it is 1.15\n  IMAGE_NAME: appropriate image name for each of the Docker container images. All are under the layer5io org.\n  SLACK_BOT_TOKEN: Used for notification of new GitHub stars given to the Meshery repo.\n  CYPRESS_RECORD_KEY`: Used for integration with the Layer5 account on Cypress.\n  GLOBAL_TOKEN: Used for securely transmitting performance test results for the None Provider.\n\n\nThe Docker Hub user, mesheryci, belongs to the “ciusers” team in Docker Hub and acts as the service account under which these automated builds are being pushed. Every time a new Docker Hub repository is created we have to grant “Admin” (in order to update the README in the Docker Hub repository) permissions to the ciusers team.\n\nChecks and Tests\nMeshery’s CI workflow incorporates several checks (partial list below) during merges and/or commits to any branches and pull requests to master branch to prevent broken code from being merged into master.\n\nCollectively, Meshery repositories will generally have CI workflow for commits and pull requests that consist of the following actions:\n\n\n  Lint check (golint)\n  Static analysis check (staticcheck)\n  Vet (govet)\n  Security checks (gosec)\n  Unit tests (go tests)\n  Build (go build)\n  Release binaries through GoReleaser (only for mesheryctl in the Meshery repository)\n  Docker build, tag and push\n\n\nAutomated Builds\n\nAll Meshery GitHub repositories are configured with GitHub Actions. Everytime a pull request is submitted against the master branch of any repository, that repository’s GitHub Actions will be invoked (whether the PR is merged or not). Workflows defined in Meshery repository will generally (but not always) perform the following actions:\n\n\n  trigger a Docker build to build a Docker container image\n  generate two Docker tags:\n    \n      a tag containing the git merge SHA\n      a tag containing that particular release’s git tag (if one is present)\n    \n  \n  assign each of these two tags to the new container image as well as the latest tag.\n  push the new Docker tags and image to Docker Hub.\n\n\nBuilding mesheryctl\n\nAs a special case, the meshery repository contains an additional artifact produced during each build. This artifact is mesheryctl which is built as an executable binary. In order to make the job of building mesheryctl easier for a combination of different platform architectures and operating systems, we are using GoReleaser. Irrespective of branch, for every git commit and git push to the meshery repository, GoReleaser will execute and generate the OS and arch-specific binaries ( but will NOT publish them to GitHub). Even though mesheryctl binaries are built each time a pull request is merged to master, only stable channel artifacts are published (persisted).\n\nReleasing mesheryctl to GitHub\n\nOnly when a git tag containing  a semantic version number is present (is a commit in the master branch) will GoReleaser execute, generate the archives, and also publish the archives to Meshery’s GitHub releases automatically. GoReleaser is configured to generate artifacts for the following OS, ARCH combination:\n\n\n  Darwin - i386, x86_64\n  Linux - i386, x86_64\n  Windows - i386, x86_64\n  FreeBSD - i386, x86_64\n\n\nThe artifacts will be made available as a tar.gz archive for all the operating systems. mesheryctl is bundled into packages for commonly used package managers: homebrew and scoop.\n\nHomebrew\n\nGoReleaser facilitates the creation of a brew formula for mesheryctl. The homebrew-tap repository is the location for Layer5’s brew formulas.\n\nScoop\n\nGoReleaser facilitates the creation of a Scoop app for mesheryctl. The scoop-bucket repository is the location of Layer5’s Scoop bucket.\n\nRelease Versioning\n\nWe follow the commonly used semantic versioning for Meshery, Meshery Adapter and Performance Benchmark Specification releases. Given a version number MAJOR.MINOR.PATCH.BUILD, increment the:\n\n\n  MAJOR version - major changes with rare potential for incompatible API changes.\n  MINOR version - add functionality in a backwards-compatible manner.\n  PATCH version - mostly for bug and security fixes.\n  AlPHA/BETA/RC - used to facilitate early testing of an upcoming release.\n\n\nComponent Versioning\n\nMeshery comprises a number of components including a server, adapters, UI, and CLI. As an application, Meshery is a composition of these different functional components. While all of Meshery’s components generally deploy as a collective unit (together), each component is versioned independently, so as to allow them to be loosely coupled and iterate on functionality independently.  Some of the components must be upgraded simultaneously, while others may be upgraded independently. See Upgrading Meshery for more information.\n\nGitHub release tags will contain a semantic version number. Semantic version numbers will have to be managed manually by tagging a relevant commit in the master branch with a semantic version number (example: v1.2.3).\n\nRelease Process\n\nDocumentation of Meshery releases contains a table of releases and release notes and should be updated with each release.\n\nAutomated Releases\n\nReleases are manually triggered by a member of the release team publishing a release. Release names and release tags need to be assigned by the publishing team member. GitHub Action workflows will trigger and take care of running the required steps and publishing all artifacts (e.g., binary and docker images).\n\nWorkflow Triggers\n\nThe following events will trigger one or more workflows:\n\n\n  Tagged Release\n  Commit pushed to the master branch\n  PR opened or commit pushed to PR branch\n  PR merged to the master branch\n\n\nRelease Notes\n\nWhile use of GitHub Actions facilitates automated builds, ReleaseDrafter is helping with facilitating automated release notes and versioning.\nGenerating Release Notes\n\nReleaseDrafter generates a GitHub tag and release draft. ReleaseDrafter action will trigger and will automatically draft release notes according to the configuration set-up. ReleaseDrafter drafts releases as soon as a commit is made into master after the previous release. The GitHub Action, ReleaseDrafter, is compatible with semantic releases and is used to auto-increment the semantic version number by looking at the previous release version.\n\nAutomated Release Notes Publishing\n\nThe publishing of release notes to Meshery Docs is automated. Triggered by a release event, a workflow will checkout the Meshery repo, copy the auto-drafted release notes into a Jekyll collection in Meshery Docs, and generate a pull request.\n\nAutomated Pull Request Labeler\n\nA GitHub Issue labeler bot is configured to automatically assign labels to issues based on which files have changed in which directories. For example, a pull request with changes to files in the “/docs/**” folder will receive the “area/docs” label. Presence of the “area/docs” label is used to trigger documentation builds and Netlify builds of the Meshery Docs. Similar labels are assigned and used to trigger workflows or used as conditional flags in workflows to determine which workflows or which steps in a workflows to run.\n\nRelease Channels\n\nArtifacts of the builds for Meshery and its components are published under two different release channels, so that improved controls may be provided to both Meshery users and Meshery developers. The two release channels are edge and stable release channels.\n\nRelative to stable releases, edge releases occur much more frequently. Edge releases are made with each merge to master, unless that merge to master is for a stable release. Stable releases are made with each merge to master when a GitHub release tag is also present in the workflow.\n\nStable Channel\n\nThe following is an example of the release channels and the docker tags used to differentiate them. The latest tag will be applied only to images in the stable release channel. Here are two releases with two different images.\n\nLatest Stable Image\n\n\n  layer5/meshery:stable-latest\n  layer5/meshery:stable-v0.4.1\n  layer5/meshery:stable-324vdgb (sha)\n\n\nOlder Stable Image\n\n\n  layer5/meshery:stable-v0.4.0\n  layer5/meshery:stable-289d02 (sha)\n\n\nEvery docker image built receives either the edge tags or the stable tabs. Which set of image tags assigned is determined by whether a release tag is present or not. In other words, stable channel docker images get the “stable” tags only in the presence of a release tag (e.g. v0.4.1).\n\nEdge Channel\n\nThe edge release channel generally contains code less tested, less “baked”. The primary reason for “edge” is to allow contributors and advanced users to get at features sooner than later. Some features need testing that is best facilitated by letting users with tolerance and patience try them out.\n\nStable and edge releases are both published to the same Docker Hub repository. Docker Hub repositories differentiate release channels by image tag. The following Docker images tagging convention is followed:\n\nLatest Edge Image\n\n\n  layer5/meshery:edge-latest\n  layer5/meshery:edge-289d02 (sha)\n\n\nOlder Edge Image\n\n\n  layer5/meshery:edge-324vdgb (sha)\n\n\nSwitching Between Meshery Release Channels\n\nUsers are empowered to switch between release channels at their leisure.\n\nSwitching Release Channels Using mesheryctl\n\nUsers can use mesheryctl to switch between release channels, e.g. mesheryctl system channel [stable|edge].  Alternatively, users can manually switch between channels by updating the docker image tags in their meshery.yaml / Kubernetes manifest files. This command generates a meshery.yml (a docker-compose file) with release channel-appropriate tags for the different Docker container images.\n\nViewing Release Channel and Version Information in Meshery UI\n\nUsers are shown their Meshery deployment’s release channel subscription enient new setting in the Preferences area of the Meshery UI, so that people can alternatively use the UI to switch between channels if they like. Version numbers for Meshery adapters are also shown in the UI.\n\nRelease Cadence\n\nMinor releases of the Meshery project are release frequently (on a monthly basis on average) with patch releases made on-demand in-between those times. The project does not have long term releases that are sustained with bug fixes, yet. Bug fixes and patches will be released as needed on the latest release version.\n\nRelease Support\n\nGeneral community support and commercial support from Layer5 is available. Separately, third parties and partners may offer longer-term support solutions.\n\nPre v1.0\n\nProject focuses on functionality, quality and adoption, while retaining the flexibility for shifts in architecture.\n\nPost v1.0\n\nOnce a 1.0 release has been made, Around once a month or so, the pro					j				e		c				t mainta					iners will take one of these daily builds and run it through a number of additional qualification tests and tag the build as a Stable release. Around once a quarter or so, the project maintainers take one of these Stable releases, run through a bunch more tests and tag the build as a Long Term Support (LTS) release. Finally, if we find something wrong with an LTS release, we issue patches.\n\nThe different types (Daily, Stable, LTS) represent different product quality levels and different levels of support from the Meshery team. In this context, support means that we will produce patch releases for critical issues and offer technical assistance."
					}




					,

					"project-contributing": {
						"id": "project-contributing",
						"title": "Contributing",
						"categories": "",
						"url": " /project/contributing",
						"content": "Please do! Thanks for your help! :balloon:\n\nThis project is community-built and welcomes collaboration. Contributors are expected to adhere to the CNCF’s Code of Conduct.\nNot sure where to start?\n\nFollow these steps and you’ll be right at home.\n\n\n  \n    See the Community Welcome Guide for how, where, and why to contribute.\n  \n  \n    Sign up for a MeshMate to find the perfect Mentor to help you explore the Layer5 projects and find your place in the community:\n    \n      Familiarize yourself with all the Layer5 projects (Take a look at the Community Drive and the Layer5 Repository Overview: Spend time understanding each of the Layer5 initiatives through high-level overviews available in the community drive and through discussions with your MeshMate.\n      Identify your area of interest: Use the time with your MeshMate to familiarize yourself with the architecture and technologies used in the projects. Inform your MeshMate of your current skills and what skills you aim to develop.\n      Run Meshery: Put on your user hat and walk-through all of Meshery’s features and functions as a user.\n      Build Meshery: Confirm that you have a usable development environment.\n      Communicate with the Layer5 community by joining the Slack account.\n      Contribute by grabbing any open issue with the help-wanted label and jump in. If needed, create a new issue. All pull requests should reference an open issue. Include keywords in your pull request descriptions, as well as commit messages, to automatically close issues in GitHub.\n    \n  \n\n\nSections\n\n  General Contribution Flow\n  Developer Certificate of Origin\n  Meshery Contribution Flow\n    \n      Meshery Documentation\n      Meshery Backend\n        \n          Writing a Meshery Adapter\n        \n      \n      Meshery UI\nRelevant coding style guidelines are the Go Code Review Comments and the Formatting and style section of Peter Bourgon’s Go: Best Practices for Production Environments.\n    \n  \n\n\nGeneral Contribution Flow\n\nTo contribute to Meshery, please follow the fork-and-pull request workflow described here.\n\nSigning-off on Commits (Developer Certificate of Origin)\n\nTo contribute to this project, you must agree to the Developer Certificate of\nOrigin (DCO) for each commit you make. The DCO is a simple statement that you,\nas a contributor, have the legal right to make the contribution.\n\nSee the DCO file for the full text of what you must agree to\nand how it works here.\nTo signify that you agree to the DCO for contributions, you simply add a line to each of your\ngit commit messages:\n\nSigned-off-by: Jane Smith &lt;jane.smith@example.com&gt;\n\n\nIn most cases, you can add this signoff to your commit automatically with the\n-s or --signoff flag to git commit. You must use your real name and a reachable email\naddress (sorry, no pseudonyms or anonymous contributions). An example of signing off on a commit:\n$ commit -s -m “my commit message w/signoff”\n\n\nTo ensure all your commits are signed, you may choose to add this alias to your global .gitconfig:\n\n~/.gitconfig\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n\nOr you may configure your IDE, for example, Visual Studio Code to automatically sign-off commits for you:\n\n\n\nDocumentation Contribution Flow\nPlease contribute! Meshery documentation uses GitHub Pages to host the docs site. Learn more about Meshery’s documentation framework. The process of contributing follows this flow:\n\n\n  Create a fork, if you have not already, by following the steps described here\n  In the local copy of your fork, navigate to the docs folder.\ncd docs\n  Create and checkout a new branch to make changes within\ngit checkout -b &lt;my-changes&gt;\n  Edit/add documentation.\nvi &lt;specific page&gt;.md\n  Run site locally to preview changes.\nmake site\n  Commit, sign-off, and push changes to your remote branch.\ngit push origin &lt;my-changes&gt;\n  Open a pull request (in your web browser) against our main repo: https://github.com/layer5io/meshery.\n\n\nMeshery Contribution Flow\nMeshery is written in Go (Golang) and leverages Go Modules. UI is built on React and Next.js. To make building and packaging easier a Makefile is included in the main repository folder.\n\nRelevant coding style guidelines are the Go Code Review Comments and the Formatting and style section of Peter Bourgon’s Go: Best \nPractices for Production Environments.\n\nPlease note: All make commands should be run in a terminal from within the Meshery’s main folder.\n\nPrerequisites for building Meshery in your development environment:\n\n  Go version 1.11+ installed if you want to build and/or make changes to the existing code.\n  GOPATH environment variable should be configured appropriately\n  npm and node should be installed on your machine, preferably the latest versions.\n  Fork this repository (git clone https://github.com/layer5io/meshery.git), clone your forked version of Meshery to your local, preferably outside GOPATH. If you happen to checkout Meshery inside your GOPATH and you have a version of Go prior to version 1.13, please set an environment variable GO111MODULE=on to enable GO Modules.\n\n\nBuild and run Meshery server\nTo build &amp; run the Meshery server code, run the following command:\nmake run-local\n\n\nAny time changes are made to the Go code, you will have to stop the server and run the above command again.\nOnce the Meshery server is up and running, you should be able to access Meshery on your localhost on port 9081 at http://localhost:9081. One thing to note, you might NOT see the Meshery UI until the UI code is built as well.\nAfter running Meshery server, you will need to select your Cloud Provider by navigating to localhost:9081. Only then you will be able to use the Meshery UI on port 3000.\n\nBuilding Docker image\nTo build a Docker image of Meshery, please ensure you have Docker installed to be able to build the image. Now, run the following command to build the Docker image:\nmake docker\n\n\nWriting a Meshery Adapter\nMeshery uses adapters to provision and interact with different service meshes. Follow these instructions to create a new adapter or modify and existing adapter.\n\n\n  Get the proto buf spec file from Meshery repo:\nwget https://raw.githubusercontent.com/layer5io/meshery/master/meshes/meshops.proto\n  Generate code\n    \n      Using Go as an example, do the following:\n        \n          adding GOPATH to PATH: export PATH=$PATH:$GOPATH/bin\n          install grpc: go get -u google.golang.org/grpc\n          install protoc plugin for go: go get -u github.com/golang/protobuf/protoc-gen-go\n          Generate Go code: protoc -I meshes/ meshes/meshops.proto --go_out=plugins=grpc:./meshes/\n        \n      \n      For other languages, please refer to gRPC.io for language-specific guides.\n    \n  \n  Implement the service methods and expose the gRPC server on a port of your choice (e.g. 10000).\n\n\nTip: The Meshery Adapter for Istio is a good reference adapter to use as an example of a Meshery Adapter written in Go.\n\nmesheryctl Contribution Flow\n\nmesheryctl is written in Golang or the Go Programming Language. For development use Go version 1.15+.\n\nThe /mesheryctl folder contains the complete code for mesheryctl.\n\nAfter making changes, run make in the mesheryctl folder to build the binary. You can then use the binary by, say, ./mesheryctl system start.\n\nmesheryctl command reference\n\nDetailed documentation of the mesheryctl commands is available in the Meshery Docs.\n\nGuidelines and resources for contributing to mesheryctl\n\nmesheryctl might be the interface that the users first have with Meshery. As such, mesheryctl needs to provide a great UX.\n\nThe following principles should be taken in mind while designing mesheryctl commands-\n\n\n  Provide user experiences that are familiar.\n  Make the commands and their behavior intuitive.\n  Avoid long commands with chained series of flags.\n  Design with automated testing in mind, e.g. provide possibility to specify output format as json (-o json) for easy inspection of command response.\n\n\nPart of delivering a great user experience is providing intuitive interfaces. In the case of mesheryctl, we should take inspiration from and deliver similar user experiences as popular CLIs do in this ecosystem, like kubectl and docker. Here is relevant kubectl information to reference - Kubectl SIG CLI Community Meeting Minutes, contributing to kubectl, code.\n\nmesheryctl uses the Cobra framework. A good first-step towards contributing to mesheryctl would be to familiarise yourself with the Cobra concepts.\n\nFor manipulating config files, mesheryctl uses Viper.\n\nA central struct is maintained in the mesheryctl/internal/cli/root/config/config.go file. These are updated and should be used for getting the Meshery configuration.\n\nFor logs, mesheryctl uses Logrus. Going through the docs and understanding the different log-levels will help a lot.\n\nmesheryctl uses golangci-lint. Refer it for lint checks.\n\nUI Contribution Flow\nMeshery is written in Go (Golang) and leverages Go Modules. UI is built on React and Next.js. To make building and packaging easier a Makefile is included in the main repository folder.\n\nInstall UI dependencies\nTo install/update the UI dependencies:\nmake ui-setup\n\n\nBuild and export UI\nTo build and export the UI code:\nmake ui-build\n\n\nNow that the UI code is built, Meshery UI will be available at http://localhost:9081.\nAny time changes are made to the UI code, the above code will have to run to rebuild the UI.\n\nUI Development Server\nIf you want to work on the UI, it will be a good idea to use the included UI development server. You can run the UI development server by running the following command:\nmake ui\n\n\nMake sure to have Meshery server configured, up and running on the default port http://localhost:9081 before proceeding to access and work on the UI server at http://local					h				o		s				t:3000.\					nAny UI changes made now will automatically be recompiled and served in the browser.\n\nRunning Meshery from IDE\nIf you want to run Meshery from IDE like Goland, VSCode. set below environment variable\nPROVIDER_BASE_URLS=\"https://meshery.layer5.io\"\nPORT=9081\nDEBUG=true\nADAPTER_URLS=mesherylocal.layer5.io:10000 mesherylocal.layer5.io:10001 mesherylocal.layer5.io:10002 mesherylocal.layer5.io:10003 mesherylocal.layer5.io:10004 mesherylocal.layer5.io:10005 mesherylocal.layer5.io:10006 mesherylocal.layer5.io:10007 mesherylocal.layer5.io:10008 mesherylocal.layer5.io:10009\n\ngo tool argument\n-tags draft\n\nupdate /etc/hosts\n127.0.0.1 mesherylocal.layer5.io"
					}




					,

					"es-project-contributing": {
						"id": "es-project-contributing",
						"title": "Contribuir",
						"categories": "",
						"url": " /es/project/contributing",
						"content": "Descripción general de contribución\n\nPor favor, ¡hazlo! ¡Gracias por tu ayuda! :balloon:\n\nEste proyecto está construido por la comunidad y la colaboración es bienvenida. Se espera que cada persona colaboradora se adhiera al Código de conducta de CNCF.\n\n¿No estás seguro/a por dónde empezar?\n\nSigue estos pasos y te sentirás como en casa.\n\n\n  Consulte la Guía de bienvenida de la comunidad para saber cómo, dónde y por qué contribuir.\n  Regístrate para un MeshMate y encontrar el Mentor (o Mentora) perfecto que te ayude a explorar los proyectos de Layer5 y encontrar tu lugar en la comunidad:\n\n\n\n  Familiarízate con todos los proyectos de Layer5 (echale un vistazo al Drive de la Comunidad y la lista de repositorios de Layer5: Dedicale tiempo a comprender cada una de las iniciativas de Layer5 a través de descripciones de alto nivel disponibles en el drive de comunidad y a través de discusiones con tu Mesh Mate.\n  Identifica tu área de interés: Usa el tiempo con tu MeshMate para familiarizarte con la arquitectura y las tecnologías utilizadas en los proyectos. Informa a tu MeshMate de tus habilidades actuales y las habilidades que pretendes desarrollar.\n  Ejecuta Meshery: Ponte en los zapatos del usuario y recorre todas las características y funciones de Meshery como usuario.\n  Construye Meshery: Asegurate que tienes un entorno de desarrollo usable.\n  Comunicate con la comunidad de Layer5 uniéndote a la cuenta de Slack.\n  Contribuye tomando cualquier issue abierto con la etiqueta help wanted y entrale. Si es necesario, crea un nuevo issue. Todas las pull requests deben hacer referencia a un issue abierto. Incluye palabras clave en las descripciones de tus pull requests, así como mensajes de commits, para cerrar automáticamente los issues en GitHub.\n\n\nSecciones\n\n\n  Flujo general de contribuciones\n  Certificado de origen del desarrollador\n  Flujo de contribución de Meshery\n    \n      Documentación de Meshery\n      Meshery Backend\n        \n          Escribir un Meshery Adapter\n        \n      \n      Meshery UI\nLas pautas de estilo de codificación relevantes son los comentarios de revisión de Go Code Review y la sección de formato y estilo de Go Code: las mejores prácticas para entornos de producción de Peter Bourgon.\n    \n  \n\n\nFlujo de contribución general\n\nPara contribuir a Meshery, siga el flujo de trabajo de fork-and-pull descrito aquí.\n\nCertificado de origen del desarrollador\n\nPara contribuir a este proyecto, debes aceptar el Certificado de\norigen de desarrollador (DCO en inglés Developer Certificate of Origin) para cada commit que haces. El DCO es una simple declaración de que tu, como contribuyente, tienes el derecho legal de hacer la contribución.\n\nConsulta el archivo DCO para obtener el texto completo de lo que debes aceptar y cómo funciona aquí.\nPara indicar que estás de acuerdo con el DCO para las contribuciones, simplemente agregues una línea a cada uno de tus commits git:\n\nSigned-off-by: Jane Smith &lt;jane.smith@example.com&gt;\n\n\nEn la mayoría de los casos, puedes agregar esta firma a tu confirmación automáticamente con la marca -s o --signoff en git commit. Debes usar tu nombre real y un correo electrónico accesible (lo sentimos, no se permiten seudónimos ni contribuciones anónimas). Un ejemplo de firma de una confirmación:\n\n$ commit -s -m “my commit message w/signoff”\n\n\nPara asegurarte de que todas tus confirmaciones están firmadas, puedes optar por agregar este alias a su global .gitconfig:\n~/.gitconfig\n\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n\n\nO puedes configurar tu IDE, por ejemplo , Visual Studio Code para cerrar automáticamente las confirmaciones por ti:\n\n\n\nFlujo de contribución a la documentación\n\n¡Por favor contribuye! La documentación de Meshery utiliza páginas de GitHub para alojar el sitio de documentos. Obten más información sobre el framework de documentación de Meshery. El flujo de proceso de contribución es el siguente:\n\n\n  Crea un fork, si aún no lo has hecho, sigue los pasos descritos aquí\n  En la copia local del fork, navega a la carpeta docs:\ncd docs\n  Crea una nueva rama para realizar cambios:\ngit checkout -b &lt;my-changes&gt;\n  Edita/agrega documentación:\nvi &lt;specific page&gt;.md\n  Ejecuta el sitio localmente para obtener una vista previa de los cambios:\nmake site\n  Has commit, sign-off, y envía los cambios a tu rama remota\ngit push origin &lt;my-changes&gt;\n  Abre pull request (en su navegador web) en nuestro repositorio principal: https://github.com/layer5io/meshery.\n\n\nFlujo de contribución de Meshery\n\nMeshery está escrito en Go (Golang) y usa los módulos Go. La interfaz de usuario se basa en React y Next.js. Para facilitar la creación y el packaging, se incluye un archivo Makefile en la carpeta principal del repositorio.\n\nLas guías de estilo de programacción relevantes son los Comentarios de revisión de código de Go y la sección Formato y estilo de Peter Bourgon’s Go:BestPractices for Production.\n\nPor favor toma en cuenta: Todos los comandos make deben ejecutarse en una terminal desde la carpeta principal de Meshery.\n\nRequisitos previos para construir Meshery en tu entorno de desarrollo:\n\n\n  Tener la versión 1.11+ deGo instalada si quieres compilar y/o hacer cambios en el código existente.\n  La variable de entorno GOPATH debe configurarse de manera apropiada.\n  npm y node deben estar instalados en tu máquina, preferiblemente las últimas versiones.\n  Haz fork de este repoisitorio (https://github.com/layer5io/meshery.git), clona tu version forked de Meshery a tu maquina local, preferiblemente fuera de tu GOPATH. Si llegase a suceder que copiaras Meshery dentro de tu GOPATH y tuvieras una version de go Go anterior a la versión 1.13, por favor establece la variable de entorno GO111MODULE=on para habilitar los modulos de Go.\n\n\nConstruir y ejecutar el servidor Meshery\n\nPara construir y ejecutar el código del servidor Meshery, ejecuta el siguiente comando:\n\nmake run-local\n\n\nCada vez que se realicen cambios en el código GO, tendrás que detener el servidor y ejecutar el comando anterior nuevamente.\nUna vez que el servidor Meshery esta en funcionamiento, deberías poder acceder a Meshery en tu localhost en el puerto 9081 en http://localhost:9081. Una cosa para tomar en cuenta, es que posiblemente NO veas la interfaz de usuario de Meshery hasta que también hayas creado el código de la interfaz de usuario.\nDespués de ejecutar el servidor Meshery, deberás seleccionar tu Proveedor de nube navegando a localhost:9081. Solo entonces podrás utilizar la interfaz de usuario de Meshery en el puerto 3000.\n\nCreación de una imagen de Docker\n\nPara crear una imagen de Docker de Meshery, asegúrete de tener instalado Docker para poder crear la imagen. Ahora, ejecuta el siguiente comando para construir la imagen de Docker:\n\nmake docker\n\n\nEscribiendo un Adaptador de Meshery\n\nMeshery usa adaptadores para hacer provisiones e interactuar con diferentes meshes de servicio. Sigue estas instrucciones para crear un nuevo adaptador o modificar un adaptador existente.\n\n\n  Obtén el archivo proto buf spec del repositorio de Meshery:\nwget https://raw.githubusercontent.com/layer5io/meshery/master/meshes/meshops.proto\n  Genera el código\n    \n      Usando Go como ejemplo, haz lo siguiente::\n        \n          agrega GOPATH a tu PATH: export PATH=$PATH:$GOPATH/bin\n          instala grpc: go get -u google.golang.org/grpc\n          instala el plugin protoc para go: go get -u github.com/golang/protobuf/protoc-gen-go\n          Genenra el código de Go: protoc -I meshes/ meshes/meshops.proto --go_out=plugins=grpc:./meshes/\n        \n      \n      Para otros lenguajes consulta gRPC.io para las guías especificas del lenguaje.\n    \n  \n  Implementa los métodos de servicio (service method) y expón el puerto de gRPC en el puerto de tu elección (por ejemplo 10000).\n\n\nTip: El adaptador de Meshery para Istio es un buen adaptador de referencia para usar como ejemplo de un adaptador Meshery escrito en Go.\n\nFlujo de Contribución al UI\n\nMeshery está escrito en Go (Golang) y aprovecha los módulos Go. La interfaz de usuario se basa en React y Next.js. Para facilitar la creación y el empaquetado, se incluye un archivo Makefile en la carpeta principal del repositorio.\n\nInstalar las dependencias de UI\n\nPara instalar/actualizar las dependencias de UI:\n\nmake ui-setup\n\n\nConstruir y exportar UI\n\nPara construir y exportar el código de UI:\n\nmake ui-build\n\n\nAhora que el código de la interfaz de usuario está creado, la interfaz de usuario de Meshery estará disponible en http: // localhost: 9081.\nCada vez que se realizan cambios en el código de la interfaz de usuario, el código anterior deberá ejecutarse para reconstruir la interfaz de usuario.\n\nServidor de desarrollo de UI\n\nSi deseas trabajar en la UI, será una buena idea utilizar el servidor de desarrollo de UI incluido. Puedes ejecutar el servidor de desarrollo de UI ejecutando el siguiente comando:\n\nmake ui\n\n\nAsegúrete de tener el servidor Meshery configurado y en funcionamiento en el puerto predeterminado http://localhost:9081 antes de proceder a acceder y trabajar en el servidor de UI en http://localhost:3000.\nCualquier cambio en la interfaz de usuario realizado ahora se 					v				o		l				verá a c					ompilar y se servirá automáticamente en el navegador.\n\nEjecutando Meshery desde IDE\n\nSi deseas ejecutar Meshery desde un IDE como Goland, VSCode. establece la variable de entorno descrito aqui:\n\nPROVIDER_BASE_URLS=\"https://meshery.layer5.io\"\nPORT=9081\nDEBUG=true\nADAPTER_URLS=mesherylocal.layer5.io:10000 mesherylocal.layer5.io:10001 mesherylocal.layer5.io:10002 mesherylocal.layer5.io:10003 mesherylocal.layer5.io:10004 mesherylocal.layer5.io:10005 mesherylocal.layer5.io:10006 mesherylocal.layer5.io:10007 mesherylocal.layer5.io:10008 mesherylocal.layer5.io:10009\n\n\nargumento de go tool\n\n-tags draft\n\n\nactualiza /etc/hosts\n\n127.0.0.1 mesherylocal.layer5.io"
					}




					,

					"concepts-architecture-database": {
						"id": "concepts-architecture-database",
						"title": "Database",
						"categories": "",
						"url": " /concepts/architecture/database",
						"content": "What are the Meshery Databases?\n\nMeshery Databases function as repositories for MeshSync, user preferences and system settings. Both databases ar					e				 		c				onsidere					d ephemeral and should be treated as caches. Data retention is tethered to the lifetime of their Meshery Server instance. Remote Providers may offer long-term data persistence. Meshery’s APIs offer mechansims for clients, like mesheryctl and Meshery UI to retrieve data.\n\nSee the figure below for addtional details of the data formats supported and type of data stored.\n\n\n\nComponents\n\nMeshery Database has several kinds of database implementations to support various usecases. They are listed below:\n\n\n  \n    \n      Component\n      Library\n    \n  \n  \n    \n      Bitcask\n      github.com/prologic/bitcask\n    \n    \n      SQLite\n      gorm.io/gorm, gorm.io/driver/sqlite"
					}




					,

					"installation-platforms-docker": {
						"id": "installation-platforms-docker",
						"title": "Docker",
						"categories": "",
						"url": " /installation/platforms/docker",
						"content": "Quick Start with Docker \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nDeploying Meshery on Docker\n\nFollow these installation steps t					o				 		u				se Docke					r and Docker Compose to run Meshery. Users often choose this installation approach in order to run Meshery on their local machine. If you need to install docker, see Getting Started with Docker and if you need to install docker-compose, see Installing Docker Compose.\n\nStart Meshery by executing:\n\n\n \n mesheryctl system start\n \n \n\nOnce you have verified that all the services are up and running, Meshery UI will be accessible on your local machine on port 9081. Open your browser and access Meshery at http://localhost:9081. Log into the Provider of your choice.\n\nUpon starting Meshery successfully, instructions to access Meshery will be printed on the sceen. See these guides for usage tips."
					}




					,

					"es-installation-platforms-docker": {
						"id": "es-installation-platforms-docker",
						"title": "Docker",
						"categories": "",
						"url": " /es/installation/platforms/docker",
						"content": "Inicio rápido con Docker\n\nNota: se necesita un mínimo de 4 GB de RAM para los despliegues de Istio (y la aplicación de muestra BookInfo).\n\nPasos\n\nSiga estos pasos de instalación para usar Docker y Docker Compose para ejecutar Meshery. Los usuarios a menudo eligen abordar la instalación de esta manera para ejecutar Meshery en su máquina local. Si necesita instalar docker, consulte Introducción a Docker y si necesita instalar docker-compose, consulte Instalación de Docker Compose.\n\nEl repositorio de Meshery incluye un archivo docker-compose.yam					l				.		 				Podemos 					usar docker-compose para activar todos los servicios de Meshery ejecutando:\n\n\n \n $ curl -L https://git.io/meshery | bash -\n \n \n\nUna vez que haya verificado que todos los servicios están en funcionamiento, la interfaz de usuario de Meshery será accesible en su máquina local en el puerto 9081. Abra su navegador y acced					a				 		a				 Meshery					 en http://localhost:9081.\nSe le redireccionará a una página de inicio de sesión social donde puede elegir uno de los métodos de inicio de sesión social disponibles para iniciar sesión en Meshery.\n\nAl iniciar Meshery correctamente, las instrucciones para acceder a Meshery se imprimirán en la pantalla. Eche un vistazo a las guías Meshery para obtener consejos de uso avanzados."
					}




					,

					"installation-platforms-eks": {
						"id": "installation-platforms-eks",
						"title": "EKS",
						"categories": "",
						"url": " /installation/platforms/eks",
						"content": "Quick Start with EKS \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\n\n\nComing soon"
					}




					,

					"es-installation-platforms-eks": {
						"id": "es-installation-platforms-eks",
						"title": "EKS",
						"categories": "",
						"url": " /es/installation/platforms/eks",
						"content": "Inicio rápido con el Servicio Elastic Kubernetes de Amazon (EKS)\n\nPara brindar a Meshery el acceso necesario a su instancia de Kubernetes administrada,\nMeshery deberá tener asignada una ServiceAccount (Cuenta de servicio). Se puede utilizar una “ServiceAccount” existente o crear una nueva.\n\n\n  Asegúrese de que la ServiceAccount que utiliza tenga asignada la función cluster-admin.\n  Configure Meshery para que se ejecute en EKS:\n    \n      Configuración automática\n      Configuración manual\n    \n  \n\n\nNota: asegúrese de poder acceder a EKS con kubectl siguiendo la Guía de EKS.\n\nConfiguración automática (Recomendada)\n\n\n  En su navegador, navegue hasta Meshery (por ejemplo http://localhost:9081) e inicie sesión.\n  Descargue su token de autenticación de Meshery haciendo clic en Get Token en la sección de su perfil de usuario.\n  Utilice este token de autenticación para ejecutar el siguiente comando:\n    $ mesheryctl system config eks --token &lt;RUTA A ARCHIVO DE TOKEN&gt;\n    \n  \n\n\nEste comando actualiza su kubeconfig para proporcionar a Meshery acceso a su instancia administrada de Kubernetes.\nUna vez configurado, prosiga a utilizar Meshery (mesheryctl system start).\n\nConfiguración Manual(Opcional)\n\nSi el procedimiento de Configuración automática falla o si desea preparar manualmente su archivo kubeconfig para proveer a Meshery con el acceso necesario a su instancia administrada de Kubernetes, realice las siguientes acciones:\n\n\n  \n    Cree una ServiceAccount con el rol de cluster-admin\n\n    $ kubectl create serviceaccount meshery\n    \n  \n  \n    Agregando/Vinculando el rol cluster-admin a la nueva cuenta de servicio meshery\n\n    $ kubectl create clusterrolebinding meshery-binding --clusterrole=cluster-admin \\\n--serviceaccount=default:meshery\n    \n  \n  \n    Obtenga el nombre secreto de ServiceAccount.\n\n    $ kubectl get secrets\n\nNAME                           TYPE                                  DATA   AGE\ndefault-token-fnfjp            kubernetes.io/service-account-token   3      95d\nmeshery-token-5z9xj               kubernetes.io/service-account-token   3      66m\n    \n\n    Nota: Aquí el nombre secreto es meshery-token-5z9xj\n  \n  \n    Obtenga el secreto/token:\n\n    $ kubectl describe secret  sa-1-token-5z9xj\nName:         meshery-token-5z9xj\nNamespace:    default\nLabels:       &lt;none&gt;\nAnnotations:  kubernetes.io/service-account.name: meshery\n              kubernetes.io/service-account.uid: 397XXX-XXX-XXXX-XXXXX-XXXXX\n\nType:  kubernetes.io/service-account-token\n\nData\n====\nca.crt:     1025 bytes\nnamespace:  7 bytes\ntoken:      XXXhbGciOiJSUXXXX\n    \n  \n  Genere un nuevo archiv					o				 		y				aml kube					config a usar como entrada para Meshery.\n  \n    Establezca las Credential de configuración usando el token generado anteriormente.\n\n    $ kubectl config set-credentials meshery --token=XXXXX\n\no/p:User \"meshery\" set.\n    \n  \n  \n    Establezca el contexto actual para la nueva cuenta de servicio meshery\n\n    $ kubectl config set-context --current --user=meshery\n\no/p:\nContext \"aws\" modified.\n    \n  \n  \n    Genere el archivo yaml kubeconfig para usar como entrada a Meshery.\n\n    $ kubectl config view --minify --flatten &gt;  config_aws_eks.yaml\n    \n  \n\n\nMeshery ahora debería estar conectado con su instancia administrada de Kubernetes. Eche un vistazo a las Guías Meshery para ver más consejos de uso avanzados."
					}




					,

					"extensibility": {
						"id": "extensibility",
						"title": "Extensibility",
						"categories": "",
						"url": " /extensibility",
						"content": "Meshery has an extensible architecture with several extension points. Meshery provides several extension points for working with different service meshes via adapters, different load generators and different providers. Meshery also offers a REST API.\n\nGuiding Principles for Extensibility\n\nThe following principles are upheld in 					t				h		e				 design 					of Meshery’s extensibility.\n\n\n  Recognize that different deployment environments have different systems to integrate with.\n  Offer a default experience that provides the optimal user experience.\n\n\nExtension Points\n\nMeshery is not just an application. It is a set of microservices where the central component is itself called Meshery. Integrators may extend Meshery by taking advantage of designated Extension Points. Extension points come in various forms and are available through Meshery					’				s		 				architec					ture.\n\n\n\nFigure: Extension points available throughout Meshery\n\nThe following points of extension are currently incorporated into Meshery.\n\nTypes of Extension Points\n\n\n  Providers\n  Load Generators\n  Adapters\n  REST API\n  GraphQL API"
					}




					,

					"feed-xml": {
						"id": "feed-xml",
						"title": "",
						"categories": "",
						"url": " /feed.xml",
						"content": "Documentation\n    Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.\n\n    http://localhost:4000/\n    \n    Fri, 02 Sep 2022 21:17:51 +0530\n    Fri, 02 Sep 2022 21:17:51 +0530\n    Jekyll v3.9.0"
					}




					,

					"installation-platforms-gke": {
						"id": "installation-platforms-gke",
						"title": "GKE",
						"categories": "",
						"url": " /installation/platforms/gke",
						"content": "Quick Start with GKE \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on GKE\n\nIn order to provide Meshery with the necessary access to your managed Kubernetes instance, \nMeshery will need to be assigned a ServiceAccount. An existing ServiceAccount can be used or a new one created. Ensure that the ServiceAccount you use has the cluster-admin role assigned.\n\nMeshery will use this ServiceAccount to interact with your managed Kubernetes instance. Use either of the following two methods to prepare a compatible kubeconfig file:\n\n\n  Automatic Configuration\n  Manual configuration\n\n\nAutomatic Configuration (Recommended)\n\n\n  In your browser, navigate to Meshery (e.g., http://localhost:9081) and login.\n  Download your Meshery authentication token by clicking Get Token under your user profile.\n  Use this authentication token to execute the following command:\n\n\n\n \n $ mesheryctl system config gke --token *PATH_TO_TOKEN*\n \n \n\nThis command updates your kubeconfig to provide Meshery with access to your managed Kubernetes instance.\nOnce configured, proceed with using Meshery:\nmesheryctl system start\n\nManual Configuration (Optional)\n\nIf the Automatic Configuration procedure fails or you would like to manually prepare your kubeconfig file to provide Meshery with the necessary access to your managed Kubernetes instance					,				 		p				erform t					he following actions:\n\n\n  Download the generate_kubeconfig_gke.sh shell script.\n  \n    Execute this shell script identifying ServiceAccount name and Namespace arguments, like so:\n\n    \n \n ./generate_kubeconfig_gke.sh cluster-admin-sa-gke default\n \n \n  \n  \n    Once the script is complete, you may proceed to start Meshery with the GKE-compatible configuration by executing:\n\n    \n \n $ mesheryctl system start\n \n \n  \n  In your browser, navigate to Meshery (e.g., http://localhost:9081) and login.\n  Under Settings –&gt; Environment, provide the generated file (config-cluster-admin-sa-gke-default.yaml) as the kubeconfig file.\n\n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}




					,

					"es-installation-platforms-gke": {
						"id": "es-installation-platforms-gke",
						"title": "GKE",
						"categories": "",
						"url": " /es/installation/platforms/gke",
						"content": "Inicio rápido con Google Kubernetes Engine (GKE)\n\nPara otorgar a Meshery el acceso necesario a su instancia de Kubernetes administrada,\nMeshery deberá tener asignada una ServiceAccount ( Cuenta de servicio ). Se puede utilizar una ServiceAccount existente o crear una nueva. Asegúrese de que la ServiceAccount que utilize tenga asignada el rol de cluster-admin.\n\nMeshery usará esta ServiceAccount para interactuar con su instancia administrada de Kubernetes. Utilice cualquiera de los dos métodos siguientes para preparar un archivo kubeconfig compatible:\n\n\n  Configuración automática\n  Configuración manual\n\n\nConfiguración Automática (Recomendada)\n\n\n  En su navegador, navegue hasta Meshery (por ejemplo, http://localhost:9081) e inicie sesión.\n  Descargue su token de autenticación de Meshery haciendo clic en Get Token debajo de su perfil de usuario.\n  Utilice este token de autenticación para ejecutar el siguiente comando:\n    $ mesheryctl system config gke --token &lt;RUTA AL ARCHIVO DE TOKEN&gt;\n    \n  \n\n\nEste comando actualiza su kubeconfig para proporcionar a Meshery acceso a su instancia administrada de Kubernetes.\nUna vez configurado, proceda con Meshery (mesheryctl system start).\n\nConfiguración Manual (Opcional)\n\nSi el procedimiento Configuración automática falla ó si desea preparar manualmente su archivo kubeconfig para proporcionar a Meshery el acceso necesario a su instancia administrada de Kubernetes, realice las siguientes acciones:\n\n\n  Descargue el script de shell generate_kubeconfig_gke.sh.\n  \n    Ejec					u				t		e				 este sc					ript de shell que identifica el nombre de la cuenta de servicio y los argumentos del espacio de nombres, de esta manera:\n\n    ./generate_kubeconfig_gke.sh cluster-admin-sa-gke default\n    \n  \n  \n    Una vez que el script haya terminado por completo, puede proceder a iniciar Meshery con la configuración compatible con GKE ejecutando:\n\n    $ mesheryctl system start\n    \n  \n  En su navegador, navegue hasta Meshery (por ejemplo,, http://localhost:9081) e inicie su sesión.\n  En la sección Settings–&gt;Environment, introduzca el archivo generado (config-cluster-admin-sa-gke-default.yaml) como el archivo kubeconfig.\n\n\nMeshery ahora debería estar conectado con su instancia administrada de Kubernetes. Entre a visualizar las guías Meshery para que obtenga consejos de uso avanzado."
					}




					,

					"project": {
						"id": "project",
						"title": "Layer5 Community",
						"categories": "",
						"url": " /project",
						"content": "The Meshery project is maintained by the Layer5 community. We are an open source organization that adheres to the CNCF’s Code of Conduct. Our projects advance the state of the art surrounding service meshes and enable adopters of Cloud Native technologies and techniques to do so with confidence. Our shared commitment to the open source spirit pushes Layer5 projects forward.\n\nCommunity First\n\nThe Layer5 community represents the largest collection of service mesh projects and their maintainers in the world.\nThe Meshery project is community-built and welcomes collaboration! \n Fork here on Github\n\n\n  Join weekly community meeting Fridays from 10am to 11am Central.\n    \n      Watch community meeting recordings and subscribe to the community calendar.\n    \n  \n  Access the community drive (request access).\n\n\nGetting involved in the Community\n\nWant to get involved with project, join our Slack and one of the community members will make sure you are not left out. We always have a role for everyone whether to be a code-writer, a community manager, user, advocate, or just to listen in. Layer5 community is always open and warmly welcomes you. Check out our community welcome guide for more details.\nIf this is your first time making open source contribution, you are in the right place! Check out our first timers’ welcome guide.\n\nPlease see our contributing guide for more details.\					n				\		n				Presenta					tions\n\n\n\nDelivered at Service Mesh Day 2019\n\nPast presentations of Meshery:\n\n\n  O’Reilly OSCON 2020\n  O’Reilly Infrastructure &amp; Ops 2020\n  InnoTech Dallas 2020\n  KubeCon EU 2020\n  DockerCon 2020 (deck, video)\n  Open Source 101 at Home\n  Docker Captains Roundtable 2020\n  Cloud Native Austin 2020\n  NSMCon 2019 talk (video, deck)\n  Service Mesh Day 2019\n  DockerCon 2019 Open Source Summit\n  KubeCon EU 2019 (video, deck)\n  KubeCon EU 2019 Istio Founders Meetup\n  Cloud Native Rejekts EU 2019\n  Container World 2019\n  Solving the Service Mesh Adopter’s Dilemma (deck, event,video)\n\n\nTalking about Meshery?\n\nGiving a talk or hosting a meetup about Meshery? Leverage existing slides or request swag to support your talk.\n\n\n    Share your event\n    Access slides and resources"
					}




					,

					"es-installation": {
						"id": "es-installation",
						"title": "Installation Guide",
						"categories": "",
						"url": " /es/installation",
						"content": "Inicio Rápido\n\nPoner a correr Meshery en un sistema habilitado con Docker, es fácil. Usa la interfaz de linea de comandos Meshery, mesheryctl, para empezar Meshery en cualquiera de sus plataformas soportadas.\n\nUsando mesheryctl\n\nmesheryctl es una interfaz de línea de comandos para administrar un Desplegado (deployment) Meshery. mesheryctl le permite controlar el ciclo de vida de Meshery con comandos como start, stop, status, reset. Ejecutando reset removerá todas las instancias de contenedor activas, poda las imágenes jaladas y remueve todos los volúmenes locales creados iniciando Meshery.\n\nMac ó Linux\n\nEmplea tu elección de homebrew o bash para instalar mesheryctl. Tu solo necesitas usarlo una vez.\n\nHomebrew\n\nInstala mesheryctl y ejecuta Meshery en Mac con Homebrew.\n\nInstalando con Homebrew\n\nPara instalar mesheryctl, ejecute el siguiente comando:\n\nbrew tap layer5io/tap\nbrew install mesheryctl\nmesheryctl system start\n\n\nActualizando con Homebrew\n\nPara actualizar mesheryctl, ejecute el siguiente comando:\n\nbrew upgrade mesheryctl\n\n\nBash\n\nInstalando con Bash\n\nInstala mesheryctl y ejecuta Meshery en Mac ó Linux con este script:\n\ncurl -L https://git.io/meshery | bash -\n\n\nActualizando con Bash\n\nActualiza mesheryctl y corre Meshery en Mac ó Linux con este script:\n\ncurl -L https://git.io/meshery | bash -\n\n\nWindows\n\nInstalando el binario mesheryctl\n\nDescarga y descomprime mesheryctl desde la página de Liberaciones Meshery. Agrega mesheryctl a tu PATH para facilitar el uso. Después, ejecuta:\n\n./mesheryctl system start\n\n\nScoop\n\nUsa Scoop para instalar Meshery en tu máquina Windows.\n\nInstalando con Scoop\n\nAgrega el Meshery Scoop Bucket e instala:\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\nActualizando con Scoop\n\nPara actualizar mesheryctl, ejecuta el siguiente comando:\n\nscoop					 				u		p				date mes					heryctl\n\n\nInstalación Advanzada\n\nLos Usuarios pueden controlar la imagen de contenedor específico y etiqueta(versión) de Meshery que quieran ejecutar mediante la edición de su archivo local ~/.meshery/meshery.yaml (un archivo de docker compose).\nAlineado con la imagen de contenedor Meshery, en lugar de dejar la etiqueta implícita :stable-latest detrás de la imagen: layer5/meshery, los usuarios, en vez de esto, identificarán una etiqueta de imagen específica así:\n\nversion: '3'\nservices:\n  meshery:\n    image: layer5/meshery:v0.5.0\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n\n\n\n\nCuando Meshery está levantado y corriendo, las instrucciones para acceder Meshery serán impresas en la pantalla y su navegador web por default deberá ser dirigido a la pantalla de inicio de Meshery."
					}




					,

					"es-functionality": {
						"id": "es-functionality",
						"title": "Functionality",
						"categories": "",
						"url": " /es/functionality",
						"content": "Funcionalidades de Meshery\n\nEstas secciones proveen guías de usuario sobre las funcionalidades que ofrece Meshery.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \					n				 		 				  \n    					\n    \n    \n    \n    \n    \n    Functionality\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Lifecycle Management\n      \n    \n    Lifecycle Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Performance Management\n      \n    \n    Performance Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Meshery and Service Mesh Interface (SMI)\n      \n    \n    \n    \n    SMI Conformance Capability"
					}




					,

					"service-meshes": {
						"id": "service-meshes",
						"title": "Service Meshes",
						"categories": "",
						"url": " /service-meshes",
						"content": "As the multi-mesh manager, Meshery offers support for more adapters than any other project or product in the world. Learn more about Meshery Adapters in the Architecture section.\n\nSupport for Service Meshes\n\n\n  \n    \n      Service Mesh\n      Service Mesh Version\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n                                               v0.1.0\n    \n    \n       Meshery Adapter for Consul\n                                               v1.8.2\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n                                               1.0\n    \n    \n       Meshery Adapter for Istio\n                                               v1.8.1\n    \n    \n       Meshery Adapter for Kuma\n                                               v1.0\n    \n    \n       Meshery Adapter for Linkerd\n                                               v2.5.0\n    \n    \n      					 				M		e				shery Ad					apter for NGINX Service Mesh\n                                               v0.6.0\n    \n    \n       Meshery Adapter for Network Service Mesh\n                                               v0.2.1\n    \n    \n       Meshery Adapter for Octarine\n                                               v1.0\n    \n    \n       Meshery Adapter for Open Service Mesh\n                                               v0.5.0\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n                                               pre-GA\n    \n    \n       Meshery Adapter for Traefik Mesh\n                                               v1.0\n    \n  \n\n\nMeshery supports the following service meshes. It uses both abstraction APIs and service mesh-specific adapters to interface with and manage service meshes. Review the full list of Meshery adapters."
					}




					,

					"es-project": {
						"id": "es-project",
						"title": "Proyecto",
						"categories": "",
						"url": " /es/project",
						"content": "Proyectos Layer5\n\nEl proyecto Meshery es mantenido por la comunidad Layer5. Somos una organización de código abierto saludable que se rige por el Código de conducta de CNCF.\n\nInvolucrarse en la comunidad\n\nSi quieres participar en el proyecto, únete a nuestro Slack y uno de los miembros de la comunidad se asegurará de que no te quedes fuera. Siempre tenemos un papel para todos, ya sea que seamos redactores de códigos, administradores de la comunidad, usuarios, defensores o simplemente para escuchar. La comunidad de Layer5 siempre está 					a				b		i				erta y t					e da una calurosa bienvenida. Consulta nuestra guía de bienvenida de la comunidad para obtener más detalles.\nSi es la primera vez que realizas una contribución de código abierto, ¡estás en el lugar correcto! Consulta nuestra guía de bienvenida para principiantes.\n\nConsulta nuestra guía para contribuciones para obtener más detalles.\n\nAcerca de Layer5\n\nPrimero la comunidad\n\nLa comunidad Layer5 representa la colección más grande de proyectos de service mesh y sus maintainers en el mundo.\n\nPrimero el código abierto\n\nCreamos proyectos para proporcionar entornos de aprendizaje, implementación, mejores prácticas operativas, evaluaciones comparativas de desempeño, creación de documentación, compartir oportunidades de networking y más. Nuestro compromiso compartido con el espíritu de código abierto impulsa los proyectos de Layer5 hacia adelante."
					}




					,

					"guides": {
						"id": "guides",
						"title": "Operation Guides",
						"categories": "",
						"url": 					"				 		/				guides",
						"content": "Guides to using Meshery’s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Using mesheryctl\n      \n    \n    Upgrade `mesheryctl` and Meshery\n      \n    \n    Deploying Sample Applications\n      \n    \n    Using Multiple Adapters\n      \n    \n    Using Metrics in Meshery"
					}




					,

					"reference": {
						"id": "reference",
						"title": "Reference",
						"categories": "",
						"url": " /reference",
						"content": "References for using Meshery’s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Extensibility: Service Mesh Adapters\n      \n        -  Meshery architecture is extensible. Meshery provides several extension points for working with different service meshes via adapters, load generators and providers.\n      \n      \n      \n    \n    Extensibility: Load Generators\n      \n        -  Meshery offers s					u				p		p				ort for 					more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n      \n      \n      \n    \n    Extensibility: Providers\n      \n        -  Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n      \n      \n      \n    \n    mesheryctl Command Reference\n      \n        -  A guide to Meshery's CLI: mesheryctl\n      \n      \n      \n    \n    Extensibility\n      \n        -  Meshery architecture is extensible. Meshery provides several extension points for working with different service meshes via adapters, load generators and providers.\n      \n      \n      \n    \n    Extensibility: APIs\n      \n        -  Meshery architecture is extensible, offering an array of extension points and REST and GraphQL APIs."
					}




					,

					"installation-quick-start": {
						"id": "installation-quick-start",
						"title": "Quick Start Guide",
						"categories": "",
						"url": " /installation/quick-start",
						"content": "Getting Meshery up and running locally on a Docker-enabled system is easy with Meshery’s command line interface, mesheryctl.\n\nConfigure Your Environment\n\nMeshery deploys as a set of Docker containers, which can be deployed to either a Docker host or Kubernetes cluster. See the complete list of its supported platforms.\n\nInstall Meshery\n\nUse the Meshery command line interface, , to install and start Meshery. Begin with Meshery by installing its command line client: mesheryctl. If you are on a MacOS or Linux system, you can download, install, and run to the management plane with the command shown in the figure.\n\n\n \n $ curl -L https://git.io/meshery | bash - \n \n \n\nDownload, install, and run Meshery in a single command.\n\nAccess Meshery\n\nVisit Meshery’s web-based user interface http://&lt;hostname&gt;:9081. When Meshery is installed on a Docker host, your default browser will be opened and navigated to http://localhost:9081.\n\nSelect a Provider\nSelect from the list of Providers in order to login to Meshery. Authenticate with your chosen your Provider.\n\n\n  \n\n\nConfigure Connection to Kubernetes\nMeshery attempts to auto detect your kubeconfig if it is stored in the default path ($HOME/.kube) on your system. In most					 				d		e				ployment					s, Meshery will automatically connect to your Kubernetes cluster. Ensure that Meshery is connected to your your Kubernetes cluster.\n\nVisit  Settings:\n\n\n  \n  \n\nIf your config has not been auto-detected, you may manually locate and upload your kube config file and select the context name (docker-desktop, kind-clsuter, minikube etc.)\n\nVerify Meshery’s Deployment\nRun connectivity tests and verify the health of your Meshery system. Verify Meshery’s connection to Kubernetes by clicking on your configuration context name. You will be notified of your connection status. You can also verify a successful connection between Meshery and its adapters by clicking on any of the available Adapter Ports.\n\n\n\n\n\nOperate service meshes and their workloads\nYou may now proceed to install and work with any service mesh supported by Meshery.\n\n\n  \n Your browser does not support the video tag"
					}




					,

					"": {
						"id": "",
						"title": "Meshery Documentation",
						"categories": "",
						"url": " /",
						"content": "Meshery is the open source, service mesh management plane for enabling the adoption, operation, and management of any service mesh and their workloads.\n\n\n  \n  \n    \n        Quick&nbsp;Start\n    \n    Getting Started\n        Introducing Meshery\n        Project and Community        \n    \n    Supported Platforms\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        AKS\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Docker\n          \n          \n        \n        \n        \n        EKS\n          \n          \n        \n        \n        \n        \n        \n        GKE\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        KinD\n          \n          \n        \n        \n        \n        Kubernetes\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Minikube\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Windows\n          \n          \n        \n        \n        \n        \n        \n      \n  \n  \n  \n  \n    \n        Concepts\n    \n    Concepts\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Adapters\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      Architecture\n        \n        \n      \n      \n      \n      \n      \n      Broker\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      Database\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      MeshSync\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Operator\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n    Functionality\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Lifecycle Management\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Performance Management\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Meshery and Service Mesh Interface (SMI)\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n    Service Mesh Management\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n       Meshery Adapter for App Mesh\n       Meshery Adapter for Consul\n       Meshery Adapter for Citrix Service Mesh\n       Meshery Adapter for Istio\n       Meshery Adapter for Kuma\n       Meshery Adapter for Linkerd\n       Meshery Adapter for NGINX Service Mesh\n       Meshery Adapter for Network Service Mesh\n       Meshery Adapter for Octarine\n       Meshery Adapter for Open Service Mesh\n       Meshery Adapter for Tanzu Service Mesh\n       Meshery Adapter for Traefik Mesh\n      \n    \n  \n\n  \n  \n    \n        Guides\n    \n    Guides\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Using Metrics in Meshery\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Using Multiple Adapters\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Deploying Sample Applications\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Upgrade `mesheryctl` and Meshery\n        \n        \n      \n      \n      \n      \n      \n      Using mesheryctl\n        \n        \n      \n    \n    Reference\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Service Mesh Adapters\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: APIs\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility\n          \n          \n        \n        \n        \n        \n        \n        \n    					 				 		 				 \n     					   \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Load Generators\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        mesheryctl Command Reference\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Providers"
					}




					,

					"concepts": {
						"id": "concepts",
						"title": "Concepts",
						"categories": "",
						"url": " /concepts",
						"content": "Concepts for understanding Meshery’s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Operator\n      \n        -  Meshery Operator controls and manages the lifeycle of components deployed inside a kubernetes cluster\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    MeshSync\n      \n        -  Meshery offers support for kubernetes cluster/service mesh state synchronization with the help of MeshSync.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n 					 				 		 				\n    \n					    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Database\n      \n        -  Meshery offers support for internal caching with the help of file databases. This has been implemented with several libraries that supports different kinds of data formats.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    Broker\n      \n        -  Meshery broker component fascilitates data streaming between kubernetes cluster components and outside world.\n      \n      \n      \n    \n    \n    \n    \n    \n    Architecture\n      \n        -  overview of different individual components of Meshery architecture and how they interact as a system.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    Adapters\n      \n        -  Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes."
					}




					,

					"functionality": {
						"id": "functionality",
						"title": "Functionality",
						"categories": "",
						"url": " /functionality",
						"content": "These sections provide user guides to the functionality Meshery offers.\nMeshery Functionality\n\n\n    \n    \n    \n    \n    \n    					\				n		 				   \n   					 \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Lifecycle Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Performance Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Meshery and Service Mesh Interface (SMI)"
					}




										,

					"es": {
						"id": "es",
						"title": "Documentación en Español 🇲🇽",
						"categories": "",
						"url": " /es",
						"content": "Documentación en Español 🇲🇽\n    \n\n\n\n\n\n    \n        Quick&nbsp;Start\n    \n    Getting Started\n        Introducing Meshery\n        Project and Community\n    \n    Supported Platforms\n        \n        \n        \n        \n          AKS\n          \n        \n        \n        \n        \n        \n        \n          Docker\n          \n        \n        \n          EKS\n          \n        \n        \n          GKE\n          \n        \n        \n        \n        \n        \n        \n          KinD\n          \n        \n        \n          Kubernetes\n          \n        \n        \n        \n        \n          Minikube\n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n          Windows"
					}




					,

					"guides-interpreting-performance-test-results					"				:		 				{
											"id": "guides-interpreting-performance-test-results",
						"title": "Interpreting Performance Test Results",
						"categories": "",
						"url": " /guides/interpreting-performance-test-results",
						"content": "Once a performance tests and run, it’s disco analysis is performed and test results persisted. Results or downloadable and persisted in the Service Mesh Performance (SMP) format.\n\nGraphical View\n\n\n\n\n\nTests\n\nFor the best experience, you should compare between two or more tests of similar configuration. Tests that are configured with a high degree of variance (e.g., one test ran for a duration of 5 minutes, while another test ran for a duration of 1 hour) will produce comparisons that are more difficult to extrapolate insights from.\n\nLatency and throughput are the two most significantly examined signals.\n\nMeshery will use different algorithms to calculate results depending upon which load generator was used to run the test."
					}




					,

					"es-installation-platforms-kind": {
						"id": "es-installation-platforms-kind",
						"title": "KinD",
						"categories": "",
						"url": " /es/installation/platforms/kind",
						"content": "Inicio Rápido con KinD\n\nPara configurar y ejecutar Meshery en KinD:\n\n\n  Instalar kinD\n  Crear un cluster Kubernetes con kinD\n    \n      Acceder al cluster kinD\n    \n  \n  Alternativamente, Ejecute Helm\n\n\nInstalación\n\n\n  En Mac / Linux mediante Homebrew (Recomendado):\n\n\nbrew install kind\n\n\n\n  En macOS / Linux mediante curl:\n\n\ncurl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.8.1/kind-$(uname)-amd64\nchmod +x ./kind\nmv ./kind /some-dir-in-your-PATH/kind\n\n\nSi está ejecutando Ubuntu en WSL2, use la distro Docker Ubuntu para instalar Docker.\n\nCrear cluster usando KinD\n\nCon el fin de construir exitosamente el servidor Meshery en su servidor local, siga las instrucciones específicas a su Sistema Operativo para completar la creación de un cluster KinD.\n\n1. KinD en WSL2\n\nPrimero que nada, obtendremos la dirección ip de su distro WSL2 mediante:\n\nip addr | grep eth0\n\n\nUsted verá una salida como:\n\n4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    inet 172.1.1.1/20 brd 172.1.1.255 scope global eth0\n\n\nCopie la dirección IP, la usaremos en el siguiente paso.\n\nLo siguiente es, crear un archivo que tenga el nombre kind_cluster.yaml y capture la dirección ip en el campo apiServerAddress:\n\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnetworking:\n  apiServerAddress: \"172.1.1.1\"\n\n\nAhora cree el cluster KinD con el archivo de configuración kind_cluster.yaml:\n\nkind create cluster --config kind_cluster.yaml --name kind --wait 300s\n\n\nUsted verá:\n\nCreating cluster \"kind\" ...\n • Ensuring node image (kindest/node:v1.17.0) 🖼  ...\n ✓ Ensuring node image (kindest/node:v1.17.0) 🖼\n • Preparing nodes 📦   ...\n ✓ Preparing nodes 📦\n • Writing configuration 📜  ...\n ✓ Writing configuration 📜\n • Starting control-plane 🕹️  ...\n ✓ Starting control-plane 🕹️\n • Installing CNI 🔌  ...\n ✓ Installing CNI 🔌\n • Installing StorageClass 💾  ...\n ✓ Installing StorageClass 💾\n • Waiting ≤ 5m0s for control-plane = Ready ⏳  ...\n ✓ Waiting ≤ 5m0s for control-plane = Ready ⏳\n • Ready after 59s 💚\nSet kubectl context to \"kind-kind\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kind\n\nNot sure what to do next? 😅 Check out https://kind.sigs.k8s.io/docs/user/quick-start/\n\n\n2. KinD en otros sistemas\n\nCrear un cluster Kubernetes es tan simple como ejecutar kind create cluster.\n\nPara obtener más configuración de la instalación, consulte la documentación oficial de KinD.\n\nAccediendo el cluster KinD\n\nDe forma predeterminada, la configuración de acceso al clúster se almacena en ${HOME}/.kube/config si la variable de entorno $KUBECONFIG no está establecida. Usted puede establecer esta variable de ambiente KUBECONFIG con el siguiente comando:\n\nexport KUBECONFIG=${HOME}/.kube/config					\				n		\				n\nUtili					ce el siguiente comando para verificar la conexión del clúster y asegurarse de que el clúster al que se que conectó, es el clúster que fue creado por KinD:\n\nkubectl cluster-info --context kind-kind\n\n\nPara borrar su cluster use:\n\nkind delete cluster --name kind\n\n\nUsando Helm\n\nHelm v3\n\nRecomendamos encarecidamente utilizar Helm v3, debido a que la versión actual ya no incluye el componente Tiller(https://helm.sh/blog/helm-3-preview-pt2/#helm). Es más ligero y seguro de esta manera.\n\nEjecute lo siguienteg:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n\n\n\n  NodePort - Si su cluster no cuenta con un Controlador Ingress (Ingress Controller) o un balanceador de cargas, entonces utilice NodePort para exponer Meshery y que pueda ser modificado en values.yaml:\n\n\nservice:\n  type: NodePort\n  port: 8080\n  annotations: {}"
					}




					,

					"installation-platforms-kind": {
						"id": "installation-platforms-kind",
						"title": "KinD",
						"categories": "",
						"url": " /installation/platforms/kind",
						"content": "Quick Start with KinD \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on KinD\n\n\n  Install kinD\n  Create a Kubernetes cluster with kinD\n    \n      Access the kinD cluster\n    \n  \n  Alternatively, Run Helm\n\n\nInstallation\n\n\n  On Mac / Linux via Homebrew (Recommended):\n\n\n\n \n brew install kind\n \n \n\n\n  On macOS / Linux via curl:\n\n\n\n \n curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.8.1/kind-$(uname)-amd64\n chmod +x ./kind\n mv ./kind /some-dir-in-your-PATH/kind\n \n \n\nIf you are running Ubuntu on WSL2, use Docker Ubuntu distro to install Docker.\n\nCreate cluster using KinD\n\nIn order to successfully build the Meshery server on your local server, follow the instructions specific to your Operating System to complete the creation of a KinD cluster.\n\n1. KinD on WSL2\n\nFirst, we will get the ip address of your WSL2 distro by:\n\n\n \n ip addr | grep eth0\n \n \n\nYou will see the output like:\n\n\n \n 4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    inet 172.1.1.1/20 brd 172.1.1.255 scope global eth0\n \n \n\nCopy the ip address, we will use that in the next step.\n\nThen, create a file called kind_cluster.yaml and put the ip address under apiServerAddress:\n\n\n \n kind: Cluster\n apiVersion: kind.x-k8s.io/v1alpha4\n networking:\n   apiServerAddress: \"172.1.1.1\"\n \n \n\nNow create the KinD cluster with the config file kind_cluster.yaml:\n\n\n \n kind create cluster --config kind_cluster.yaml --name kind --wait 300s\n \n \n\nYou will see\n\nCreating cluster \"kind\" ...\n • Ensuring node image (kindest/node:v1.17.0) 🖼  ...\n ✓ Ensuring node image (kindest/node:v1.17.0) 🖼\n • Preparing nodes 📦   ...\n ✓ Preparing nodes 📦\n • Writing configuration 📜  ...\n ✓ Writing configuration 📜\n • Starting control-plane 🕹️  ...\n ✓ Starting control-plane 🕹️\n • Installing CNI 🔌  ...\n ✓ Installing CNI 🔌\n • Installing StorageClass 💾  ...\n ✓ Installing StorageClass 💾\n • Waiting ≤ 5m0s for control-plane = Ready ⏳  ...\n ✓ Waiting ≤ 5m0s for control-plane = Ready ⏳\n • Ready after 59s 💚\nSet kubectl context to \"kind-kind\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kind\n\nNot sure what to do next? 😅 Check out https://kind.sigs.k8s.io/docs/user/quick-start/\n\n\n2. KinD on other systems\n\nCreating a Kubernetes cluster is as simple as kind create cluster.\n\nFor more configuration of installation, please refer to KinD official documentation.\n\nAccess the KinD cluster\n\nBy default, the cluster access configuration is stored in ${HOME}/.kube/config if $KUBECONFIG environment variable is not set. You can set the KUBECONFIG environment with the command below:\n\n\n \n export KUBECONFIG=${HOME}/.kube/config\n \n \n\nUse the command below check the connection of the cluster and make sure the clus					t				e		r				 you con					nected what’s the cluster was created by KinD:\n\n\n \n kubectl cluster-info --context kind-kind\n \n \n\nTo delete your cluster use:\n\n\n \n kind delete cluster --name kind\n \n \n\nUsing Helm\n\nHelm v3\n\nWe strongly recommend to use Helm v3, because of this version not including the Tiller(https://helm.sh/blog/helm-3-preview-pt2/#helm) component anymore. It’s lighter and safer.\n\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n \n \n\n\n  NodePort - If your cluster does not have an Ingress Controller or a load balancer, then use NodePort to expose Meshery and that can be modify under the chart values.yaml:\n\n\n\n \n service:\n   type: NodePort\n   port: 8080\n   annotations: {}\n \n \n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}




					,

					"es-installation-platforms-kubernetes": {
						"id": "es-installation-platforms-kubernetes",
						"title": "Kubernetes",
						"categories": "",
						"url": " /es/installation/platforms/kubernetes",
						"content": "Inicio Rápido con Kubernetes\n\nPara preparar y ejecutar Meshery en Kubernetes:\n\n\n  \n     Use Helm y configure un cluster Kubernetes \n  \n  \n    Ejecutar Meshery en un cluster Kubernetes existente\n  \n\n\nUsando Helm\n\n1. Helm v3\n\nEjecute lo siguiente:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n\n\n2. Helm v2\n\nEjecute lo siguiente:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm template meshery --namespace meshery install/kubernetes/helm/meshery | kubectl apply -f -\n\n\nUsando el Manifiesto de Kubernetes\n\nMeshery también puede ser desplegado(deployed) en un clúster de Kubernetes existente.Vea tabla de compatibilidades para la compatibilidad de versiones. Para instalar Meshery en su cluster, clone el repositorio de Meshery:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n\n\nCree un nombre de espacio (namespace) como un nuevo espacio lógico para hospedar Meshery y sus componentes:\n\n$ kubectl create ns meshery\n\n\nTodos los yamls de despliegue necesarios para desplegar(deploy) Meshery se incluyen en la carpeta ʻinstall / deployment_yamls / k8s` dentro de la carpeta Meshery clonada. Para implementar los yamls en el clúster, ejecute el siguiente comando:\n\n$ kubectl -n meshery apply -f install/deployment_yamls/k8s\n\n\nUna vez que se desplieguen los archivos yaml, necesitamos exponer el servicio meshery para poder acceder al servicio desde fuera del clúster. Hay varias formas de exponer un servicio en Kubernetes. Aquí describiremos 3 formas co					m				u		n				es en la					s que podemos exponer un servicio:\n\n\n  Ingress - Si su cluster Kubernetes tiene un Controlador Ingress (Ingress Controller) funcional, entonces usted puede configurar un ingreso para exponer Meshery:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\nname: meshery-ingress\nannotations:\n    kubernetes.io/ingress.class: \"nginx\"\nspec:\nrules:\n- host: *\n    http:\n    paths:\n    - path: /\n        backend:\n        serviceName: meshery-service\n        servicePort: 8080\n\n\n\n  \n    Balanceador de Cargas -\nSi su clúster de Kubernetes tiene un balanceador de carga externo, esta podría ser la ruta lógica.\n  \n  \n    NodePort -\nSi su clúster no tiene un Controlador Ingress (Ingress Controller) o un balanceador de carga, use NodePort para exponer Meshery:\n  \n\n\napiVersion: v1\nkind: Service\nspec:\n    type: NodePort\n\n\nMeshery debe ahora ser conectado con su instancia administrada de Kubernetes. Eche un vistazo a las guías guías Meshery para tips de uso advanzado."
					}




					,

					"installation-platforms-kubernetes": {
						"id": "installation-platforms-kubernetes",
						"title": "Kubernetes",
						"categories": "",
						"url": " /installation/platforms/kubernetes",
						"content": "Quick Start with Kubernetes \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on Kubernetes\n\n\n   Use Helm and set up a Kubernetes cluster\n  Run Meshery on existing Kubernetes cluster\n\n\nUsing Helm\n\n1. Helm v3\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n \n \n\n2. Helm v2\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm template meshery --namespace meshery install/kubernetes/helm/meshery | kubectl apply -f -\n \n \n\nUsing Kubernetes Manifests\nMeshery can also be deployed on an existing Kubernetes cluster. See compatibility table for version compatibility. To install Meshery on your cluster, clone the Meshery repo:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; \n $ cd meshery\n \n \n\nCreate a namespace as a new logical space to host Meshery and its components:\n\n\n \n $ kubectl create ns meshery\n \n \n\nAll the needed deployment yamls for deploying Meshery are included in the install/deployment_yamls/k8s folder inside the cloned Meshery folder. To deploy the yamls on the cluster please run the following command:\n\n\n \n $ kubectl -n meshery apply -f install/deployment_yamls/k8s\n \n \n\nOnce the yaml files are deployed, we need to expose the meshery service to be able to access the service from outside the cluster. Ther					e				 		a				re sever					al ways a service can be exposed on Kubernetes. Here we will describe 3 common ways we can expose a service:\n\nIngress\n\nIf your Kubernetes cluster has a functional Ingress Controller, then you can configure an ingress to expose Meshery:\n\n\n \n apiVersion: extensions/v1beta1\n kind: Ingress\n metadata:\n name: meshery-ingress\n annotations:\n     kubernetes.io/ingress.class: \"nginx\"\n spec:\n rules:\n - host: *\n     http:\n     paths:\n     - path: /\n         backend:\n         serviceName: meshery-service\n         servicePort: 8080\n \n \n\n\n  \n    LoadBalancer - If your Kubernetes cluster has an external load balancer, this might be a logical route.\n  \n  \n    NodePort - If your cluster does not have an Ingress Controller or a load balancer, then use NodePort to expose Meshery:\n  \n\n\n\n \n apiVersion: v1\n kind: Service\n spec:\n     type: NodePort\n \n \n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}




					,

					"extensibility-load-generators": {
						"id": "extensibility-load-generators",
						"title": "Extensibility: Load Generators",
						"categories": "",
						"url": " /extensibility/load-generators",
						"content": "Users may prefer to use one load generator over the next given the difference of capabilities between load generators, so Meshery provides a load generator interface (a gRPC interface) behind which a load generator can be implemented. Meshery provides users with choice of which load generator they prefer to use for a given performance test. Users may set their configure their own preference of load generator different that the default load generator.\n\nWhat function do load generators in Meshery provide?\n\nLoad generators will provide the capability to run load tests from Meshery. As of today the load generators are embedded as librari					e				s		 				in Meshe					ry and Meshery invokes the load generators APIs with the right load test options to run the load test. At the moment, Meshery has support for HTTP load generators. Support for GRPC and TCP load testing is on the roadmap. Meshery has functional integration with fortio, wrk2, and nighthawk.\n\nWhy support multiple load generators?\n\nDifferent use cases and different opinions call for different approaches to statistical analysis of the performance results. For example, wrk2 accounts for a concept called Coordinated Omission.\n\nWhich load generators does Meshery support?\n\n\n  fortio - Fortio load testing library, command line tool, advanced echo server and web UI in go (golang). Allows to specify a set query-per-second load and record latency histograms and other useful stats.\n  wrk2 - A constant throughput, correct latency recording variant of wrk.\n  nighthawk - Enables users to run distributed performance tests to better mimic real-world, distributed systems scenarios.\n    \n      See the GetNighthawk project."
					}




					,

					"assets-js-lunr-min-js": {
						"id": "assets-js-lunr-min-js",
						"title": "",
						"categories": "",
						"url": " /assets/js/lunr.min.js",
						"content": "/**\n * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 0.7.0\n * Copyright (C) 2016 Oliver Nightingale\n * MIT Licensed\n * @license\n */\n!function(){var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version=\"0.7.0\",t.utils={},t.utils.warn=function(t){return function(e){t.console&&console.warn&&console.warn(e)}}(this),t.utils.asString=function(t){return void 0===t||null===t?\"\":t.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var t=Array.prototype.slice.call(arguments),e=t.pop(),n=t;if(\"function\"!=typeof e)throw new TypeError(\"last argument must be a function\");n.forEach(function(t){this.hasHandler(t)||(this.events[t]=[]),this.events[t].push(e)},this)},t.EventEmitter.prototype.removeListener=function(t,e){if(this.hasHandler(t)){var n=this.events[t].indexOf(e);this.events[t].splice(n,1),this.events[t].length||delete this.events[t]}},t.EventEmitter.prototype.emit=function(t){if(this.hasHandler(t)){var e=Array.prototype.slice.call(arguments,1);this.events[t].forEach(function(t){t.apply(void 0,e)})}},t.EventEmitter.prototype.hasHandler=function(t){return t in this.events},t.tokenizer=function(e){return arguments.length&&null!=e&&void 0!=e?Array.isArray(e)?e.map(function(e){return t.utils.asString(e).toLowerCase()}):e.toString().trim().toLowerCase().split(t.tokenizer.seperator):[]},t.tokenizer.seperator=/[\\s\\-]+/,t.tokenizer.load=function(t){var e=this.registeredFunctions[t];if(!e)throw new Error(\"Cannot load un-registered function: \"+t);return e},t.tokenizer.label=\"default\",t.tokenizer.registeredFunctions={\"default\":t.tokenizer},t.tokenizer.registerFunction=function(e,n){n in this.registeredFunctions&&t.utils.warn(\"Overwriting existing tokenizer: \"+n),e.label=n,this.registeredFunctions[n]=e},t.Pipeline=function(){this._stack=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in this.registeredFunctions&&t.utils.warn(\"Overwriting existing registered function: \"+n),e.label=n,t.Pipeline.registeredFunctions[e.label]=e},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn(\"Function is not registered with pipeline. This may cause problems when serialising the index.\\n\",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.registeredFunctions[e];if(!i)throw new Error(\"Cannot load un-registered function: \"+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._stack.indexOf(e);if(-1==i)throw new Error(\"Cannot find existingFn\");i+=1,this._stack.splice(i,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._stack.indexOf(e);if(-1==i)throw new Error(\"Cannot find existingFn\");this._stack.splice(i,0,n)},t.Pipeline.prototype.remove=function(t){var e=this._stack.indexOf(t);-1!=e&&this._stack.splice(e,1)},t.Pipeline.prototype.run=function(t){for(var e=[],n=t.length,i=this._stack.length,r=0;n>r;r++){for(var o=t[r],s=0;i>s&&(o=this._stack[s](o,r,t),void 0!==o&&\"\"!==o);s++);void 0!==o&&\"\"!==o&&e.push(o)}return e},t.Pipeline.prototype.reset=function(){this._stack=[]},t.Pipeline.prototype.toJSON=function(){return this._stack.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Vector=function(){this._magnitude=null,this.list=void 0,this.length=0},t.Vector.Node=function(t,e,n){this.idx=t,this.val=e,this.next=n},t.Vector.prototype.insert=function(e,n){this._magnitude=void 0;var i=this.list;if(!i)return this.list=new t.Vector.Node(e,n,i),this.length++;if(en.idx?n=n.next:(i+=e.val*n.val,e=e.next,n=n.next);return i},t.Vector.prototype.similarity=function(t){return this.dot(t)/(this.magnitude()*t.magnitude())},t.SortedSet=function(){this.length=0,this.elements=[]},t.SortedSet.load=function(t){var e=new this;return e.elements=t,e.length=t.length,e},t.SortedSet.prototype.add=function(){var t,e;for(t=0;t1;){if(o===t)return r;t>o&&(e=r),o>t&&(n=r),i=n-e,r=e+Math.floor(i/2),o=this.elements[r]}return o===t?r:-1},t.SortedSet.prototype.locationFor=function(t){for(var e=0,n=this.elements.length,i=n-e,r=e+Math.floor(i/2),o=this.elements[r];i>1;)t>o&&(e=r),o>t&&(n=r),i=n-e,r=e+Math.floor(i/2),o=this.elements[r];return o>t?r:t>o?r+1:void 0},t.SortedSet.prototype.intersect=function(e){for(var n=new t.SortedSet,i=0,r=0,o=this.length,s=e.length,a=this.elements,h=e.elements;;){if(i>o-1||r>s-1)break;a[i]!==h[r]?a[i]h[r]&&r++:(n.add(a[i]),i++,r++)}return n},t.SortedSet.prototype.clone=function(){var e=new t.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},t.SortedSet.prototype.union=function(t){var e,n,i;this.length>=t.length?(e=this,n=t):(e=t,n=this),i=e.clone();for(var r=0,o=n.toArray();rp;p++)c[p]===a&&d++;h+=d/f*l.boost}}this.tokenStore.add(a,{ref:o,tf:h})}n&&this.eventEmitter.emit(\"add\",e,this)},t.Index.prototype.remove=function(t,e){var n=t[this._ref],e=void 0===e?!0:e;if(this.documentStore.has(n)){var i=this.documentStore.get(n);this.documentStore.remove(n),i.forEach(function(t){this.tokenStore.remove(t,n)},this),e&&this.eventEmitter.emit(\"remove\",t,this)}},t.Index.prototype.update=function(t,e){var e=void 0===e?!0:e;this.remove(t,!1),this.add(t,!1),e&&this.eventEmitter.emit(\"update\",t,this)},t.Index.prototype.idf=function(t){var e=\"@\"+t;if(Object.prototype.hasOwnProperty.call(this._idfCache,e))return this._idfCache[e];var n=this.tokenStore.count(t),i=1;return n>0&&(i=1+Math.log(this.documentStore.length/n)),this._idfCache[e]=i},t.Index.prototype.search=function(e){var n=this.pipeline.run(this.tokenizerFn(e)),i=new t.Vector,r=[],o=this._fields.reduce(function(t,e){return t+e.boost},0),s=n.some(function(t){return this.tokenStore.has(t)},this);if(!s)return[];n.forEach(function(e,n,s){var a=1/s.length*this._fields.length*o,h=this,u=this.tokenStore.expand(e).reduce(function(n,r){var o=h.corpusTokens.indexOf(r),s=h.idf(r),u=1,l=new t.SortedSet;if(r!==e){var c=Math.max(3,r.length-e.length);u=1/Math.log(c)}o>-1&&i.insert(o,a*s*u);for(var f=h.tokenStore.get(r),d=Object.keys(f),p=d.length,v=0;p>v;v++)l.add(f[d[v]].ref);return n.union(l)},new t.SortedSet);r.push(u)},this);var a=r.reduce(function(t,e){return t.intersect(e)});return a.map(function(t){return{ref:t,score:i.similarity(this.documentVector(t))}},this).sort(function(t,e){return e.score-t.score})},t.Index.prototype.documentVector=function(e){for(var n=this.documentStore.get(e),i=n.length,r=new t.Vector,o=0;i>o;o++){var s=n.elements[o],a=this.tokenStore.get(s)[e].tf,h=this.idf(s);r.insert(this.corpusTokens.indexOf(s),a*h)}return r},t.Index.prototype.toJSON=function(){return{version:t.version,fields:this._fields,ref:this._ref,tokenizer:this.tokenizerFn.label,documentStore:this.documentStore.toJSON(),tokenStore:this.tokenStore.toJSON(),corpusTokens:this.corpusTokens.toJSON(),pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(t){var e=Array.prototype.slice.call(arguments,1);e.unshift(this),t.apply(this,e)},t.Store=function(){this.store={},this.length=0},t.Store.load=function(e){var n=new this;return n.length=e.length,n.store=Object.keys(e.store).reduce(function(n,i){return n[i]=t.SortedSet.load(e.store[i]),n},{}),n},t.Store.prototype.set=function(t,e){this.has(t)||this.length++,this.store[t]=e},t.Store.prototype.get=function(t){return this.store[t]},t.Store.prototype.has=function(t){return t in this.store},t.Store.prototype.remove=function(t){this.has(t)&&(delete this.store[t],this.length--)},t.Store.prototype.toJSON=function(){return{store:this.store,length:this.length}},t.stemmer=function(){var t={ational:\"ate\",tional:\"tion\",enci:\"ence\",anci:\"ance\",izer:\"ize\",bli:\"ble\",alli:\"al\",entli:\"ent\",eli:\"e\",ousli:\"ous\",ization:\"ize\",ation:\"ate\",ator:\"ate\",alism:\"al\",iveness:\"ive\",fulness:\"ful\",ousness:\"ous\",aliti:\"al\",iviti:\"ive\",biliti:\"ble\",logi:\"log\"},e={icate:\"ic\",ative:\"\",alize:\"al\",iciti:\"ic\",ical:\"ic\",ful:\"\",ness:\"\"},n=\"[^aeiou]\",i=\"[aeiouy]\",r=n+\"[^aeiouy]*\",o=i+\"[aeiou]*\",s=\"^(\"+r+\")?\"+o+r,a=\"^(\"+r+\")?\"+o+r+\"(\"+o+\")?$\",h=\"^(\"+r+\")?\"+o+r+o+r,u=\"^(\"+r+\")?\"+i,l=new RegExp(s),c=new RegExp(h),f=new RegExp(a),d=new RegExp(u),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,w=new RegExp(\"([^aeiouylsz])\\\\1$\"),k=new RegExp(\"^\"+r+i+\"[^aeiouwxy]$\"),x=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,F=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,_=/^(.+?)(s|t)(ion)$/,z=/^(.+?)e$/,O=/ll$/,P=new RegExp(\"^\"+r+i+\"[^aeiouwxy]$\"),T=function(n){var i,r,o,s,a,h,u;if(n.length<3)return n;if(o=n.substr(0,1),\"y\"==o&&(n=o.toUpperCase()+n.substr(1)),s=p,a=v,s.test(n)?n=n.replace(s,\"$1$2\"):a.test(n)&&(n=n.replace(a,\"$1$2\")),s=g,a=m,s.test(n)){var T=s.exec(n);s=l,s.test(T[1])&&(s=y,n=n.replace(s,\"\"))}else if(a.test(n)){var T=a.exec(n);i=T[1],a=d,a.test(i)&&(n=i,a=S,h=w,u=k,a.test(n)?n+=\"e\":h.test(n)?(s=y,n=n.replace(s,\"\")):u.test(n)&&(n+=\"e\"))}if(s=x,s.test(n)){var T=s.exec(n);i=T[1],n=i+\"i\"}if(s=b,s.test(n)){var T=s.exec(n);i=T[1],r=T[2],s=l,s.test(i)&&(n=i+t[r])}if(s=E,s.test(n)){var T=s.exec(n);i=T[1],r=T[2],s=l,s.test(i)&&(n=i+e[r])}if(s=F,a=_,s.test(n)){var T=s.exec(n);i=T[1],s=c,s.test(i)&&(n=i)}else if(a.test(n)){var T=a.exec(n);i=T[1]+T[2],a=c,a.test(i)&&(n=i)}if(s=z,s.test(n)){var T=s.exec(n);i=T[1],s=c,a=f,h=P,(s.test(i)||a.test(i)&&!h.test(i))&&(n=i)}return s=O,a=c,s.test(n)&&a.test(n)&&(s=y,n=n.replace(s,\"\")),\"y\"==o&&(n=o.toLowerCase()+n.substr(1)),n};return T}(),t.Pipeline.registerFunction(t.stemmer,\"stemmer\"),t.generateStopWordFilter=function(t){var e=t.reduce(function(t,e){return t[e]=e,t},{});return function(t){return t&&e[t]!==t?t:void 0}},t.stopWordFilter=t.generateStopWordFilter([\"a\",\"able\",\"about\",\"across\",\"after\",\"all\",\"almost\",\"also\",\"am\",\"among\",\"an\",\"and\",\"any\",\"are\",\"as\",\"at\",\"be\",\"because\",\"been\",\"but\",\"by\",\"can\",\"cannot\",\"could\",\"dear\",\"did\",\"do\",\"does\",\"either\",\"else\",\"ever\",\"every\",\"for\",\"from\",\"get\",\"got\",\"had\",\"has\",\"have\",\"he\",\"her\",\"hers\",\"him\",\"his\",\"how\",\"however\",\"i\",\"if\",\"in\",\"into\",\"is\",\"it\",\"its\",\"just\",\"least\",\"let\",\"like\",\"likely\",\"may\",\"me\",\"might\",\"most\",\"must\",\"my\",\"neither\",\"no\",\"nor\",\"not\",\"of\",\"off\",\"often\",\"on\",\"only\",\"or\",\"other\",\"our\",\"own\",\"rather\",\"said\",\"say\",\"says\",\"she\",\"should\",\"since\",\"so\",\"some\",\"than\",\"that\",\"the\",\"their\",\"them\",\"then\",\"there\",\"these\",\"they\",\"this\",\"tis\",\"to\",\"too\",\"twas\",\"us\",\"wants\",\"was\",\"we\",\"were\",\"what\",\"when\",\"where\",\"which\",\"while\",\"who\",\"whom\",\"why\",\"will\",\"with\",\"would\",\"yet\",\"you\",\"your\"]),t.Pipeline.registerFunction(t.stopWordFilter,\"stopWordFilter\"),t.trimmer=function(t){return t.replace(/^\\W+/,\"\").replace(/\\W+$/,\"\")},t.Pipeline.registerFunction(t.trimmer,\"trimmer\"),t.TokenStore=function(){this.root={docs:{}},this.length=0},t.TokenStore.load=function(t){var e=new this;return e.root=t.root,e.length=t.length,e},t.TokenStore.prototype.add=function(t,e,n){var n=n||this.root,i=t.charAt(0),r=t.slice(1);return i in n||(n[i]={docs:{}}),0===r.length?(n[i].docs[e.ref]=e,void(this.length+=1)):this.add(r,e,n[i])},t.TokenStore.pr					o				t		o				t		y				pe.has=f					unction(t){if(!t)return!1;for(var e=this.root,n=0;n<t.length;n++){if(!e[t.charAt(n)])return!1;e=e[t.charAt(n)]}return!0},t.TokenStore.prototype.getNode=function(t){if(!t)return{};for(var e=this.root,n=0;n<t.length;n++){if(!e[t.charAt(n)])return{};e=e[t.charAt(n)]}return e},t.TokenStore.prototype.get=function(t,e){return this.getNode(t,e).docs||{}},t.TokenStore.prototype.count=function(t,e){return Object.keys(this.get(t,e)).length},t.TokenStore.prototype.remove=function(t,e){if(t){for(var n=this.root,i=0;i<t.length;i++){if(!(t.charAt(i)in n))return;n=n[t.charAt(i)]}delete n.docs[e]}},t.TokenStore.prototype.expand=function(t,e){var n=this.getNode(t),i=n.docs||{},e=e||[];return Object.keys(i).length&&e.push(t),Object.keys(n).forEach(function(n){\"docs\"!==n&&e.concat(this.expand(t+n,e))},this),e},t.TokenStore.prototype.toJSON=function(){return{root:this.root,length:this.length}},function(t,e){\"function\"==typeof define&&define.amd?					d				e		f				ine(e):\					"object\"==typeof exports?module.exports=e():t.lunr=e()}(this,function(){return t})}();"
					}






					,

					"assets-js-main-js": {
						"id": "assets-js-main-js",
						"title": "",
						"categories": "",
						"url": " /assets/js/main.js",
						"content": "(function($) {\n    'use strict';\n    $(function() {\n        $('[data-toggle=\"tooltip\"]').tooltip();\n        $('[data-toggle=\"popover\"]').popover();\n        $('.popover-dismiss').popover({\n            trigger: 'focus'\n        })\n    });\n\n    function bottomPos(element) {\n        return element.offset().top + element.outerHeight();\n    }\n    $(function() {\n        var promo = $(\".js-td-cover\");\n        if (!promo.length) {\n            return\n        }\n        var promoOffset = bottomPos(promo);\n        var navbarOffset = $('.js-navbar-scroll').offset().top;\n        var threshold = Math.ceil($('.js-navbar-scroll').outerHeight());\n        if ((promoOffset - navbarOffset) ';\n       $(this).after(clipButton);\n});\n\nnew Clipboard('.clipbtn');"
					}




					,

					"es-functionality-lifecycle-management": {
						"id": "es-functionality-lifecycle-management",
						"title": "Lifecycle Management",
						"categories": "",
						"url": " /es/functionality/lifecycle-management",
						"content": "Gestión del ciclo de vida del service mesh\nMeshery soporta varios service mesh diferentes, de modo que puede aprender y comparar diferentes funcionalidades de service mesh. Una vez que haya seleccionado operar un service mesh determinado, Meshery le ayudará con las actividades en curso.\n\nDespliegue de un service mesh\nMeshery automatiza el aprovisionamiento de varios service mesh, permitiendo a los usuarios seleccionar diferentes perfiles de configuración para admitir una variedad de modelos de despliegue.\n\nInstalación de aplicaciones de muestra\nComúnmente junto a cada service mesh hay una aplicación de muestra que facilita la demostración del valor del service mesh dado. Meshery permite que rápidamente despliegue l					a				 		m				isma apl					icación de muestra en diferentes service mesh.\n\nUso de configuración de service mesh personalizada\nMeshery le brinda la posibilidad, a usted como administrador, de personalizar el despliegue de su service mesh.\n\nEliminación de un service mesh\nAsí como Meshery automatiza el aprovisionamiento de varios service mesh, también facilita el desaprovisionamiento de los service mesh.\n\nNotificaciones\nMeshery monitorea los service mesh y la salud de la aplicación. Meshery proporciona notificaciones de los problemas de ambiente, conflictos de aplicaciones con la configuración del service mesh.\n\nReconocer y descartar notificaciones\nLa mayoría de las notificaciones son informativas y pueden descartarse fácilmente después de leerlas. Algunas notificaciones incluyen alertas accionables.\n\nActuar sobre las alertas\n\nLas notificaciones particulares que Meshery presenta son accionables inmediatamente. Estas se indican por un resaltado de color rojo. Manténgase atento ante estas alertas y actue de inmediato para asegurar un buen funcionamiento del service mesh."
					}




					,

					"functionality-lifecycle-management": {
						"id": "functionality-lifecycle-management",
						"title": "Lifecycle Management",
						"categories": "",
						"url": " /functionality/lifecycle-management",
						"content": "Service Mesh Lifecycle Management\n\nMeshery supports a number of different service meshes, so that you can learn and compare different service mesh functionality. Once you have selected to operate a given service mesh, Meshery will assist you with ongoing activities.\n\nDeploying a service mesh\n\nMeshery automates the provisioning of various service meshes, allowing users to select different configuration profiles in order to support a variety of deployment models.\n\nMeshery adapters will dynamically retrieve the specific service mesh’s release package upon initial deployment of a given service mesh. Meshery adapters cache (in .meshery/bin) the service mesh installation package.\n\nInstalling sample applications\n\nCommonly adjoining each service mesh is a sample applica					t				i		o				n that f					acilitates demonstration of the value of the given service mesh. Meshery allows you to efficiently deploy the same sample application across different service meshes.\n\nUse custom service mesh configuration\n\nMeshery provides the ability for you as a service mesh manager to customize your service mesh deployment.\n\nDeleting a service mesh\n\nJust as Meshery automates the provisioning of various service meshes, so does it facilitate the deprovisioning of service meshes.\n\nNotifications\n\nMeshery tracks service mesh and application health. Meshery provides notification of environment issues, application conflicts with service mesh configuration.\n\nAcknowledging and dismissing notifications\n\nMany notifications are informational and can readily be dismissed after reading. Some notifications include actionable alerts.\n\nTaking action on alerts\n\nParticular notifications that Meshery presents are immediately actionable. These are denoted by a red colored highlight. Be on the lookout for these alerts and take action promptly to ensure a smooth running service mesh."
					}




					,

					"guides-meshery-metrics": {
						"id": "guides-meshery-metrics",
						"title": "Using Metrics in Meshery",
						"categories": "",
															"		u				rl": " /					guides/meshery-metrics",
						"content": "Connect and use metrics in Meshery\n\nMeshery provides performance reports, including performance test results, node resource metrics etc. so that operators may easily understand the overhead of their service mesh’s control plane and data plane in context of the overhead incurred on nodes running within the cluster. In order to generate performance test reports of service meshes and their workloads, Meshery uses Grafana and/or Prometheus as visualization and metrics systems, respectively. This guide outlines the requirements necessary for Meshery to connect to these systems. The steps may vary depending upon the service mesh and its configuration.\n\nIn order to pull in these environment metrics, you can also manually configure Meshery to connect with your existing Grafana and/or Prometheus instances through the Meshery dashboard. Once they have been loaded and are displayed on the screen, you may also perform an ad-hoc test to check Meshery’s connection status.\n\n\n\nSuggested Reading\n\n\n  Guide: Interpreting Performance Test Results"
					}




					,

					"reference-mesheryctl": {
						"id": "reference-mesheryctl",
						"title": "mesheryctl Command Reference",
						"categories": "",
						"url": " /reference/mesheryctl",
						"content": "Categories and Command Structure\n\nMeshery CLI commands are categorized by function, which are:\n\n\n  mesheryctl - Global flags\n  mesheryctl system - Meshery Lifecycle and Troubleshooting\n  mesheryctl mesh - Service Mesh Lifecycle &amp; Configuration Management\n  mesheryctl perf -  Service Mesh Performance Management\n\n\nGlobal Commands and Flags\n\n\n  \n    \n      command\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      mesheryctl\n       \n      Displays help about any command.\n      mesheryctl\n    \n    \n       \n      version\n      Displays the version of the Meshery Client (mesheryctl) and the SHA of the release binary.\n      mesheryctl system version\n    \n    \n       \n      config\n      configures Meshery with the kubeconfig, generated with the help of user details, to provide cluster access for public clouds(GKE/EKS).\n      mesheryctl system config gke --token \"PATH TO TOKEN\"\n    \n    \n       \n      mesheryctl-config\n      (optional) path to Meshery Client (mesheryctl) configuration file (~/.meshery/mesheryctl.yaml) to overrides defaults.\n      mesheryctl perf &lt;args&gt; --mesheryctl-config=~/.meshery/mesheryctl.yaml\n    \n    \n       \n      verbose\n      (optional) Sets the log level to debug for verbose output.\n      mesheryctl &lt;command&gt; --verbose\n    \n    \n       \n      help\n      Displays helpful information about any command.\n      mesheryctl --help\n    \n  \n\n\nMeshery Lifecycle Management\n\nInstallation, troubleshooting and debugging of Meshery and its adapters.\n\n\n  \n    \n      command\n      arg\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      system\n       \n       \n       \n      mesheryctl system\n    \n    \n       \n      channel\n       \n      Switch between release channels.\n      mesheryctl system channel\n    \n    \n       \n      config\n       \n      Configures Meshery to use a Kubernetes cluster.\n      mesheryctl system config gke --token ~/Downloads/auth.json\n    \n    \n       \n      log\n       \n      Starts tailing Meshery server debug logs.\n      mesheryctl system log\n    \n    \n       \n      start\n       \n      Start all Meshery containers.\n      mesheryctl system start\n    \n    \n       \n      completion\n       \n      Generates completion script.\n      mesheryctl system completion [bash\\|zsh\\|fish]\n    \n    \n       \n      status\n       \n      Displays the status of Meshery’s containers (server and adapters).\n      mesheryctl system status\n    \n    \n       \n      stop\n       \n      Stop all Meshery containers.\n      mesheryctl system stop\n    \n    \n       \n      reset\n       \n      Resets meshery.yaml with copy from Meshery repo. Warning - Any local changes will be overwritten.\n      mesheryctl system reset\n    \n    \n       \n      update\n       \n      Pull new Meshery images from Docker Hub. Does not pulls new mesheryctl client. This command may be executed while Meshery is running.\n      mesheryctl system update\n    \n    \n       \n      help\n       \n      Displays help about any Meshery lifecycle management command.\n      mesheryctl system --help\n    \n    \n       \n      channel\n      switch\n      switch release channel and version\n      mesheryctl system channel switch [stable|stable-version|edge|edge-version]\n    \n    \n       \n      channel\n      view\n      view release channel and version\n      mesheryctl system channel view\n    \n    \n       \n      start\n      –reset\n      (optional) reset Meshery’s configuration file to default settings.\n      mesheryctl system start --reset\n    \n    \n       \n      start\n      –skip-update\n      (optional) skip updates available in Meshery.\n      mesheryctl system start --skip-update\n    \n    \n       \n      channel\n      set\n      set release channel and version.\n      mesheryctl system channel set [stable|stable-version|edge|edge-version]\n    \n    \n       \n      stop\n      –reset\n      (optional) reset Meshery’s configuration file to default settings.\n      mesheryctl system stop --reset\n    \n  \n\n\nPerformance Management\n\n\n  \n    \n      command\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      perf\n       \n      Performance management - baselining and testing.\n      mesheryctl perf --name \"a quick stress test\" --url http://192.168.1.15/productpage --qps 300 --concurrent-requests 2 --duration 30s --load-generator wrk2\n    \n    \n       \n      –mesh (optional)\n      Name of the service mesh. (default) empty string\n       \n    \n    \n       \n      –load-generator (optional)\n      Choice of load generator - fortio (OR) wrk2 (default) fortio\n      --load-generator=fortio\n    \n    \n       \n      –file (optional)\n      URI of the service mesh performance test configuration file. (default) empty string\n      --file soak-test-clusterA.yaml\n    \n    \n       \n      –qps (optional)\n      Queries per second (default) 0 (0 - means to use the CPU unbounded to generate as many requests as possible.\n      --qps 30\n    \n    \n       \n      –url (required)\n      URL of the endpoint send load to during testing.\n      http://my-service/api/v1/test\n    \n    \n       \n      –name (optional)\n      A memorable name for th					e				 		t				est. (de					fault) a random string\n       \n    \n    \n       \n      –concurrent-requests (optional)\n      Number of concurrent requests (default) 1\n      --concurrent-requests 10\n    \n    \n       \n      –duration(optional)\n      Duration of the test.\n      10s, 5m, 2h\n    \n    \n       \n      –help, -h\n      Displays help the performance management command.\n      mesheryctl perf --help\n    \n  \n\n\nService Mesh Lifecycle Management\n\n\n  \n    \n      command\n      arg\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      mesh\n       \n       \n      Lifecycle management of service meshes\n       \n    \n    \n       \n      init\n       \n      Provision a service mesh\n       \n    \n    \n       \n       \n      –platform\n      Identify platform to provision service mesh on (e.g. Docker, K8s)\n      --platform docker\n    \n    \n       \n       \n      –profile\n      Use specific configuration profile\n      --profile mTLS\n    \n    \n       \n       \n      –help, -h\n      Displays help about any service mesh lifecycle management command.\n      mesheryctl help"
					}




					,

					"installation-mesheryctl": {
						"id": "installation-mesheryctl",
						"title": "Install mesheryctl",
						"categories": "",
						"url": " /installation/mesheryctl",
						"content": "Meshery’s command line client is mesheryctl. To install mesheryctl on your system, you may choose from any of the following supported methods.\n\nBash\n\nInstall\n\n\n \n curl -L https://git.io/meshery | bash -\n \n \n\nHomebrew\n\nInstall\n\nTo install mesheryctl using homebrew, execute the following commands.\n\n\n \n $ brew tap layer5io/tap\n $ brew install mesheryctl\n \n\n\nYou need to have brew installed on your Mac or Linux system to perform these actions.\n\nUpgrade\n\nTo upgrade mesheryctl, execute the following command.\n\n\n \n $ brew upgrade mesheryctl\n \n \n\nExample output of a successful upgrade:\n➜  ~ brew upgrade mesheryctl\n==&gt; Upgrading 1 outdated package:\nlayer5io/tap/mesheryctl 0.3.2 -&gt; 0.3.4\n==&gt; Upgrading layer5io/tap/mesheryctl\n==&gt; Downloading https://github.com/layer5io/meshery/releases/download/v0.3.4/mesheryctl_0.3.4_Darwin_x86_64.zip\n==&gt; Downloading from https://github-production-rel					e				a		s				e-asset-					2e65be.s3.amazonaws.com/157554479/17522b00-2af0-11ea-8aef-cbfe8\n######################################################################## 100.0%\n🍺  /usr/local/Cellar/mesheryctl/0.3.4: 5 files, 10.2MB, built in 4 seconds\nRemoving: /usr/local/Cellar/mesheryctl/0.3.2... (5 files, 10.2MB)\nRemoving: /Users/lee/Library/Caches/Homebrew/mesheryctl--0.3.2.zip... (3.9MB)\n==&gt; Checking for dependents of upgraded formulae...\n==&gt; No dependents found!\n\n\nScoop\n\nmesheryctl can be installed via Scoop (a package manager for Windows, just like apt for Ubuntu). To install mesheryctl using Scoop, execute the following commands.\n\nInstall\n\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\n\n\nYou need to have scoop installed on your Windows system to perform these actions.\n\nYou’re ready 					t				o		 				run Mesh					ery. To do so, execute the following command.\n\n\n\nmesheryctl system start\n\n\n\n\nUpgrade\n\nTo upgrade mesheryctl, just execute the following command.\n\n\n\nscoop update mesheryctl\n\n\n\n\nContinue deploying Meshery onto one of the Supported Platforms."
					}




					,

					"reference-mesheryctl-commands-command-name-template": {
						"id": "reference-mesheryctl-commands-command-name-template",
						"title": "mesheryctl &lt;command name&gt;",
						"categories": "en",
						"url": " /reference/mesheryctl/commands/command_name_template",
						"content": "mesheryctl &#60;command name&#62;\n\n\nDescription of the command preferably in a paragraph.\n\n\n\n\n  \n    \n  mesheryctl &#60;command&#62; [flags] \n    \n  \n\n\n\nExamples\n\n\n  \n    \n\n  # use case 1 (brief description)\n  mesheryctl &#60;command&#62; [flags]\n  \n  # use case 2 (brief description)\n  mesheryctl &#60;command&#62; [flags] \n    \n  \n \n\n\nOptions\n\n\n  \n    \n  [flag] (data type) short					 				d		e				scriptio					n\n    \n  \n\n\n\n\nOptions inherited from parent commands\n\n  \n    \n  Possible Options inherited from parent command"
					}




					,

					"concepts-architecture-meshsync": {
						"id": "concepts-architecture-meshsync",
						"title": "MeshSync",
						"categories": "",
						"url": " /concepts/architecture/meshsync",
						"content": "MeshSync is a custom Kubernetes controller that provides tiered discovery and continual synchronization with Meshery Server as to the state of the Kubernetes cluster, service meshes, and their workloads.\n\nWhat are its core responsibilities?\n\nDiscover existing resources inside the kubernetes cluster\nThe resources that are present inside the cluster are discovered efficiently with the help of pipelines. The data is constructed in a particular format specific to meshery and publish across to different parts of the architecture.\n\nListening to events/changes on every component\nMeshSync implements several informers/listeners across each resource to listen to changes that occur to them. These are reflected at real time and are updated in their respective areas.\n\nMeshSync FAQs"
					}




					,

					"es-installation-platforms-minikube": {
						"id": "es-installation-platforms-minikube",
						"title": "Minikube",
						"categories": "",
						"url": " /es/installation/platforms/minikube",
						"content": "Inicio Rápido con Minikube\n\nPara configurar y ejecutar Meshery en Minikube:\n\n\n  Iniciar Minikube\n  Configurar Meshery para usar minkube\n  Ejecutar Meshery\n\n\nCompatibilidad\n\nLas siguientes versiones mínimas de componentes son requieridas:\n\n\n  \n    Nombre\n    Versión \n  \n  \n    Minikube\n    1.0.0 \n  \n  \n    Kubernetes\n    1.14.1\n  \n  \n    kubectl\n    1.14.1\n  \n\n\nPasos\n\nEjecute los siguientes pasos en este orden:\n\n1. iniciar minikube\n\nminikube start --cpus 4 --memory 8192 --kubernetes-version=v1.14.1\n\n\nNota: la memoria mínima requerida es –memory=4096 (para despliegues de Istio solamente)\n\nNote: Si está utilizando manejador docker (docker driver), después de completar los pasos de instalación de Meshery, ejecute el siguiente comando para establecer la conectividad entre Meshery y el servidor Kubernetes.\n\ndocker network connect bridge meshery_meshery_1\n\n\n2. Configurar Meshery para usar minikube\n\n\n  Inicie sesión en Meshery. En el menú de su perfil de usuario, haga clic en Get					 				T		o				ken.\n  					Use mesheryctl y así configurar Meshery para usar minikube. Ejecute:\n\n\nmesheryctl system config minikube -t ~/Downloads/auth.json\n\n\nTambién puede generar y cargar manualmente el archivo kubeconfig para que Meshery lo use:\n\nEste archivo de configuración será utilizado por Meshery.\n\nkubectl config view --minify --flatten &gt; config_minikube.yaml\n\n\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: &lt; cert shortcutted &gt;\n    server: https://192.168.99.100:8443\n  name: minikube\ncontexts:\n- context:\n    cluster: minikube\n    user: minikube\n  name: minikube\ncurrent-context: minikube\nkind: Config\npreferences: {}\nusers:\n- name: minikube\n  user:\n    client-certificate-data: &lt;cert shortcutted &gt;\n    client-key-data: &lt; key shortcutted &gt;\n\n\nNota: Asegúrese que current-context (contexto actual) esté establecido a minikube.\n\n3. Configurar Meshery\n\nSiga los pasos de instalación para instalar el CLI (Intérprete de Línea de Comandos) mesheryctl.\n\nMeshery ahora debería estar conectado con su instancia administrada de Kubernetes. Eche un vistazo a guías Meshery para consejos de uso advanzado."
					}




					,

					"installation-platforms-minikube": {
						"id": "installation-platforms-minikube",
						"title": "Minikube",
						"categories": "",
						"url": " /installation/platforms/minikube",
						"content": "Quick Start with Minikube \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo Setup and run Meshery on Minikube :\n\n\n  Start Minikube\n  Configure Meshery to use minikube\n  Run Meshery\n\n\nCompatibility\nThe following minimum component versions are required:\n\n\n  \n    Name\n    Version\n  \n  \n    Minikube\n    1.0.0 \n  \n  \n    Kubernetes\n    1.14.1\n  \n  \n    kubectl\n    1.14.1\n  \n\n\nSteps\nPerform the following steps in order:\n\n1. Start minikube\n\n\n \n minikube start --cpus 4 --memory 8192 --kubernetes-version=v1.14.1\n \n \n\nNote: minimum memory required is –memory=4096 (for Istio deployments only)\n\nCheck up on your minikube cluster :\n\n\n  minikube status \n\n2. Install Meshery\n\nFollow the installation steps to setup the mesheryctl CLI and install Meshery.\n\nUsers using docker driver:\nAfter completing the Meshery installation, execute the following command to establish connectivity between Meshery and Kubernetes cluster:\n\n\n \n docker network connect bridge meshery_meshery_1\n \n \n\nTo establish connectivity between a particular Meshery Adapter and Kubernetes server, use “docker ps” to identify the name of the desired container, and execute the following command:\n\n\n \n docker network connect bridge &amp;lt container name of the desired adapter &amp;gt\n \n \n\n2. Configure Meshery to use minikube\n\n\n  \n    Login to Meshery. Under your user profile, click Get Token.\n  \n  \n    Use mesheryctl to configure Meshery to use minikube. To allow Meshery to detect your config file, execute the following commands:\n  \n\n\n\n \n mesheryctl system config minikube -t ~/Downloads/auth.json\n \n \nOptionally configure Meshery to use minikube through the Web UI :\n\n  Run the below command to generate the “config_minikube.yaml” file for your cluster:\n\n\n\n \n kubectl config view --minify --flatten &gt; config_minikube.yaml\n 					\				n		 				\n\n\n  					Upload the generated config file by navigating to Settings &gt; Environment &gt; Out of Cluster Deployment in the Web UI and using the “Upload kubeconfig” option.\n\n\nManual Steps\n\nYou may also manually generate and load the kubeconfig file for Meshery to use:\n\nThe following configuration yaml will be used by Meshery. Copy and paste the following in your config file :\n\n\n \n apiVersion: v1\n clusters:\n - cluster:\n     certificate-authority-data: &lt; cert shortcutted &gt;\n     server: https://192.168.99.100:8443\n   name: minikube\n contexts:\n - context:\n     cluster: minikube\n     user: minikube\n   name: minikube\n current-context: minikube\n kind: Config\n preferences: {}\n users:\n - name: minikube\n   user:\n     client-certificate-data: &lt; cert shortcutted &gt;\n     client-key-data: &lt; key shortcutted &gt;\n \n \n\nNote: Make sure current-context is set to minikube.\n\n\nTo allow Meshery to auto detect your config file, Run :\n\n \n kubectl config view --minify --flatten &gt; config_minikube.yaml\n \n\n\n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}




					,

					"guides-multiple-adapters": {
						"id": "guides-multiple-adapters",
						"title": "Using Multiple Adapters",
						"categories": "",
						"url": " /guides/multiple-adapters",
						"content": "Advanced Configuration\n\nMeshery is capable of running zero or more service mesh adapters. Without any service mesh adapters, some but not all of Meshery’s features will continue to functio					n				 		(				e		.				g. perfo					rmance testing of workloads not running on a service mesh).\n\nModifying the default adapter deployment configuration\nThe number of adapters, type of adapters, where they are deployed, how they are named and what port they are exposed on are all configurable deployment options. To modify the default configuration, find ~/.meshery/meshery.yaml on your system. ~/.meshery/meshery.yaml is a Docker Compose file.\n\nConfiguration: Running fewer Meshery adapters\nIn the ~/.meshery/meshery.yaml configuration file, remove the entry(ies) of the adapter(s) you are removing from your deployment.\n\nConfiguration: Running more than one instance of the same Meshery adapter\n\nThe default configuration of a Meshery deployment includes one instance of each of the Meshery adapters (that have reached a stable version status). You may choose to run multiple instances of the same type of Meshery adapter; e.g. two instances of the meshery-istio adapter. To do so					,				 		m				odify ~/					.meshery/meshery.yaml to include multiple copies of the given adapter.\n\nDemo of Meshery managing service mesh deployments across multiple clusters:\n\n\n\nSee on YouTube: Cloud Native Austin Virtual Meetup: April 2020"
					}






					,

					"concepts-architecture-operator": {
						"id": "concepts-architecture-operator",
						"title": "Operator",
						"categories": "",
						"url": " /concepts/architecture/operator",
						"content": "Meshery operator is a kubernetes controller manager which is conceptually known as a kubernetes operator. This manages the lifecycle of every meshery component that is deployed or running inside the cluster.\n\nList of Controllers that is managed by the operator\n\nBroker Controller\n\nMeshery broker is one of the core components of the meshery architecture. This controller manages the lifecycle of broker that meshery uses for data streaming across the cluster and the outside world.\n\nSee the “Meshery Broker” for more information.\n\nMeshSync Controller\n\nMeshSync Controller manages the lifecycle of MeshSync that is deployed for resource synchronization for the cluster.\n\nSee the “MeshSync” for more information.\n\nOperator FAQs"
					}




					,

					"es-overview": {
						"id": "es-overview",
						"title": "Descripción General",
						"categories": "",
						"url": " /es/overview",
						"content": "Introducción a Meshery\nEl plano de gestión de service mesh adopta, opera y desarrolla sobre diferentes service meshes.\nMeshery facilita el aprendizaje sobre la funcionalidad y el desempeño de los service mesh e incorpora la recopilación y visualización de métricas de las aplicaciones que se ejecutan dentro de un service mesh o multiples service meshes.\nMeshery proporciona estas funcionalidades de alto nivel:\n\n\n  Gestión del desempeño de service meshes.\n  Gestión de configuración de service meshes.\n    \n      Mejores prácticas de configuración.\n    \n  \n  Gestión del ciclo de vida de service meshes.\n  Interoperabilidad y asociación de service meshes.\n\n\n\n\nPresentado en Service Mesh Day 2019\n\n¿Qué desafíos resuelve Meshery?\nGestión de service mesh - uno o múltiples service meshes.\n\nSiempre que haya que responder a estas preguntas sobre el desempeño, son subjetivas a la carga de trabajo y la infraestructura específicas utilizadas para la medición. Ante este desafío, el proyecto Envoy, por ejemplo, se niega a publicar datos de desempeño porque tales pruebas pueden ser:\n\n  Confusas\n  Malinterpretadas.\n\n\nMás allá de la necesidad del desempeño y el alto consumo de datos bajo una permutación de diferentes cargas de trabajo (aplicaciones), los tipos y tamaños de los recursos de infraestructura, la necesidad de un proyecto multifuncional, y las comparaciones entre semejantes, son anhelados para facilitar una comparación de las diferencias de comportamiento entre service meshes y la selección de su uso. Los proyectos individuales son reservados en publicar resultados de pruebas de otras competencias de service mesh. Es necesario un análisis independiente, imparcial y creíble.\n\nLa intención de Meshery es ser un proveedor y una utilidad neutra de proyectos para evaluar de manera uniforme el desempeño de los service mesh. Entre proyectos de service mesh y servicios de proxy (y sorprendentemente, dentro de un mismo proyecto), existen diferentes números de herramientas y resultados. Meshery permite elegir un conjunto eficiente de herramientas para su ecosistema al proporcionar evaluaciones y métricas de desempeño.\n\n\n  Al aprovechar Meshery, podrás lograr una comparación de desempeño de los service meshes semejantes.\n  Realiza un seguimiento del desempeño de un service mesh de un release a otro.\n  Comprende las diferencias de comportamiento entre los service meshes.\n  Realiza un seguimiento del desempeño de su aplicación de una versión a otra.\n\n\nMeshery es para Entusiastas y Operadores\nSea la opción para implementar desde el Día 0 o el mantenimiento del Día 2 de despliegue, Meshery tiene capacidades útiles para cualquier circunstancia. La audicencia dirigida para un proyecto con Meshery sería cualquier tipo de operador  que aproveche el service mesh en su ecosistema; incluyendo desarrolladores, ingenieros de devops, quienes toman decisiones, arquitectos, y organizaciones que dependen de una plataforma de microservicios..\n\nMeshery es para la gestión de desempeño: pruebas y comparaciones de mercado\nMeshery ayuda a los usuarios a sopesar el valor de la implementación de un service mesh con la alta carga involucrada a la ejecución del mismo. Meshery proporciona un análisis estadístico de la latencia de las solicitudes y el rendimiento que se observan a través de las permutaciones de su carga de trabajo, infraestructura y la configuración del service mesh.\nAdemás de solicitar la latencia y el rendimiento, Meshery también rastrea la sobrecarga de memoria y el CPU en los nodos del clúster. Mide el plano de datos y el plano de control con diferentes conjuntos de cargas de trabajo e infraestructuras.\n\n\nEstablece un desempeño de marca y rastrea el desempeño como estándar a medida que cambia en el tiempo.\n\nMeshery es para cualquier service mesh\nLa diversidad de infraestructuras es una realidad para cualquier organización. Ya sea que se esté ejecutando un solo service mesh o varios tipos de service meshes, en Meshery encontrarás que soporta una diversidad de infraestructura (o bien, la falta de una).\n\n\n  Adaptadores disponibles de service mesh - Adaptadores de service mesh soportados por Mashery.\n\n\n\n  \n    \n      Plataforma                                            \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for Consul\n      stable\n    \n    \n      Meshery Adapter for Istio\n      stable\n    \n    \n      Meshery Adapter for Linkerd\n      stable\n    \n    \n      Meshery Adapter for Network Service Mesh\n      stable\n    \n    \n      Meshery Adapter for Octarine\n      stable\n    \n    \n      Meshery Adapter for Open Service Mesh\n      stable\n    \n  \n\n\n\n\n  Adaptadores en progreso de service mesh - Adaptadores de service mesh sometidos por la comunidad y en desarrollo\n\n\n\n  \n    \n      Plataforma                                            \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for Citrix Service Mesh\n      beta\n    \n    \n      Meshery Adapter for Kuma\n      beta\n    \n    \n      Meshery Adapter for NGINX Service Mesh\n      beta\n    \n    \n      Meshery Adapter for Traefik Mesh\n      beta\n    \n  \n\n\n\n\n  Adaptadores de service mesh que buscamos apoyo - Adaptadores de service mesh que se encuentran en búsqueda de ayuda de la comunidad.\n\n\n\n  \n    \n      Plataforma                                                \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for App Mesh\n      alpha\n    \n    \n      Meshery Adapter for Tanzu Service Mesh\n      alpha\n    \n  \n\n\nComunidad\nEste proyecto es hecho por la comunidad y toda colaboración es bienvenida! Fork here on Github\n\n\n  Únete a la reunión semanal de la comunidad Viernes de 10am a 11am Horario Central.\n    \n      Observa las grabaciones de la comunidad y suscríbete al calendario de la comunidad.\n    \n  \n  Ingresa al drive de la comunidad (solicita acceso).\n\n\nFAQ\n\n¿Por qué usar Meshery?\n\n  Porque es un proyecto de código abierto, proveedor neutral de proyectos que facilita las pruebas en meshes.\n  Porque fortio no está empaquetado en una utilidad de prueba de mesh, sino que es solo un generador de carga en sí mismo.\n  Debido a que regpatrol es de código cerrado, el código binario no es liberado, embebido para un mesh y es producido por un proveedor de ese mesh.\n\n\n¿Por qué crear Meshery y no usar otra herramienta de marca?\nMeshery está diseñado específicamente para facilitar la evaluación comparativa de los service mesh y sus cargas de trabajo, al contrario de otras herramientas. Sin embargo también existen otras herramientas que se utilizan para la evaluación comparativa de los service meshes, como regpatrol. Regpatrol es utilizado por IBM, el cual no es código abierto ni está 					d				i		s				ponible 					en su forma binaria para su uso, posee las siguientes diferencias con Meshery:\n\n  Telemetría: regpatrol obtiene la telemetría del adaptador Mixer Prometheus y utiliza el agente de nodo propietario de IBM.\n  Meshery se obtiene del adaptador Mixer Prometheus y utiliza el exportador de nodos Prometheus.\n  Tipo de tráfico: regpatrol usa JMeter, que puede analizar las respuestas y realizar pruebas funcionales.\n  Meshery está usando fortio, que es solo para pruebas de generación y rendimiento.\n\n\nRecursos\n\nPresentaciones de Meshery\n\n\n  O’Reilly OSCON 2020\n  O’Reilly Infrastructure &amp; Ops 2020\n  InnoTech Dallas 2020\n  KubeCon EU 2020\n  DockerCon 2020 (deck, video)\n  Open Source 101 at Home\n  Docker Captains Roundtable 2020\n  Cloud Native Austin 2020\n  NSMCon 2019 talk (video, deck)\n  Service Mesh Day 2019\n  DockerCon 2019 Open Source Summit\n  KubeCon EU 2019 (video, deck)\n  KubeCon EU 2019 Istio Founders Meetup\n  Cloud Native Rejekts EU 2019\n  Container World 2019\n  Solving the Service Mesh Adopter’s Dilemma (deck, event,video)\n\n\nOtros Recursos\n\n  Comparación de Service Meshes\n  Herramientas de Service meshes\n  Libros sobre Service Mesh\n  Workshops sobre Service Mesh"
					}




					,

					"overview": {
						"id": "overview",
						"title": "Overview",
						"categories": "",
						"url": " /overview",
						"content": "As the service mesh management plane, Meshery enables the adoption, operation, and management of any service mesh and their workloads. Meshery’s powerful performance management functionality is accomplished through implementation of Service Mesh Performance (SMP). Meshery’s multi-mesh management functionality leverages Service Mesh Interface (SMI). Meshery enables operators to deploy WebAssembly filters to Envoy-based data planes. Meshery facilitates learning about functionality and performance of service meshes and incorporates the collection and display of metrics from applications running on or across service meshes.\n\nMeshery’s Functionality\n\nMeshery features can be categorized by:\n\n\n  Service Mesh Performance Management\n    \n      Workload and service mesh benchmarking\n      Prometheus and Grafana Integration\n    \n  \n  Service Mesh Configuration Management\n    \n      Configuration best practices\n    \n  \n  Service Mesh Lifecycle Management\n    \n      Service mesh provisioning and workload onboarding\n      Meshery Operator and MeshSync\n    \n  \n  Data Plane Intelligence\n    \n      WebAssembly filters for Envoy\n    \n  \n  Service Mesh Interoperability and Federation\n    \n      Manage multiple service meshes concurrently\n      Connect to multiple clusters independently\n    \n  \n\n\nMeshery is for Developers, Operators, and Product Owners\n\nWhether making a Day 0 adoption choice or maintaining a Day 2 deployment, Meshery has useful capabilities in either circumstance. Targeted audience for Meshery project would be any technology operators that leverage service mesh in their ecosystem; this includes developers, devops engineers, decision makers, architects, and organizations that rely on microservices platform.\n\nService mesh management - one or multiple service meshes.**\nMeshery is for performance management: testing and benchmarking\nMeshery helps users weigh the value of their service mesh deployment against the overhead incurred in running a service mesh. Meshery provides statistical analysis of the request latency and throughput seen across various permutations of your workload, infrastructure and service mesh configuration.\nIn addition to request latency and throughput, Meshery also tracks memory and CPU overhead in of the nodes in your cluster. Measure your data plane and control plane against different sets of workloads and infrastructures.\n\nAnytime performance questions are to be answered, they are subjective to the specific workload and infrastructure used for measurement. Given this challenge, the Envoy project, for example, refuses to publish performance data because such tests can be:\n\n  Involved\n  Misinterpreted\n\n\nBeyond the need for performance and overhead data under a permutation of different workloads (applications) and types and sizes of infrastructure resources, the need for cross-project, apple-to-apple comparisons are also desired in order to facilitate a comparison of behavioral differences between service meshes and selection of their use. Individual projects shy from publishing test results of other, competing service meshes. An independent, unbiased, credible analysis is needed.\n\nMeshery is intended to be a vendor and project-neutral utility for uniformly benchmarking the performance of service meshes. Between service mesh and proxy projects (and surprisingly, within a single project), a number of different tools and results exist. Meshery allows you to pick an efficient set of tools for your ecosystem by providing performance evaluation and metrics.\n\n\n  By leveraging Meshery you could achieve apples-to-apples performance comparison of service meshes\n  Track your service mesh performance from release to release.\n  Understand behavioral differences between service meshes.\n  Track your application performance from version to version.\n\n\n\nEstablish a performance benchmark and track performance against this baseline as your environment changes over time.\n\nMeshery is for any service mesh\n\nInfrastructure diversity is a reality for any enterprise. Whether you’re running a single service mesh or multiple types of service meshes, you’ll find that Meshery supports your infrastructure diversity (or lack thereof).\nSupported Service Me					s				h		e				s\n\nSta					ble\n\n\n  \n    \n      Platform                                              \n      Status\n    \n  \n  \n    \n       Meshery Adapter for Consul\n      stable\n    \n    \n       Meshery Adapter for Istio\n      stable\n    \n    \n       Meshery Adapter for Linkerd\n      stable\n    \n    \n       Meshery Adapter for Network Service Mesh\n      stable\n    \n    \n       Meshery Adapter for Octarine\n      stable\n    \n    \n       Meshery Adapter for Open Service Mesh\n      stable\n    \n  \n\n\nBeta\n\n\n  \n    \n      Platform                                              \n      Status\n    \n  \n  \n    \n        Meshery Adapter for Citrix Service Mesh\n      beta\n    \n    \n        Meshery Adapter for Kuma\n      beta\n    \n    \n        Meshery Adapter for NGINX Service Mesh\n      beta\n    \n    \n        Meshery Adapter for Traefik Mesh\n      beta\n    \n  \n\n\nAlpha - Service mesh adapters adapters for which we are seeking community-contributed support.\n\n\n  \n    \n      Platform                                                  \n      Status\n    \n  \n  \n    \n        Meshery Adapter for App Mesh\n      alpha\n    \n    \n        Meshery Adapter for Tanzu Service Mesh\n      alpha"
					}




					,

					"functionality-performance-management": {
						"id": "functionality-performance-management",
						"title": "Performance Management",
						"categories": "",
						"url": " /functionality/performance-management",
						"content": "Key to the efficient operation of any service mesh is the measurement and management of it’s performance.\n\nLoad Generators\n\nMeshery provides users with a choice about the kind of load generator they prefer to use for a given performance test. Users may set their configure based on their own preference of load generator different from that of the default load generator.\n\nMeshery supports the following load generators and is extendible to support others:\n\n\n  fortio\n  wrk2\n  Nighthawk\n\n\nfortio\n\nFortio is a fast, small (3Mb docker image, minimal dependencies),\nreusable, embeddable go library as well as a command line tool and server process,\nthe server includes a simple web UI and graphical representation of the results\n(both a single latency graph and a multiple results comparative min, max, avg, qps and percentiles graphs).\n\nwrk2\n\nIt is a modern HTTP benchmarking tool capable of generating significant load when run on a single multi-core CPU. It combines a multithreaded design with scalable event notification systems such as epoll and kqueue.\n\nNighthawk\n\nNightHawk is an L7 (HTTP/HTTPS/HTTP2) performance characterization tool. It currently offers:\n\n\n  A load testing client which supports HTTP/1.1 and HTTP/2 over HTTP and HTTPS. (HTTPS certificates are not yet validated).\n  A simple test server which is capable of generating dynamic response sizes, as well as inject delays.\n  A binary to transform nighthawk output to well-known formats, allowing integration with other systems and dashboards.\n\n\nConfiguring performance testing settings\n\nMeshery provides a highly configurable set of load profiles with various, tuneable facets, including support for generating TCP, gRPC, and HTTP load with optional configuration of the performance test’s:\n\n\n  Duration\n  Concurrent Threads\n  Concurrent Generators\n  Load Generator Type\n  Custom HTTP Headers\n\n\nSee Service Mesh Performance (SMP) for a full description of the different types of performance tests that Meshery provides.\n\nUsing Performance Test Profiles\n\nAs Meshery user you can customize and save your load test configuration in the form of a Performance Test Profile. Using Performance Test Profiles, you can return to Meshery to run the same set of customized tests again and again, tracking variations in performance overtime.\n\nComparing Test Results and Service Meshes\n\nMeshery users can easily compare the difference in request performance (latency and throughput) between independent performance tests. Statistical analysis is run upon finalization of every performance test and presented in the form of a histogram with latency buckets.\n\nKubernetes Cluster and Service Mesh Metrics\n\nMeshery provides performance test results alongside environment metrics, including service mesh control and data plane metrics as well as cluster node resource metrics, so that operators may ea					s				i		l				y unders					tand the overhead of their service mesh’s control plane and data plane in context of the overhead incurred on nodes within the cluster.\n\nGrafana and Meshery\n\nConnect Meshery to your existing Grafana instance. Meshery will auto-import the boards of your choosing:\n\n\n    \n\n\nConnecting to Grafana\n\nIf you have an API key configured to restrict access to your Grafana boards, you will need to enter the API key when establishing Meshery’s connection to Grafana. You may also set up a Grafana board and then set up an API key:\n\n\n\n\n  Import Grafana boards\n    \n      Import existing Grafana boards via API\n      Import custom Grafana board via yaml\n    \n  \n  Configure graph panel preferences\n\n\nPrometheus and Meshery\n\nMeshery allows users to connect to one or more Prometheus instances in order to gather telemetric data (in the form of metrics). These metrics may pertain to service meshes, Kubernetes, applications on the mesh or any other metric that Prometheus has collected.\n\nOnce you have connected Meshery to your Prometheus deployment(s), you may perform ad-hoc connectivity tests to verify communication between Meshery and Prometheus.\n\nSuggested Reading\n\n\n  Guide: Interpreting Performance Test Results"
					}




					,

					"es-functionality-performance-management": {
						"id": "es-functionality-performance-management",
						"title": "Performance Management",
						"categories": "",
						"url": " /es/functionality/performance-management",
						"content": "Gestión del rendimiento\nLa clave del funcionamiento eficiente de cualquier service mesh es la medición y gestión de su rendimiento.\n\nGeneradores de carga\nMeshery proporciona a los usuarios la opción de elegir qué generador de carga prefieren usar para una prueba de rendimiento determinada. Los usuarios pueden establecer su configuración basada en su propia preferencia de generador de carga diferente al generador de carga por defecto.\n\nMeshery soporta los siguientes generadores de carga y es extensible para soportar otros:\n\n\n  Fortio\n  wrk2\n  NightHawk\n\n\nFortio\n\nFortio es un rápida, pequeña (imagen de Docker de 3Mb, dependencias mínimas), reusable, biblioteca de go integrable, así como también una herramienta de línea de comandos y un proceso de servidor. El servidor incluye una Interfaz de Usuario web simple y una representación gráfica de los resultados (un gráfico de latencia único y gráficos comparativos de min, max, avg, qps y percentiles gráficos).\n\nwrk2\n\nEs una herramienta moderna de evaluación comparativa HTTP capaz de generar una carga significativa cuando se ejecuta en un solo CPU multi-núcleo. Combina un diseño multiproceso con sistemas de notificación de eventos escalables como lo son epoll y kqueue.\n\nNightHawk\n\nNightHawk es una herramienta de caracterización L7 (HTTP/HTTPS/HTTP2). Actualmente ofrece:\n\n\n  Un cliente de prueba de carga que soporta HTTP/1.1 y HTTP/2 sobre HTTP y HTTPS (los certificados HTTPS aún no se validan).\n  Un servidor de prueba simple capaz de generar tamaños de respuestas dinámicas, así como también inyectar retrasos.\n  Un binario para tranformar la salida de NightHawk a formatos conocidos, permitiendo la integración con otros sistemas y paneles.\n\n\nNode y métricas del service mesh\n\nMeshery proporciona los resultados de pruebas de rendimiento junto a las métricas del entorno, incluyendo el control del service mesh y las métricas del plano de datos. También incluye las métricas de los recursos del nodo del clúster, para que los operadores puedan comprender fácilmente la sobrecarga del plano de control y el plano de datos de su s					e				r		v				ice mesh					 en el contexto de la sobrecarga incurrida en los nodos dentro del clúster.\n\nGrafana y Meshery\n\nConecte Meshery a su instancia de Grafana existente y Meshery importará los tableros que elija.\n\n\n    \n\n\nConexión a Grafana\nSi tiene una clave de API configurada para restringir el acceso a sus tableros de Grafana, deberá ingresar la clave de API cuando establezca la conexión de Meshery con Grafana.\n\n\n  Importación de tableros de Grafana\n    \n      Importación de tablero existente de Grafana a través de API\n      Importación de tablero personalizado de Grafana a través de yaml\n    \n  \n  Configuración de las preferencias del panel de gráficos\n\n\nPrometheus y Meshery\nMeshery permite a los usuarios conectarse a una o más instancias de Prometheus para recopilar datos telemétricos (en forma de métricas). Estas métricas pueden pertenecer al service mesh, Kubernetes, aplicaciones en la malla o realmente… cualquier métrica que Prometheus haya recolectado.\n\nUna vez que haya conectado Meshery a su (s) despliegue (es) de Prometheus, puede realizar pruebas de conectividad ad-hoc para verificar la comunicación entre Meshery y Prometheus.\n\nLectura sugerida\n\n\n  Guía: Interpre					t				a		c				ión de l					os resultados de la prueba de rendimiento"
					}




					,

					"es-installation-platforms": {
						"id": "es-installation-platforms",
						"title": "Supported Platforms",
						"categories": "",
						"url": " /es/installation/platforms",
						"content": "Empezando a trabajar con otras Plataformas\n\nLa Tabla a continuación provee instrucciones de instalación para cada plataforma con la que Meshery es compatible:\n\n\n  \n    \n      Plataforma\n      Versión\n    \n  \n  \n    \n       Docker\n       \n    \n    \n           Docker Engine\n      19.x y superior\n    \n    \n       Kubernetes\n      1.12.x y superior\n    \n    \n          AKS\n       \n    \n    \n          Docker Desktop\n      2.0.x y superior\n    \n    \n          EKS\n      1.12.x y superior\n    \n    \n          GKE\n      1.14.x y superior\n    \n    \n          Helm\n       \n    \n    \n          KinD\n      v0.7.0\n    \n    \n          Minikube\n      1.2.x y superior\n    \n    \n          OpenShift\n      En Desarrollo\n    \n    \n       Mac\n       \n    \n    \n          Mac - Homebrew\n       \n    \n    \n          Scoop\n       \n    \n    \n          Windows\n      Build 18917 y superior\n    \n    \n       Raspberry Pi\n      En Desarrollo"
					}




					,

					"installation-platforms": {
						"id": "installation-platforms",
						"title": "Supported Platforms",
						"categories": "",
						"url": " /installation/platforms",
						"content": "Supported Platforms\nMeshery deploys as a set of Docker containers, which can be deployed to either a Docker host or Kubernetes cluster. See the complete list of supported platforms in the table below. With service meshes having sprung to life in the context of Kubernetes, so too, 					c				a		n				 Meshery					’s deployment models be characterized in the context of Kubernetes. A given deployment of Meshery can be described as either an in-cluster or an out-of-cluster deployment. Meshery deploys as a stand-alone, management plane on a Docker host (out-of-cluster) or as a management plane in a Kubernetes cluster (in-cluster).\n\nPlatform Compatibility Matrix\nFind installation instructions for the Supported Platforms in the compatibility table.\n\n\n  \n    \n      Platform\n      Version\n    \n  \n  \n    \n       Docker\n       \n    \n    \n           Docker Engine\n      19.x and above\n    \n    \n       Kubernetes\n      1.12.x and above\n    \n    \n          AKS\n       \n    \n    \n          Docker Desktop\n      2.0.x and above\n    \n    \n          EKS\n      1.12.x and above\n    \n    \n          GKE\n      1.14.x and above\n    \n    \n          Helm\n       \n    \n    \n          KinD\n      v0.7.0\n    \n    \n          Minikube\n      1.2.x and above\n    \n    \n          OpenShift\n      In Progress\n    \n    \n       Mac\n       \n    \n    \n          Mac - Homebrew\n      macOS 10.12 - 10.15, 11\n    \n    \n          Scoop\n       \n    \n    \n          Windows\n      Build 18917 and above\n    \n    \n       Raspberry Pi\n      In Progress"
					}




					,

					"extensibility-providers": {
						"id": "extensibility-providers",
						"title": "Extensibility: Providers",
						"categories": "",
						"url": " /extensibility/providers",
						"content": "Meshery offers Providers as a point of extensibility. With a built-in Local Provider (named “None”), Meshery Remote Providers are designed to be pluggable. Remote Providers offer points of extension to users / integrators to deliver enhanced functionality, using Meshery as a platform. A specific type of provider can be enforced in a Meshery instance by passing it with the env variable ENFORCED_PROVIDER.\n\n\n  Extensibility points offer clean separation of open vs closed source capabilities.\n    \n      Meshmap is an example of a feature to be delivered via Remote Provider.\n    \n  \n  Remote Providers should be able to offer custom RBAC, custom UI components, and custom backend components\n    \n      Dynamically loadable frameworks need to be identified or created to serve each of these purposes.\n    \n  \n\n\nDesign Principles: Meshery Remote Provider Framework\n\nMeshery’s Remote Provider extensbility framework is designed to enable:\n\n\n  Pluggable UI Functionality:\n    \n      Out-of-tree custom UI components with seamless user experience.\n      A system of remote retrieval of extension packages (ReactJS components and Golang binaries).\n    \n  \n  Pluggable Backend Functionality:\n    \n      Remote Providers have any number of capabilities unbeknownst to Meshery.\n    \n  \n  Pluggable AuthZ\n    \n      Design an extensible role based access control system such that Remote Providers can determine their own set of controls. Remote Providers to return JWTs with custom roles, permission keys and permission keychains.\n    \n  \n\n\n\n\nWhat functionality do Providers perform?\n\nWhat a given Remote Provider offers might vary broadly between providers. Meshery offers extension points that Remote Providers are able to use to inject different functionality - functionality specific to that provider.\n\n\n  Authentication and Authorization\n    \n      Examples: session management, two factor authentication, LDAP integration.\n    \n  \n  Long-Term Persistence\n    \n      Examples: Storage and retrieval of performance test results.\n      Examples: Storage and retrieval of user preferences.\n    \n  \n  Enhanced Visualization\n    \n      Examples: Creation of a visual service mesh topology.\n      Examples: Different charts (metrics), debug (log viewer), distributed trace explorers.\n    \n  \n  Reporting\n    \n      Examples: Using Meshery’s GraphQL server to compose new dashboards.\n    \n  \n\n\nTypes of providers\n\nTwo types of providers are defined in Meshery: local and remote. The Local provider is built-into Meshery. Remote providers are may be implemented by anyone or organization that wishes to integrate with Meshery. Any number of Remote providers may be available in your Meshery deployment.\n\nRemote Providers\n\nUse of a Remote Provider, puts Meshery into multi-user mode and requires user authentication. Use a Remote provider when your use of Meshery is ongoing or used in a team environment (used by multiple people).\n\nName: “Meshery” (default)\n\n\n  Enforces user authentication.\n  Long-term term persistence of test results.\n  Save environment setup.\n  Retrieve performance test results.\n  Retrieve conformance test results.\n  Free to use.\n\n\nLocal Provider\n\nUse of the Local Provider, “None”, puts Meshery into single-user mode and does not require authentication. Use the Local provider when your use of Meshery is intended to be shortlived.\n\nName: “None”\n\n\n  No user authentication.\n  Container-local storage of test results. Ephemeral.\n  Environment setup not saved.\n  No performance test result history.\n  No conformance test result history.\n  Free to use.\n\n\nBuilding a Provider\n\nMeshery interfaces with Providers through a Go interface. The Provider implementations have to be placed in the code and compiled together today. A Provider instance will have to be injected into Meshery when the program starts.\n\nMeshery keeps the implementation of Remote Providers separate so that they are brought in through a separate process and injected into Meshery at runtime (OR) change the way the code works to make the Providers invoke Meshery.\n\nRemote Provider Extension Points\n\nInterwoven into Meshery’s web-based, user interface are a variety of extension points. Each extension point is carefully carved out to afford a seamless user experience. Each extension point is identified by a name and type. The following Meshery UI extension points are available:\n\n\n  Name: navigator \n Type: Menu Items\nDescription: This is supposed to be a full page extension which will get a dedicated endpoint in the meshery UI. And will be listed in the meshery UI’s navigator/sidebar. Menu items may refer to full page extensions.\n\n\nName: user_prefs \nType: Single Component\nDescription: This is supposed to be remote react components which will get placed in a pre-existing page and will not have a dedicated endpoint. As of now, the only place where this extension can be loaded is the “User Preference” section under meshery settings.\n\nName: /extension/\n**Type:** Full Page\nDescription:\n\nThe Provider package is unzipped into Meshery server filesystem under /app/provider-pkg/&lt;package-name&gt;.\n\nRemote Providers must fulfill the following endpoints:\n\n\n  /login - return valid token\n  /logout - invalidating token\n  /capabilities - return capabilities.json\n\n\nUI Extension Points\n\nAll UI extensions will be hosted under the endpoint &lt;mesheryserver:port/provider&gt;\n\nUserPrefs\n\nThe UserPrefs extension point expects and loads a component to be displayed into /userpreferences page.\n\nNavigator\n\nThe Navigator extension point loads a set of menu items to be displayed in the menu bar on the left hand side of the Meshery UI.\n\nCapabilities Endpoint Example\n\nMeshery Seerver will proxy all requests to remote provider endpoints. Endpoints are dynamically determined and identified in the “capabilities” section of the /capabilities endpoint. Providers as an object have the following attributes (this must be returned as a response to /capabilities endpoint):\n\n{\n  \"provider_type\": \"remote\",\n  \"package_version\": \"v0.1.0\",\n  \"package_url\": \"https://layer5labs.github.io/meshery-extensions-packages/provider.tar.gz\",\n  \"provider_name\": \"Meshery\",\n  \"provider_description\": [\n    \"Persistent sessions\",\n    \"Save environment setup\",\n    \"Retrieve performance test results\",\n    \"Free use\"\n  ],\n  \"extensions\": {\n    \"navigator\": [\n      {\n        \"title\": \"MeshMap\",\n        \"href\": {\n          \"uri\": \"/meshmap\",\n          \"external\": false\n        },\n        \"component\": \"provider/navigator/meshmap/index.js\",\n        \"icon\": \"provider/navigator/img/meshmap-icon.svg\",\n        \"link:\": true,\n        \"show\": true,\n        \"children\": [\n          {\n            \"title\": \"View: Single Mesh\",\n            \"href\": {\n              \"uri\": \"/meshmap/mesh/all\",\n              \"external\": false\n            },\n            \"component\": \"navigator/meshmap/index.js\",\n            \"icon\": \"navigator/img/singlemesh-icon.svg\",\n            \"link\": false,\n            \"show\": true\n          }\n        ]\n      }\n    ],\n    \"user_prefs\": [\n      {\n        \"component\": \"userprefs/meshmap-preferences.js\"\n      }\n    ]\n  },\n  \"capabilities\": [\n    { \"feature\": \"sync-prefs\", \"endpoint\": \"/user/preferences\" },\n    { \"feature\": \"persist-results\", \"endpoint\": \"/results\" },\n    { \"feature\": \"persist-result\", \"endpoint\": \"/result\" },\n    { \"feature\": \"persist-smi-results\", \"endpoint\": \"/smi/results\" },\n    { \"feature\": \"persist-metrics\", \"endpoint\": \"/result/metrics\" },\n    { \"feature\": \"persist-smp-test-profile\", \"endpoint\": \"/user/test-config\" }\n  ]\n}\n\n\n\nMeshery enables you as a service mesh owner to customize your service mesh deployment.\n\nManaging your Remote Provider Extension Code\n\nRemote Provider extensions are kept					 				o		u				t-of-tre					e from Meshery (server and UI). You might need to build your extensions under the same environment and set of dependencies as Meshery. The Meshery framework of extensibility has been designed such that in-tree extensions can be safely avoided while still providing a robust platform from which to extend Meshery’s functionality. Often, herein lies the delineation of open vs. closed functionality within Meshery. Remote Providers can bring (plugin) what functionality that they want behind this extensible interface (more about Meshery extensibility), at least that is up to the point that Meshery has provided a way to plug that feature in.\n\nOffering out-of-tree support for Meshery extensions means that:\n\n\n  source code to your Meshery extensions are not required to be open source,\n  liability to Meshery’s stability is significantly reduced, avoiding potential bugs in extended components.\n\n\nThrough clearly defined extension points, Meshery extensions may be offered as closed source capabilities that plug into open source Meshery code. To facilitate integration of your Meshery extensions, you might automate the building and releasing of your separate, but interdependent code repositories. You will be responsible for sustaining both your ReactJS and Golang-based extensions."
					}




					,

					"project-releases": {
						"id": "project-releases",
						"title": "Releases",
						"categories": "",
						"url": " /project/releases",
						"content": "Version  Date \n\n\n    \n    \n         v0.4.20 \n         December 11, 2020 \n    \n\n    \n    \n         v0.4.22 \n         November 12, 2020 \n    \n\n    \n    \n         v0.4.21 \n         November 12, 2020 \n    \n\n    \n    \n         v0.4.19 \n         November 10, 2020 \n    \n\n    \n    \n         v0.4.13 \n         November 10, 2020 \n    \n\n    \n    \n         v0.4.18 \n         November 08, 2020 \n    \n\n    \n    \n         v0.4.17 \n         October 29, 2020 \n    \n\n    \n    \n         v0.4.16 \n         October 28, 2020 \n    \n\n    \n    \n         v0.4.15 \n         October 23, 2020 \n    \n\n    \n    \n         v0.4.14 \n         October 20, 2020 \n    \n\n    \n    \n         v0.4.12 \n         October 08, 2020 \n    \n\n    \n    \n         v0.4.11 \n         October 05, 2020 \n    \n\n    \n    \n         v0.4.11 \n         October 03, 2020 \n    \n\n    \n    \n         v0.4.9 \n         September 30, 2020 \n    \n\n    \n    \n         v0.4.8 \n         September 28, 2020 \n    \n\n    \n    \n         v0.4.7 \n         September 25, 2020 \n    \n\n    \n    \n         v0.4.6 \n         September 03, 2020 \n    \n\n    \n    \n         v0.4.5 \n         September 02, 2020 \n    \n\n    \n    \n         v0.4.4 \n         August 27, 2020 \n    \n\n    \n    \n         v0.4.3 \n         August 22, 2020 \n    \n\n    \n    \n         v0.4.2 \n         August 17, 2020 \n    \n\n    \n    \n         v0.04.1 \n         August 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.4 \n         July 09, 2020 \n    \n\n    \n    \n         v0.4.0-beta.3 \n         July 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.2 \n         July 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.1 \n         July 06, 2020 \n    \n\n    \n    \n         v0.3.19 \n         July 05, 2020 \n    \n\n    \n    \n         v0.3.18 \n         July 04, 2020 \n    \n\n    \n    \n         v0.3.16 \n         June 22, 2020 \n    \n\n    \n    \n         v0.3.15 \n         May 04, 2020 \n    \n\n    \n    \n         v0.3.14 \n         April 24, 2020 \n    \n\n    \n    \n         v0.3.13 \n         April 16, 2020 \n    \n\n    \n    \n         v0.3.12 \n         April 10, 2020 \n    \n\n    \n    \n         v0.3.11 \n         March 11, 2020 \n    \n\n    \n    \n         v0.3.10 \n         March 09, 2020 \n    \n\n    \n    \n         v0.3.9 \n         February 02, 2020 \n    \n\n    \n    \n         v0.3.8 \n         January 17, 2020 \n    \n\n    \n    \n         v0.3.7 \n         January 15, 2020 \n    \n\n    \n    \n         v0.3.6 \n         January 14, 2020 \n    \n\n    \n    \n         v0.3.5 \n         January 13, 2020 \n    \n\n    \n    \n         v0.3.17 \n         January 07, 2020 \n    \n\n    \n    \n         v0.3.4 \n         December 30, 2019 \n    \n\n    \n    \n         v0.3.3 \n         December 21, 2019 \n    \n\n    \n    \n         v0.3.2 \n         November 30, 2019 \n    \n\n    \n    \n         v0.3.1 \n         November 13, 2019 \n    \n\n    \n    \n         v0					.				2		.				4 \n    					     November 07, 2019 \n    \n\n    \n    \n         v0.2.3 \n         November 05, 2019 \n    \n\n    \n    \n         v0.2.2 \n         October 26, 2019 \n    \n\n    \n    \n         v0.2.1 \n         October 24, 2019 \n    \n\n    \n    \n         v0.2.1 \n         October 23, 2019 \n    \n\n    \n    \n         v0.1.6 \n         October 14, 2019 \n    \n\n    \n    \n         v0.1.5 \n         September 20, 2019 \n    \n\n    \n    \n         v0.1.4 \n         July 27, 2019 \n    \n\n    \n    \n         v0.1.3 \n         July 01, 2019 \n    \n\n    \n    \n         v0.1.2 \n         June 20, 2019 \n    \n\n    \n    \n         v0.1.1 \n         June 12, 2019 \n    \n\n    \n    \n         v0.1.0 \n         May 29, 2019 \n    \n\n    \n    \n         v0.0.9 \n         May 15, 2019 \n    \n\n    \n    \n         v0.0.8 \n         May 01, 2019 \n    \n\n    \n    \n         v0.0.7 \n         April 29, 2019 \n    \n\n    \n    \n         v0.0.6 \n         April 20, 2019 \n    \n\n    \n    \n         v0.0.5 \n         April 12, 2019 \n    \n\n    \n    \n         v0.0.4 \n         April 07, 2019 \n    \n\n    \n    \n         v0.0.3 \n         March 30, 2019 \n    \n\n    \n    \n         v0.0.2 \n         March 20, 2019 \n    \n\n    \n    \n         v0.0.1 \n         March 07, 2019"
					}




					,

					"es-project-releases": {
						"id": "es-project-releases",
						"title": "Lanzamientos",
						"categories": "",
						"url": " /es/project/releases",
						"content": "Lanzamientos de Meshery\n\nv0.4.4\n\nLanzado el 27 de agosto de 2020\n\n¿Qué hay de nuevo?\n\n\n  \n    Características\n\n    \n      Timeout agregado en golang-ci lint\n      Movido a Gorilla/mux para el enrutamiento del servidor\n      Migrado a golangci-lint\n      Interfaz del generador de carga nighthawk inicializada\n    \n  \n  \n    Mantenimiento\n\n    \n      Se actualizó la rama meshmap a la última versión en la rama master\n      Título de la página en negrita\n      Se movió meshery adapter para osm\n    \n  \n  \n    Documentación\n\n    \n      Se agregaron notas RVM adicionales para usuarios de Windows\n      Se agregó captura de pantalla y descripción de SMI\n      Añadida la versión actual de osm\n    \n  \n  \n    Corrección de bugs\n    \n      Detección automática de la configuración de kube\n      Se corrigió la barra social del pie de página\n    \n  \n\n\nv0.4.3\n\nLanzado el 22 de agosto de 2020\n\n¿Qué hay de nuevo?\n\n\n  \n    Características\n\n    \n      Utiliza Open Service Mesh en lugar de osm\n      Menú desplegable de uso del campo de duración + texto en la preferencia de rendimiento\n      Se agregaron “tooltips” para los elementos del menú de navegación en el estado minimizado\n      Botón de calendario comunitario agregado\n    \n  \n  \n    Documentación\n\n    \n      Páginas de documentos arregladas\n      README.md actualizado\n      Se agregó el enlace de la guía de bienvenida y el enlace para los principiantes\n      Se agregó “Open Service Mesh” al menú de navegación en los documentos de Meshery\n    \n  \n  \n    Corrección de bugs\n    \n      smi-conformance: se agregaron dos puntos al principio\n      Se agregó la fila inferior que faltaba\n    \n  \n\n\nv0.4.2\n\nLanzado el 17 de agosto de 2020\n\n¿Qué hay de nuevo?\n\n\n  \n    Características\n\n    \n      Actualizar las operaciones CRUD en la configuración de prueba\n      Corrección de la “snackbar” no deseada en la pestaña de preferencias perf\n      Agregar validación para el protocolo en URL\n      Inicializar el adaptador OSM para Meshery\n      Agregar un nuevo comando “restart” a mesheryctl\n    \n  \n  \n    Mantenimiento\n\n    \n      Reparar el “ci” roto para pruebas de interfaz de usuario\n      Optimizar imágenes\n      Quitar el paso redundante de “docker push”\n    \n  \n  \n    Documentación\n\n    \n      Quitar enlaces rotos de la tabla de plataformas compatibles\n      Quitar ejemplo de salida de “brew upgrade mesheryctl”\n      Crear archivo smi-conformance-capability.md\n      Reparar los enlaces rotos del sitio de documentación\n      Reparar el enlace roto a SMP en release.md\n      Actualizar el adaptador Meshery Kuma a beta\n      Actualizar los documentos del adaptador\n      Agregar logotipos a la carpeta “assets”\n      Agregar Open Service Mesh a la lista\n      Corregir error tipográfico en la descripción del Adaptador App Mesh\n    \n  \n  \n    Corrección de bugs\n    \n      Crear/Quitar/Leer en perfiles de prueba de usuario\n      Corrección para la página de resultados\n      Arreglar el archivo de configuración de releaseDrafter\n    \n  \n\n\nv0.4.1\n\nLanzado el 8 de agosto de 2020\n\n¿Qué hay de nuevo?\n\n\n  Documentación\n    \n      Correcciones de “typos” y errores\n    \n  \n\n\nv0.4.0-beta.4\n\nLanzado el 9 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Corrección de bugs\n    \n      hotfix: No se puede crear la página de configuración de Meshery\n    \n  \n\n\nv0.4.0-beta.3\n\nLanzado el 8 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Corrección de bugs\n    \n      Hotfix del error introducido en la versión v0.4.0-beta.2\n    \n  \n\n\nv0.4.0-beta.2\n\nLanzado el 8 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Meshery\n    \n      Se agregó el archivo kubeconfig inicial.\n    \n  \n  Mesheryctl\n    \n      Se quitó el error fatal debido a que faltaba meshery.yaml.\n    \n  \n  Documentación\n    \n      Logotipo del adaptador Kuma actualizado en Meshery Docs.\n      Se agregaron puertos de red a la tabla de adaptadores.\n      Captura de pantalla de proveedores agregada.\n      Se agregaron todas las plataformas compatibles a la lista.\n      Se agregó Nighthawk como generador de carga.\n      Se arregló el enlace roto en la página de EKS.\n    \n  \n\n\nv0.3.19\n\nLanzado el 7 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se corrigió un error importante por no inicializar la carpeta de la aplicación (~/meshery) y el archivo de configuración de la aplicación (meshery.yaml).\n    \n  \n\n\nv0.4.0-beta.1\n\nLanzado el 5 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Meshery\n    \n      Etiqueta “stable-latest” para el nuevo canal de lanzamiento.\n    \n  \n\n\nv0.3.18\n\nLanzado el 4 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      mesheryctl version ahora obtiene la información de la versión del servidor, incluida la etiqueta de lanzamiento y git sha.\n      meshery perf ahora soporta SPMS como un paquete a través del indicador --file.\n    \n  \n  Meshery\n    \n      Mejora de la extensibilidad: ahora se proporciona una interfaz abstracta, Load Generator Interface, para facilitar la extensión de Meshery para admitir otros generadores de carga, como Nighthawk.\n    \n  \n  Documentos\n    \n      instrucciones de EKS y GKE mejoradas\n    \n  \n\n\nv0.3.17\n\nLanzado el 1 de julio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Meshery\n    \n      Característica: Se estableció un nuevo canal de lanzamiento “stable”.\n      Característica: Experiencia de usuario mejorada para encabezados HTTP de prueba de rendimiento avanzado.\n    \n  \n\n\nv0.3.16\n\nLanzado el 22 de junio de 2020\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Característica: Se agregó mesheryctl system como el nuevo comando para la gestión del ciclo de vida de Meshery.\n        \n          Todos los comandos de gestión del ciclo de vida de Meshery como start, stop, reset, logs, y así, ahora se encuentran en system.\n        \n      \n      Característica: Se agregó mesheryctl system config como un nuevo subcomando para ayudar a configurar Meshery para comunicarse con las instancias levantadas de Kubernetes en GKE, AKS y EKS.\n    \n  \n\n\nv0.3.15\n\nLanzado el 1 de mayo de 2020\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Característica: Se agregó la funcionalidad de mesheryctl perf --file &lt;smp.yaml&gt; para perfiles de prueba de rendimiento con formato SMP.\n      Característica: Cambio de comportamiento mesheryctl perf para usar tokens y admitir JWT.\n    \n  \n\n\nv0.3.14\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Cambio de comportamiento en mesheryctl start para buscar nuevas imágenes del servidor Meshery por defecto.\n    \n  \n\n\nv0.3.13\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      “Point release” para el soporte ARM inicial de mesheryctl.\n    \n  \n\n\nv0.3.12\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      “Scoop Bucket” y “Scoop package” iniciales para mesheryctl.\n    \n  \n\n\nv0.3.11\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Soluciona problemas menores de la experiencia del usuario en el comando mesheryctl perf. Consulta Comandos CLI de Meshery y Documentación como referencia.\n    \n  \n\n\nv0.3.10\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Introduce el comando mesheryctl perf. Consulta Comandos CLI de Meshery y Documentación como referencia.\n    \n  \n\n\nv0.3.9\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se agregó mesheryctl version para proporcionar el número de versión del lado del servidor.\n      Mejora de mesheryctl logs | stop | start para proporcionar la gramática adecuada en situaciones en las que Meshery está detenido o Docker no está presente.\n    \n  \n  Servidor Meshery\n    \n      Se quitó la información superflua más allá de la dirección IP y el puerto en los “endpoints” de Grafana y Prometheus (#612)\n    \n  \n\n\nv0.3.8\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se quitó la salida de línea de comando extraña. En esta versión se mejora la claridad de la interacción CLI con mesheryctl.\n    \n  \n\n\nv0.3.7\n\n¿Qué hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Ahora se admiten pruebas de conectividad ad-hoc para Prometheus. Los usuarios pueden hacer clic en el chip Prometheus y hacer que Meshery verifique su capacidad para conectarse a la instancia de Prometheus configurada.\n    \n  \n\n\nv0.3.6\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Ahora se admiten pruebas de conectividad ad-hoc para Grafana. Los usuarios pueden hacer clic en el chip Grafana y hacer que Meshery verifique su capacidad para conectarse a la instancia de Grafana configurada.\n    \n  \n\n\nv0.3.5\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se quitó init como comando expuesto a los usuarios. La funcionalidad de este comando se usa internamente para mesheryctl start. Un nuevo comando start --check proporcionará la funcionalidad de verificación previa en el lugar de init.\n    \n  \n\n\nv0.3.4\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      mesheryctl version ahora se ha mejorado con la novedad de mostrar el git commit (sha) de la versión mesheryctl.\n    \n  \n\n\nv0.3.3\n\n¿Qué hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Providers: una nueva construcción de proyecto que permite a los usuarios seleccionar el proveedor de autenticación, almacenamiento a largo plazo, etc.\n    \n  \n\n\nv0.3.2\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se agregó mesheryctl version como un nuevo subcomando.\n    \n  \n\n\nv0.3.1\n\n¿Qué hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Soporte para wrk2 como generador de carga alternativo.\n    \n  \n\n\nv0.2.4\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Soporte de Homebrew disponible para mesheryctl.\n    \n  \n  Servidor Meshery\n    \n      Adaptador Meshery para Octarine lanzado como estable.\n    \n  \n  Documentación\n    \n      Guía de inicio rápido revisada para Mac, Linux y Windows.\n      Soporte WSL2 publicado.\n      El script de generación de kubeconfig GKE cambió a --decode.\n    \n  \n\n\nv0.2.3\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Salida mejorada del comando status en Windows.\n    \n  \n  Servidor Meshery\n    \n      Posibilidad de hacer “deploy” de Meshery en Istio.\n      “Adapter Chips”: Mover el número de puerto del adaptador al tooltip.\n    \n  \n\n\nv0.2.2\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Comando update mejorado, sin sobrescribir en la configuración local mientras se ejecuta el comando start.\n    \n  \n  Meshery UI\n    \n      Una nueva vista modal para organizar y mostrar los resultados de rendimiento en formato tabular.\n    \n  \n\n\nv0.2.1\n\n¿Qué hay de nuevo?\n\n\n  Mesheryctl\n    \n      Revisión de la configuración de Kubernetes dentro del clúster y fuera del clúster.\n    \n  \n\n\nv0.2.0\n\n¿Qué hay de nuevo?\n\n\n  Adaptadores Meshery\n    \n      Adaptador introducido para Network Service Mesh.\n    \n  \n  Servidor Meshery\n    \n      Capacidad para ejecutar pruebas de rendimiento de forma asincrónica.\n      Recopila y conserva métricas de nodos.\n    \n  \n\n\nv0.1.6\n\n¿Qué hay de nuevo?\n\n\n  \n    Registro de cambios\n  \n  Nueva interfaz de usuario para administrar la conexión de Meshery al clúster de Kubernetes.\n  Nueva compatibilidad de mesheryctl para Windows para abrir el navegador predeterminado al iniciar.\n  Nueva aplicación de muestra agregada al adaptador istio: aplicación Hipster (aplicación de demostración de microservicios de Google).\n\n\nv0.1.5\n\n¿Qué hay de nuevo?\n\n\n  Registro de cambios\n  \n    Mejoras de UX\n  \n  mesheryctl start ahora espera a que los contenedores de la aplicación Meshery estén activos antes de iniciar el navegador del usuario.\n  mesheryctl stop ahora muestra el progreso del comando similar a la experiencia cuando se usa el script bash meshery.\n\n\nv0.1.4\n\n¿Qué hay de nuevo?\n\n\n  Registro de cambios\n\n\nv0.1.3\n\n¿Qué hay de nuevo?\n\n\n  Migrar desde Configurar Meshery a la página Configuración.\n\n\nv0.1.2\n\n¿Qué hay de nuevo?\n\n\n  \n    Sincronización del almacenamiento local del navegador\n  \n  \n    Almacenamiento de sesiones en memoria de Meshery.\n  \n\n\nv0.1.1\n\n¿Qué hay de nuevo?\n\n\n  Parche para el bug Alpine.\n\n\nv0.1.0\n\nWhat’s new\n\n\n  Istio inicial completamente funcional.\n\n\nv0.0.9\n\n¿Qué hay de nuevo?\n\n\n  \n    Sitio de documentación segregado\n  \n  \n    contenido presenta					d				o		.				\n  \n\n					\nv0.0.8\n\n¿Qué hay de nuevo?\n\n\n  \n    Posibilidad de importar json del board de Grafana\n  \n  \n    Integración con Prometheus directamente para métricas.\n  \n\n\nv0.0.7\n\n¿Qué hay de nuevo?\n\n\n  \n    Migrado lejos de los gráficos de iframe incrustados de grafana\n  \n  Ahora usando Chartjs para gráficos.\n  Ahora usando C3 para gráficos.\n\n\nv0.0.6\n\n¿Qué hay de nuevo?\n\n\n  \n    Adaptador pre-alfa de Consul.\n  \n  Soporte para implementar el adaptador SMI Istio.\n  Asegurar la compatibilidad para aplicar los manifiestos SMI a través de Meshery.\n\n\nv0.0.5\n\n¿Qué hay de nuevo?\n\n\n  \n    Adaptador Linkerd pre-alpha.\n  \n  \n    Capacidad para filtrar resultados.\n  \n\n\nv0.0.4\n\n¿Qué hay de nuevo?\n-Posibilidad de ver resultados persistentes.\n\n\n  Integración y soporte para gráficos Grafana.\n  Embedding panels in iframe.\n\n\nv0.0.3\n\n¿Qué hay de nuevo?\n\n\n  \n    Versión inicial con soporte de adaptadores Meshery.\n  \n  \n    Lanzamiento de una versión pre-alfa del adaptador Istio.\n  \n\n\nv0.0.2\n\n¿Qué hay de nuevo?\n\n\n  Capacidad para admitir la ejecución de yaml personalizado en Kubernetes con Istio.\n\n\nv0.0.1\n\nNew release\n\n\n  Versión inicial de Meshery\n    \n      Conectar a Kubernetes.\n      Ejecutar comandos preconfigurados en Kubernetes con Istio."
					}




					,

					"guides-sample-apps": {
						"id": "guides-sample-apps",
						"title": "Deploying Sample Applications",
						"categories": "",
						"url": " /guides/sample-apps",
						"content": "Sample Applications are used to interact and exemplify the features of your service mesh. They are often a collection of microservices which you can be used by the user as a sandbox playground to experiment and learn about the service mesh and it’s exhaustive set of features.\nBefore deploying a sample app on top of your service mesh, the application needs to be exposed and allowed external access to the available services in a cluster. There are a myriad of ways to do this, specific to the service mesh you are using.\n\nA popular way of exposing your cluster is by using Ingress, an API object that defines rules which allow external access to services in a cluster.\n\n\n  Set up Ingress\n  Set up Ingress on Minikube\n\n\nDeploy a sample app on Meshery\n\n\n  Go to the management page of any service mesh and install any of its stable versions\n\n  Click (+) on Manage Sample Application Lifecycle. You will now be able to see a drop down menu with the available sample applications.\n\n\n\n\n  Click on the sample application you want to deploy. This might take up to a minute. You will be notified when the sample application has been deployed\n\n\n\nBookInfo\n\nOriginally built by Istio, BookInfo is a sample application which on deployment displays information about a book, similar to a single catalog entry of an online book store. Displayed on the page is a description of the book, book details (ISBN, number of pages, and so on), and a few book reviews. The application comprises of four microservices:\n\n\n  productpage: The productpage microservice calls the details and reviews microservices to populate the page.\n  details: The details microservice contains book information.\n  reviews: The reviews microservice contains book reviews. It also calls the ratings microservice.\n  ratings: The ratings microservice contains book ranking information that accompanies a book review.\n\n\nOnce BookInfo is deployed, you can use Meshery to apply custom configurations to control traffic, inject latency, perform context-based routing, and so on.\n\n\n\nEmojivoto\n\nEmojivoto is a microservice application, originally built by Linkerd that allows users to vote for their favorite emoji, and tracks votes received on a leaderboard. The application is composed of three microservices:\n\n\n  emojivoto-web: Web frontend and REST API\n  emojivoto-emoji-svc: gRPC API for finding and listin					g				 		e				moji\n  					emojivoto-voting-svc: gRPC API for voting and leaderboard\n\n\n\n\nImageHub\n\nImage Hub is a sample application for exploring WebAssembly modules used as Envoy filters. The application was originally written to run on Consul. However, it doesn’t have any dependency on Consul and can be deployed on any service mesh. These modules can be used to implement multi-tenancy or to implement per user rate limiting in your application’s endpoints, without messing with your application infrastructure. \nFollow this tutorial to set up ImageHub with Ingress\n\n\n\nHTTPBin\n\nHttpBin is a simple HTTP request and response service that responds to many kinds of http/https requests including the standaard http request methods (or verbs) used by REST.\n\n\n\nLinkerd Books\n\nLinkerd Books is a sample Ruby based application. It is designed to demonstrate the various value propositions, including debugging, observability, and monitoring of your service mesh. It can be used to scope out your mesh’s efficiency and for debugging.\n\n\n\nHipster\n\nHipster is a sample cloud-native application, originally built by Google. It comprises of 10 microservices and can be used to showcase and work with Kubernetes, Istio, gRPC and OpenCensus. On deployment, it runs a web-based e-commerce demo application, an example of which can be seen below:"
					}




					,

					"assets-css-sass-css": {
						"id": "assets-css-sass-css",
						"title": "",
						"categories": "",
						"url": " /assets/css/sass.css",
						"content": ".l5-dark-yellow { background-color: #ebc017 !important; }\n\n.l5-dark-yellow-text { color: #ebc017 !important; }\n\n.l5-light-yellow { background-color: #e9c46a !important; }\n.l5-light-yellow .l5-light-yellow-text { color: #e9c46a !important; }\n.l5-light-yellow table.adapters { box-shadow: 1px 1px 2px grey; border: 1px; }\n.l5-light-yellow table.adapters td { width: auto; vertical-align: middle; border: 1px solid darkgray; }\n.l5-light-yellow table.adapters td.no-adapters { width: auto; text-align: center; color: #aaa; font-style: italic; }\n.l5-light-yellow table.adapters td.alpha-adapters { width: auto; background-color: lightgray; text-align: center; }\n.l5-light-yellow table.adapters td.beta-adapters { width: auto; background-color: #00D3A9; text-align: center; color: #fff; }\n.l5-light-yello					w				 		t				able.ada					pters td.stable-adapters { width: auto; background-color: #3C494F; text-align: center; color: #fff; }\n.l5-light-yellow table.adapters tr:hover { background-color: #f5f5f5; }\n.l5-light-yellow table.adapters img.adapter-logo { vertical-align: middle; margin-right: 5px; height: 30px; width: 30px; }\n\npre.codeblock-pre { display: inline-flex; justify-content: left; text-align: left; align-items: left; align-content: left; flex-wrap: nowrap; flex-direction: row; background-color: #111; margin: 0; padding: 10px; border-radius: 0.3rem; width: 100%; }\n\n.codeblock { width: 100%; display: inline-flex; overflow: auto; justify-content: left; color: #ddd; margin: 0px; padding: 0px; }\n\n.clipboardjs { display: inline-flex; align-self: flex-end; justify-content: left; width: 100%; overflow-x: auto; padding: 0px; margin: 0px; }\n\n.btn-copy-wrap { align-content: flex-end; }\n\n.clipbtn { margin: 5px; border: 0px; background-color: transparent; color: #ccc; font-siz					e				:		 				1		.				2		r				em; }\n\					n.clipbtn:hover { color: #fff; cursor: pointer; }\n\ndiv.prereqs { background-color: #3C494F; color: #ddd; margin: 20px; padding: 15px; border-radius: 0.3rem; }\n\na.meshery-light { color: #00b39f; }\n\ntable.mesherycomponents th { background-color: #3C494F; color: white; }\ntable.mesherycomponents td.childcomponent { color: white; background-color: #477E96; }"
					}




					,

					"installation-platforms-scoop": {
						"id": "installation-platforms-scoop",
						"title": "Scoop",
						"categories": "",
						"url": " /installation/platforms/scoop",
						"content": "Quick Start with Scoop \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nmesheryctl can be installed via Scoop (a package manager for Windows, just like apt for Ubuntu). mesheryctl is also available through Homebrew.\nPrerequisites\n\nYou need to have scoop installed on your Windows system to perform these actions.\n\nInstall\n\nTo install mesheryctl using Scoop, execute the following commands.\n\n\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\n\n\nYou’re ready to run Meshery. To do so, execute the following command.\n\n\n\nmesheryctl system start\n\n\n\nUpgrade\n\nTo upgrade mesheryctl, just execute the following command.\n\n\n\nscoop update mesheryctl"
					}








					,

					"es-project-security-vulnerabilities": {
						"id": "es-project-security-vulnerabilities",
						"title": "Vulnerabilidades de seguridad",
						"categories": "",
						"url": " /es/project/security-vulnerabilities",
						"content": "# Informar una vulnerabilidad\n\nEstamos muy agradecidos con quienes investigan temas de seguridad y quienes informan\nsobre las vulnerabilidades de seguridad de Meshery. Investigamos cada informe a fondo.\n\nPara realizar un informe, envía un correo electrónico\na la lista de correo privada [meshery-security-vulns-reports@layer5.io](mailto:meshery-security-vulns-reports@layer5.io) con los detalles de la vulnerabilidad.\nPara los bugs normales del producto que no están relacionados con vulnerabilidades de seguridad latentes, diríjete al repositorio correspondiente\ny envía un [nuevo issue](https://github.com/layer5io/meshery/issues/new/choose).\n\n### ¿Cuándo informar una vulnerabilidad de seguridad?\n\nEnvíanos un informe siempre que:\n\n- Creas que Meshery tiene una vulnerabilidad de seguridad potencial.\n- No estás seguro de cómo una vulnerabilidad afecta a Meshery.\n- Creas que una vulnerabilidad está presente en otro proyecto que Meshery\n  depende de (Docker, por ejemplo).\n\n### ¿Cuándo no informar una vulnerabilidad de seguridad?\n\nNo envíes un informe de vulnerabilidad si:\n\n- Necesitas ayuda para ajustar los componentes de Meshery para la seguridad.\n- Necesitas ayuda para aplicar actualizaciones relacionadas con la seguridad.\n- Tu problema no está relacionado con la seguridad.\n\n## Evaluación\n\nEl equipo de Meshery reconoce y analiza cada informe de vulnerabilidad dentro de los 10 días hábiles.\n\nCualquier información de vulnerabilidad que compartas con el equipo de Meshery permanece\ndentro del proyecto Meshery. No divulgamos la información a otros\nproyectos. Solo compartimos la información necesaria para solucionar el problema.\n\nMantenemos al informante actualizado a medida que se aborda el estado del problema de seguridad.\n\n## Arreglando el problema\n\nUna vez que se ha distinguido por completo u					n				a		 				vulnerab					ilidad de seguridad, el equipo de Meshery desarrolla una solución.\nEl desarrollo y la prueba de la solución se realizan en un repositorio privado de GitHub para evitar\ndivulgación prematura de la vulnerabilidad.\n\n## Divulgación temprana\n\nEl proyecto Meshery mantiene una lista de correo para la divulgación temprana privada de vulnerabilidades de seguridad.\nLa lista se utiliza para proporcionar información procesable para socios cercanos de Meshery. La lista no está destinada\npara que las personas se enteren de los problemas de seguridad.\n\n## Divulgación pública\n\nEl día elegido para la divulgación pública, se lleva a cabo una secuencia de actividades lo más rápido posible:\n\n- Los cambios se combinan, desde el repositorio privado de GitHub que contiene la corrección, en el conjunto apropiado de ramas públicas.\n\n- El equipo de Meshery se asegura de que todos los binarios necesarios se creen y se publiquen rápidamente.\n\n- Una vez que los binarios están disponibles, se envía un anuncio en los siguientes canales:\n\n  - El [Blog de Meshery](https://meshery.io/blog/)\n  - El [Feed del Twitter de Meshery](https://twitter.com/mesheryio)\n  - El canal de #announcements en Slack\n\nEn la medida de lo posible, este anuncio será procesable e incluirá cualquier medida de mitigación que los clientes puedan tomar antes de\nactualizar a una versión fija."
					}




					,

					"project-security-vulnerabilities": {
						"id": "project-security-vulnerabilities",
						"title": "Security Vulnerabilities",
						"categories": "",
						"url": " /project/security-vulnerabilities",
						"content": "## Reporting a vulnerability\n\nWe are very grateful to the security researchers and users that report\nback Meshery security vulnerabilities. We investigate every report thoroughly.\n\nTo make a report, send an email to the private\n[meshery-security-vulns-reports@meshery.dev](mailto:meshery-security-vulns-reports@meshery.dev)\nmailing list with the vulnerability details. For normal product bugs\nunrelated to latent security vulnerabilities, please head to\nthe appropriate repository and submit a [new issue](https://github.com/layer5io/meshery/issues/new/choose).\n\n### When to report a security vulnerability?\n\nSend us a report whenever you:\n\n- Think Meshery has a potential security vulnerability.\n- Are unsure whether or how a vulnerability affects Meshery.\n- Think a vulnerability is present in another project that Meshery\ndepends on (Docker for example).\n\n### When not to report a security vulnerability?\n\nDon't send a vulnerability report if:\n\n- You need help tuning Meshery components for security.\n- You need help applying security related updates.\n- Your issue is not security related.\n\nInstead, join the [Layer5 Slack community](http://slack.layer5.io/) and ask questions.\n\n### Evaluation\n\nThe Meshery team acknowledges and analyzes each vulnerability report within 10 working days.\n\nAny vulnerability information you share with the Meshery team stays\nwithin the Meshery project. We don't disseminate the information to other\nprojects. We only share the information as needed to fix the issue.\n\nWe keep the reporter updated as the status of the secur					i				t		y				 issue i					s addressed.\n\n### Fixing the issue\n\nOnce a security vulnerability has been fully characterized, a fix is developed by the Meshery team.\nThe development and testing for the fix happens in a private GitHub repository in order to prevent\npremature disclosure of the vulnerability.\n\n### Early disclosures\n\nThe Meshery project maintains a mailing list for private early disclosure of security vulnerabilities. \nThe list is used to provide actionable information to close Meshery partners. The list is not intended \nfor individuals to find out about security issues.\n\n### Public disclosures\n\nOn the day chosen for public disclosure, a sequence of activities takes place as quickly as possible:\n\n- Changes are merged from the private GitHub repository holding the fix into the appropriate set of public\nbranches.\n\n- Meshery team ensures all necessary binaries are promptly built and published.\n\n- Once the binaries are available, an announcement is sent out on the following channels:\n  - The [Meshery blog](https://meshery.io/blog/)\n  - The [Meshery Twitter feed](https://twitter.com/mesheryio)\n  - The [#announcements](https://layer5io.slack.com/archives/CSF3PSZT9) channel on [Layer5 Slack](http://slack.layer5.io/)\n\nAs much as possible this announcement will be actionable, and include any mitigating steps customers can take prior to upgrading to a fixed version."
					}




					,

					"functionality-service-mesh-interface": {
						"id": "functionality-service-mesh-interface",
						"title": "Meshery and Service Mesh Interface (SMI)",
						"categories": "",
						"url": " /functionality/service-mesh-interface",
						"content": "## Conformance\n\nDefining “Conformance” - It’s important to acknowledge that conformance consists of both capabilities and compliance status. We define conformance as a combination of these two concepts.\n\n1. SMI Conformance acknowledges that\n   ...some participating service meshes may conscientiously never fully implement functions (SMI specs)...\n\n2. SMI Conformance identifies\n   ...a difference between full implementation of a specification and compliance with the portions that it implements...\n\n## Capability\n\nGiven that some service mesh implementations, never intend to fully implement the SMI specifications, for each individual test, three possible capability designations exist\n\n- Full - service mesh has this capability.\n\n- Partial - service mesh has a portion of this capability implemented (may or may not have this full capability in the future).\n\n- None - currently service mesh does not have this capability (may or may not have this capability in the future).\n\n## Approach to Conformance Testing\n\nEach Kubernetes version, service mesh version and SMI category will undergo several tests. Each test will be carried out in an automated and concurrent fashion, mostly, by invoking Meshery to execute the conformance tests.\n\n#### Here are the steps\n\n- Setup a specific version of a service mesh\n- [Optional] Setup Prometheus accordingly\n- Deploy a chosen sample app\n- Deploy the needed SMI operator like smi-metrics\n  the test to run, which can involve calling an API endpoint\n- Validation of the response\n\nNot all tests can be validated by just using the response, in those cases we can also connect to a prometheus instance, which is preconfigured to collect all the metrics for the test, and use these metrics to define expectations. We will be working on specific examples.\n\nFinally, the results for the test runs from Meshery are persisted (same GitHub repository) and published on the conformance web page. Eventually, we can build a system which will allow us to run granular tests on demand for a chosen Kubernetes, service mesh and SMI Operator versions.\n\n## Conformance Test Definitions\n\nConformance tests are categorized by SMI specification type. A set of tests are defined for each SMI specification. Within each test set, two types of assertion tests are defined a presence assertion and a capability assertion.\n\n## Validating Conformance\n\nConformance to SMI specifications will be done through automated provisioning of individual service meshes and deployment of a common workload. A simple, instrumented, sample application is used as the workload to test.\n\n## Defining Conformance\n\nConformance with SMI specifications is defined as a series of test assertions. A test assertion is a condition that must be tested to confirm conformance to a requirement. A test assertion is a condition that from the perspective of validation testing, determining conformance will require any number of conditions to be tested. The collection of test assertions categorized by SMI specification collectively define the suite of SMI conformance tests. Meshery is the test harness used to fit SMI conformance tests to different service meshes and different workloads.\n\n## Steps To Executing Performance Tests\n\n### Preconditions\n\n- A given service mesh’s ability to adhere to the SMI specification is validated by running a workload on top of the service mesh.\n- Workload deployments are configured specific to the onboarding requirements of the given service mesh.\n- Tests are defined to validate conformance for each type of SMI specification (e.g. metrics, access, traffic… ).\n\n### Invocation\n\n- Test assertions are defined in a workload-specific way and deployed with the workloads being tested (test assertions are packaged).\n- A test result is collected with the evaluation of each assertion.\n- Future Test results will be individually streamed to Meshery after each assertion is evaluated.\n- Once all assertions are evaluated, test results are returned for visual presentation in Meshery\n\n## Reporting Conformance\n\n### Provenance of Test Results\n\nEach participating service mesh project will be asked to incorporate the conformance tool, Meshery, into their CI pipelines, or alternatively,					 				t		o				 manuall					y run the conformance test suite when a release of the service mesh project is made. The conformance tool will run the test suite and automatically update the conformance dashboard when the test is complete.\nIn order to ensure provenance of test results that represent a given service mesh, each project will be asked to identify one or more github accounts tha					t				 		w				ill be u					sed for publishing the tests. Ideally, this github account is a servicerobot account used within the project’s CI pipeline.\n\nThis method of providing verification of results is similarly used for those same service mesh projects that also use Meshery to provide their performance test results.\n\nEach service mesh project needs to identify their servicerobot account, by updating this list httpsmeshery.iosmi-conformancesm-service-accounts. Identify a given Meshery Provider user and designate their “CI service account”.\n\n## Publishing Test Results\n\nA public-facing report will display the current and historical status of individual service mesh capability with each of the SMI specifications. The report will be visual in nature, but also be available as yaml. Dashboard to be published publicly here httpsmeshery.iosmi-conformance (currently, listed on httpslayer5.iolandscape#smi).\n\n### Historical Conformance\n\nReports will track the history of service mesh versions and SMI spec versions and their compatibility."
					}




					,

					"sitemap-xml": {
						"id": "sitemap-xml",
						"title": "",
						"categories": "",
						"url": " /sitemap.xml",
						"content": "/\n     {{ \"now\" | date: \"%Y-%m-%d\" }}\n     daily\n    \n{% for section in site.data.toc %}\n     {{ site.baseurl }}{{ section.url }}/\n     {{ \"now\" | date: \"%Y-%m-%d\" }}\n     daily\n    \n{% endfor %}"
					}




					,

					"es-functionality-smi-conformance": {
						"id": "es-functionality-smi-conformance",
						"title": "SMI Conformance Capability",
						"categories": "",
						"url": " /es/functionality/smi-conformance",
						"content": "# Capacidad de conformidad de SMI\r\n\r\n## Conformidad\r\n\r\nDefiniendo “Conformidad” - Es importante reconocer que la conformidad consiste en capacidades y estado de conformidad. Nosotros definimos la conformidad como una combinación de estos 2 conceptos.\r\n\r\n1. La conformidad de SMI reconoce que\r\n   ...algunos service mesh participantes nunca implementan completamente funciones a conciencia (especificaciones SMI)...\r\n\r\n2. La conformidad SMI identifica\r\n   ...una diferencia entre la completa implementación de una especificación y el cumplimiento de las partes que implementa...\r\n\r\n## Capacidad\r\n\r\nDado que algunas implementaciones del service mesh nunca tienen la intención de implementar completamente las especificaciones de SMI, por cada prueba individual, existen tres posibles designaciones de capacidad.\r\n\r\n- Completa - los service mesh tienen esta capacidad.\r\n\r\n- Parcial - los service mesh tienen implementada una porción de esta capacidad (puede o no tener esta capacidad completamente en el futuro).\r\n\r\n- Ninguna - actualmente los service mesh no tienen esta capacidad (puede o no tener esta capacidad en el futuro).\r\n\r\n## Enfoque de las pruebas de conformidad\r\n\r\nCada versión de Kubernetes, versión de service mesh y categoría de SMI serán sometidas a varias pruebas. Cada prueba se llevará a cabo de forma automatizada y concurrente, principalmente invocando a Meshery para ejecutar las pruebas de conformidad.\r\n\r\n#### Estos son los pasos\r\n\r\n- Configurar una versión específica de un service mesh\r\n- [Opcional] Configurar Prometheus\r\n- Desplegar una aplicación de muestra elegida\r\n- Desplegar el operador SMI necesario, como smi-metrics\r\n  la prueba se ejecutará, lo que puede implicar la llamada a un punto final de API\r\n- Validar la respuesta\r\n\r\nNo todas las pruebas pueden ser validadas simplemente usuando la respuesta, en estos casos podemos también conectarnos a una instancia de Prometheus, el cual está preconfigurado para recolectar todas las métricas para la prueba, y usar estas métricas para definir expectativas. Trabajaremos en ejemplos específicos.\r\n\r\nFinalmente, los resultados de las ejecuciones de pruebas de Meshery son persistentes (como repositorios de GitHub) y publicados en la página web de conformidad. Eventualmente, podemos construir un sistema el cual nos permitirá ejecutar de forma granular pruebas en demanda para una versión elegida de Kubernetes, service mesh y operador de SMI.\r\n\r\n## Definiciones de las pruebas de conformidad\r\n\r\nLas pruebas de conformidad son clasificadas por tipo de especificación SMI. Un conjunto de pruebas son definidas para cada especificación SMI. Dentro de cada conjunto de pruebas, se definen dos tipos de pruebas de aserción: aserción de presencia y aserción de capacidad.\r\n\r\n## Validación de conformidad\r\n\r\nLa conformidad con las especificaciones de SMI se realizarán a través del aprovisionamiento automatizado de service mesh individuales y el despliegue de una carga de trabajo en común. Se utiliza una aplicación de muestra sencilla e instrumentada como carga de trabajo para probar.\r\n\r\n## Definición de conformidad\r\n\r\nLa conformidad con las especificaciones de SMI es definida como una serie de pruebas de aserción. Una prueba de aserción es una condición que debe probarse para confirmar la conformidad con un requisito. Una prueba de aserción es una condición que desde la perspectiva de las pruebas de validación, determinan la conformidad requerida para que se prueben varias condiciones. La colección de pruebas de aserción clasificadas por la especificación de SMI define colectivamente el conjunto de pruebas de conformidad de SMI. Meshery es el mejor arnés de prueba utilizado para ajustar las pruebas de conformidad de SMI para diferentes service mesh y diferentes cargas de trabajo.\r\n\r\n## Pasos para ejecutar pruebas de rendimiento\r\n\r\n### Precondiciones\r\n\r\n- La capacidad de un determinado service mesh para adherirse a una especificación de SMI es validada ejecutando una carga de trabajo sobre el service mesh.\r\n- Los depliegues de cargas de trabajo son configurados de forma específica para los requisitos de incorporación del service mesh dado.\r\n- Las pruebas son definidas para validar la conformidad para cada tipo de especificación de SMI (por ejemplo, métricas, acceso, tráfico...).\r\n\r\n### Invocación\r\n\r\n- Las pruebas de aserción son definidas de acuerdo a una carga de trabajo específica y son desplegadas con las cargas de trabajo que se están probando (las pruebas de aserción están empaquetadas).\r\n- Un resultado de prueba es recolectado con la evaluación de cada aserción.\r\n- Los resultados de futuras pruebas se transmitirán individualmente a Meshery después de que se evalúe cada aserción.\r\n- Una vez que todas las aserciones son evaluadas, los resultados de las pruebas son retornadas a Meshery para su representación visual.\r\n\r\n## Informe de conformidad\r\n\r\n### Procedencia de los resultados de pruebas\r\n\r\nA cada proyecto de service mesh participante se le pedirá que incorpore la herramienta de conformidad, Meshery, en sus pipelines de CI o, alternativamente, que ejecute manualmente el conjunto de pruebas de conformidad cuando se realice un despliegue del proyecto de service mesh. La herramienta de conformidad ejecutará el conjunto de pruebas y automáticamente actualizará el panel de conformidad cua					n				d		o				 		l				a prueba					 sea completada.\r\nPara garantizar la procedencia de los resultados de las pruebas que representan un service mesh determinado, se pedirá a cada proyecto que identifique uno o más cuentas de GitHub que se utilizarán para publicar las pruebas. Idealmente, esta cuenta de GitHub es una cuenta servicerobot que se usa dentro del pipeline de CI del proyecto.\r\n\r\nEste método de proporcionar la verification de resultados es usado de manera similar para esos mismos proyectos de service mesh que también usan Meshery, para proporcionar sus resultados de pruebas de rendimiento.\r\n\r\nCada proyecto de service mesh necesita identificar su cuenta de servicerobot, actualizando esta lista httpsmeshery.iosmi-conformancesm-service-accounts. Identifique un usuario proveedor de Meshery determinado y designe su \"cuenta de servicio de CI\".\r\n\r\n## Publicación de resultados de pruebas\r\n\r\nUn informe de cara al público mostrará el estado actual e histórico de la capacidad del service mesh individual con cada una de las especificaciones de SMI. El informe será de natuaraleza visual, pero también está disponible como yaml. El panel se publicará públicamente aquí httpsmeshery.iosmi-conformance (actualmente, listado en httpslayer5.iolandscape#smi).\r\n\r\n### Conformidad histórica\r\n\r\nLos informes rastrearán el historial de las versiones del service mesh, las versiones de las especificaciones SMI y su compatibilidad."
					}






					,

					"guides-upgrade": {
						"id": "guides-upgrade",
						"title": "Upgrade `mesheryctl` and Meshery",
						"categories": "",
						"url": " /guides/upgrade",
						"content": "# Upgrade Guide\n\n## Upgrading Meshery Server, Adapters, and UI\n\nVarious components of Meshery will need to be upgraded as new releases become available. Meshery is comprised of a number of components including a server, adapters, UI, and CLI. As an application, Meshery is a composition of different functional components.\n\n\n    \nFigure: Meshery components\n\n\nSome of the components must be upgraded simultaneously, while others may be upgraded independently. The following table depicts components, their versions, and deployment units (deployment groups).\n\n\n\n### Versioning of Meshery components\n\n\n    \n        Components\n        Sub-component\n        Considering or Updating\n    \n    \n        Meshery Adapters\n        Any and All Adapters\n        Docker Deployment: Watchtower updates this component in accordance with the user’s release channel subscription.\n    \n    \n        Meshery Server\n        Meshery UI\n        Manages lifecycle of Meshery Operator; Adapters, UI, Load Generators, Database.\nDocker Deployment: Watchtower updates this component in accordance with the user’s release channel subscription.\n    \n    \n        Load Generators\n    \n    \n        Database\n    \n    \n        Meshery Operator\n        MeshSync\n        Meshery Operator manages the lifecycle of this component and its sub-components.\n    \n    \n        Meshery Broker\n        Meshery Operator manages the lifecycle of this event bus component.\n    \n    \n        `mesheryctl`\n        \n        mesheryctl manages the lifecycle of Meshery Server. \n         \n            system start calls system update by default, which updates server and existing adapters, but doesn’t update meshery.yaml.\n            system reset retrieving docker-compose.yaml from GitHub (use git tag to reset to the right Meshery version).\n            system context manages config.yaml, which manages meshery.yaml. \n            mesheryctl					 				s		h				ould gen					erally be checking for latest release and informing user.\n        \n        \n    \n    \n        Remote Providers\n        Meshery Cloud\n        Process Extension: Integrators manage the lifecycle of their Remote Providers. Process is unique per provider.\n    \n    \n        Meshery Cloud\n         Static Extension: Integrators manage the lifecycle of their Meshery Extensions. Process is unique per provider.\n    \n\n\n\nSub-components deploy as a unit, however, they do not share the same version number.\n\n### Meshery Docker Deployments\n\nIn order to upgrade Meshery Server, Adapters, and UI, execute the following command:\n\n \n \n mesheryctl system update\n \n \n\n### Meshery Kubernetes Deployments\n\nUse `kubectl apply` or `helm` to upgrade the Meshery application manifests in your Kubernetes cluster.\n\n## Upgrading Meshery CLI\n\nThe Meshery command line client, `mesheryctl`, is available in different package managers. Use the instructions relevant to your environment.\n\n### Upgrading `mesheryctl` using Homebrew\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n brew upgrade mesheryctl\n \n \n\n### Upgrading `mesheryctl` using Bash\n\nUpgrade `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n### Upgrading `mesheryctl` using Scoop\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n scoop update mesheryctl"
					}




					,

					"es-installation-platforms-windows": {
						"id": "es-installation-platforms-windows",
						"title": "Windows",
						"categories": "",
						"url": " /es/installation/platforms/windows",
						"content": "# **Inicio rápido con Windows**\n\nPara configurar y ejecutar Meshery en Windows:\n\n1. Configurar Windows y habilitar Docker \n2. Instalar un cluster Kubernetes\n3. Instalar Meshery\n\n### **Compatibilidad**\n\nLas siguientes versiones mínimas de Compilación de Windows son requeridas:\n\n\n  \n    Nombre\n    Versión\n  \n  \n    WSL1\n    x64 - Windows 7 \n  \n  \n    WSL2\n    x64 - Version 1903, Compilación 18362; ARM 64 - Version 2004, Compilación 19041\n  \n  \n    Kernel Personalizado\n    Compilación 18945\n  \n  \n    Kernel con módulos requeridos K8s\n    Compilación 19013\n  \n\n\n**Nota**\nEjecute el siguiente comando en Powershell para comprobar la compilación y la versión de Windows:\n\n```powershell\n[System.Environment]::OSVersion.Version\n```\n\n### **Pasos**\n\nRealice los siguientes pasos en orden:\n\n#### 1. Instalar el subsistema de Windows para Linux (WSL)\n\nAbra la Powershell en modo administrador y ejecute:\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nRestart-Computer\n```\n\n##### **Elegir tu versión WSL:**\n\nWSL2 (Recomendado)\nElija la versión por defecto a `WSL2`, la cual será heredada por cualquier distro que desee usar.\n\n**Habilite la característica VM (Virtual Machine)**:\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**Colocar WSL2 como la versión default**:\n\n```bash\nwsl --set-default-version 2\n```\n\n WSL1 \n\nAdvertencia:\nSe recomienda actualizar a WSL2 ya que WSL1 no soporta la aplicación Docker Desktop para Windows. En su lugar, solo soporta la versión obsoleta, [Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/).\n\nSi aun desea continuar, siga las instrucciones para WSL1\n\n\n\n1. La versión por defecto de WSL está establecida en WSL1 por defecto. Puedes ir al siguiente link para instalar la distro de tu elección. \n\n2. Docker Toolbox \n\nAdvertencia: Docker Toolbox es una versión obsoleta. Se recomienda actualizar el sistema e instalar la aplicación Docker Desktop con WSL2. \n\nDocker Toolbox utiliza características específicas del kernel de Linux, y no puede funcionar de forma nativa en Windows. En su lugar, crea y utiliza una pequeña VM de Linux en tu máquina junto con docker-machine , y utiliza VirtualBox para ejecutar Docker. \n\n Diríjase a Toolbox Releases y descargue la última versión del archiv					o				 		.				exe\n Si					ga estas instrucciones para configurar con éxito la aplicación Docker Toolbox. \n\n\n\n\n\n#### 2. [Instalar la nueva distro](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice)\n\nEn este tutorial, [Ubuntu 18.04](https://www.microsoft.com/en-us/p/ubuntu-1804-lts/9n9tngvndl3q?activetab=pivot:overviewtab) será la distro utilizada. Siéntase libre de usar cualquier distro a su elección.\n\n#### 3. habilitar Docker\n\nLa aplicación Docker Desktop para Windows incluye un completo conjunto de herramientas, incluyendo Docker Engine, el cliente Docker CLI, Docker Compose, Notary, Kubernetes, y un Credential Helper.\n\n\n  \n    Versión Windows 10\n    Docker Desktop\n  \n  \n    Pro/Education/Enterprise\n    Docker Desktop para Windows Pro\n  \n  \n    Home\n    Docker Desktop para Windows Home\n  \n\n\n#### 4.  Instalar un cluster Kubernetes\n\nUna vez que Docker esté instalado, el siguiente paso será instalar un cluster Kubernetes. En esta guía, se usará [K3d](https://github.com/rancher/k3d) ya que sólo depende de Docker.\n\n```bash\ncurl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash\nk3d cluster create\nexport KUBECONFIG=\"$(k3d kubeconfig get 'k3s-default')\"\n```\n\n#### 5. Instalar Meshery\n\nSiga los [pasos de instalación]({{ site.baseurl }}/es/installation/windows.md) para instalar el CLI mesheryctl. Luego, ejecute:\n\n```bash\n./mesheryctl system start\n```"
					}




					,

					"installation-platforms-windows": {
						"id": "installation-platforms-windows",
						"title": "Windows",
						"categories": "",
						"url": " /installation/platforms/windows",
						"content": "{% include installation_prerequisites.html %}\n\n# Overview\nTo set up and run Meshery on Windows \n\n1. Configure Windows and enable Docker \n2. Install a Kubernetes cluster on top \n3. Run Meshery\n\n### Compatibility\n\nThe following minimum Windows build versions are required:\n\n  \n    Name\n    Version \n  \n  \n    WSL1\n    x64 - Windows 7 \n  \n  \n    WSL2\n    x64 - Version 1903, Build 18362; ARM 64 - Version 2004, Build 19041\n  \n  \n    Custom Kernel\n    Build 18945\n  \n  \n    Kernel with K8s required modules\n    Build 19013\n  \n\n\nNote\nRun the following command on Powershell to check your Windows build and version:\n \n \n[System.Environment]::OSVersion.Version\n \n \n### Steps\nPerform the following steps in order:\n\n### 1. Install Windows Subsystem for Linux (WSL) \n\nOpen Powershell in administrator mode and run:\n\n \n \n dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n Restart-Computer\n \n \n\n##### Choosing your WSL version:\n\nWSL2 (Recommended)\nSet the default version to *WSL2*, which will be inherited by any distro you wish to use.\n\nEnable VM (Virtual Machine) feature:\n\n \n \n dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n \n \n\nSet WSL2 as the default version:\n\n \n \n wsl --set-default-version 2\n \n \n\n WSL1 \n\nWarning:\nIt is recommended to update to WSL2 as WSL1 doesn't support the Docker Desktop application for Windows. Instead, it only supports the deprecated version, [Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/). \n\nIf you still wish to continue, follow the instructions for WSL1\n\n\n\n1. The default version of WSL is set to WSL1 by default. You can move forward to install the distro of your choice. \n\n2. Docker Toolbox \n\nWarning: Docker Toolbox is a deprecated version. It is recommended to update your system and install the Docker Desktop application with WSL2. \n\nDocker Toolbox uses Linux-specific kernel features, and can’t run natively on Windows. Instead, it creates and uses a small Linux VM on your machine along with docker-machine, and uses VirtualBox to run Docker. \n    \n         Go to Toolbo					x				 		R				eleases 					and download the latest release .exe file \n        Follow these instructions to successfully set up the Docker Toolbox application. \n    \n\n\n\n\n\n### 2. [Install a new distro](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice)\nIn this tutorial, [Ubuntu 18.04](https://www.microsoft.com/en-us/p/ubuntu-1804-lts/9n9tngvndl3q?activetab=pivot:overviewtab) will be the distro used. Feel free to use any distro of your choice.\n\n\n### 3. Enable Docker\n\nThe Docker Desktop application for Windows includes a comprehensive set of tools, including Docker Engine, Docker CLI client, Docker Compose, Notary, Kubernetes, and a Credential Helper.\n\n\n  \n    Windows 10 Version\n    Docker Desktop \n  \n  \n    Pro/Education/Enterprise\n    Docker Desktop for Windows Pro\n  \n  \n    Home\n    Docker Desktop for Windows Home\n  \n\n\n### 4.  Install a Kubernetes cluster\n\nOnce Docker is installed, the next step will be to install a Kubernetes cluster.\nIn this how-to, [K3d](https://github.com/rancher/k3d) will be used as it relies only on Docker.\n\n  \n  \n  curl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash\n  k3d cluster create\n  export KUBECONFIG=\"$(k3d kubeconfig get 'k3s-default')\"\n  \n  \n\n\n### 5. Set up Meshery\n\nFollow the [installation steps]({{ site.baseurl }}/installation#windows) to install the mesheryctl CLI. Then, execute:\n  \n  \n  ./mesheryctl system start"
					}




					,

					"guides-mesheryctl": {
						"id": "guides-mesheryctl",
						"title": "Using mesheryctl",
						"categories": "",
						"url": " /guides/mesheryctl",
						"content": "`mesheryctl` is the command line interface to manage Meshery and interface with its functionality using a terminal. `mesheryctl` commands are categorized into three main areas:\n\n- Lifecycle management of Meshery (control Meshery's lifecycle with commands like `system start`, `stop`, `status`, `reset`. )\n- Lifecycle management of Service Meshes\n- Performance management of Service Meshes and Workloads\n\n\n\n## Related Guides\n\n- For an exhaustive list of commands and syntax, refer to the **[`mesheryctl` Command Reference]({{ site.baseurl }}/guides/mesheryctl-commands)**.\n- To upgrade `mesheryctl`, refer to the **[Upgrade Guide]({{ site.baseurl }}/guides/upgrade)**.\n\n## Installing `mesheryctl`\n\n### Mac or Linux\n\nUse your choice of homebrew or bash to install `mesheryctl`. You only need to use one.\n### Homebrew\n\nInstall `mesheryctl` and run Meshery on Mac with Homebrew.\n\n#### Installing with Homebrew\n\nTo install `mesheryctl`, execute the following commands:\n\n \n \n brew tap layer5io/tap\n brew install mesheryctl\n mesheryctl system start\n \n \n\n**Upgrading with Homebrew**\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n brew upgrade mesheryctl\n \n \n\n#### Bash\n\n**Installing with Bash**\n\nInstall `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n**Upgrading with Bash**\n\nUpgrade `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n## Windows\n\n### Installing the `mesheryctl` binary\n\nDownload and unzip `mesheryctl` from the [Meshery releases](https://github.com/layer5io/meshery/releases/latest) page. Add `mesheryctl` to your PATH for ease of use. Then, execute:\n\n \n \n ./mesheryctl system start\n \n \n\n### Scoop\n\nUse [Scoop](https://scoop.sh) to install Meshery on your Windows machine.\n\n**Installing with Scoop**\n\nAdd the Meshery Scoop Bucket and install:\n\n \n \n scoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\n scoop install mesheryctl\n \n \n\n**Upgrading with Scoop**\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n scoop update mesheryctl\n \n \n\n## Advanced Installation\n\nUsers can control the specific container image and tag (version) of Meshery that they would like to run by editing their local *~/.meshery/meshery.yaml* (a docker compose file).\nAligned with the Meshery container image, instead of leaving the implicit :stable-latest tag behind image: layer5/meshery, users will instead identify a specific image tag like so:\n\n```\nbash\nversion: '3'\nservices:\n  meshery:\n    image: layer5/meshery:v0.5.0\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n```\n\n# Configuring Autocompletion for `mesheryctl`\n\nIf you would like to have `mesheryctl` commands automatically completed for use as you use `mesheryctl`, then use the f					o				l		l				owing in					structions to configure automatic completion within your environment.\n\n## Autocompletion for Bash\n\n### bash \n \n source /dev/stdin \n \n\n### bash >= 4.0\n\n \n \n source \n \n\n### bash \n \n brew instal					l				 		b				ash-comp					letion # ensure you have bash-completion 1.3+\n mesheryctl system completion bash > $(brew --prefix)/etc/bash_completion.d/mesheryctl\n \n \n\n### bash >= 4.0 on MacOS\n\n \n \n br					e				w		 				install 					bash-completion@2\n mesheryctl system completion bash > $(brew --prefix)/etc/bash_completion.d/mesheryctl\n \n \n\n## Autocompletion for zsh\n\n \n \n so					u				r		c				e \n \n\					nIf shell completion is not already enabled in your environment you will need to enable it.  You can execute the following once:\n\n \n \n ~/.zshrc > echo \"autoload -U compi					n				i		t				; compin					it\" \n \n \n_Note_ : You might need to restart your shell for this setup to take effect.\n\n#### zsh on MacOS and Oh My zsh\n\n \n \n mesheryctl system completion zsh > \"${fpath[					1				]		}				/_mesher					yctl\"\n \n \n\n### Autocompletion for fish\n\n \n \n mesheryctl system completion fish | source\n \n \n\nTo load fish shell completions for each session, execute once:\n \n \n mesheryct					l				 		s				ystem co					mpletion fish > ~/.config/fish/completions/mesheryctl.fish\n \n \n\n# Suggested Reading\n\n- For an exhaustive list of commands and syntax,					 				r		e				fer to t					he **[`mesheryctl` Command Reference]({{ site.baseurl }}/guides/mesheryctl-commands)**.\n- To upgrade `mesheryctl`, refer to the **[Upgrade Guide]({{ site					.				b		a				seurl }}					/guides/upgrade)**."
					}




					,

					"assets-css-style-css": {
						"id": "assets-css-style-css",
						"title": "",
						"categories": "",
											"				u		r				l": " /a					ssets/css/style.css",
						"content": "@import \"jekyll-theme-primer\";"
					}




					,

					"architecture-adapters": {
						"id": "architecture-adapters",
						"title": "",
																					"catego					ries": "",
						"url": " /architecture/adapters",
						"content": ""
					}




					,

					"architecture": {
						"id": "architecture",
						"title": "",
						"					c				a		t				egories"					: "",
						"url": " /architecture",
						"content": ""
					}




					,

					"architecture-broker": {
						"id": "architecture-broker",
						"title": "",
						"					c				a		t				egories"					: "",
						"url": " /architecture/broker",
						"content": ""
					}




					,

					"architecture-database": {
						"id": "architecture-database",
						"title": "",
						"categories": "",
						"url": " /architecture/database",
						"content": ""
					}




					,

					"reference-extensibility": {
						"id": "reference-extensibility",
						"title": "",
						"categories": "",
						"url": " /reference/extensibility",
						"content": ""
					}




					,

					"project": {
						"id": "project",
						"title": "",
						"categories": "",
						"url": " /project/",
						"content": ""
					}




					,

					"installation": {
						"id": "installation",
						"title": "",
						"categories": "",
						"url": " /installation/",
						"content": ""
					}




					,

					"guides-mesheryctl": {
						"id": "guides-mesheryctl",
						"title": "",
						"categories": "",
						"url": " /guides					/				m		e				sheryctl					",
						"content": ""
					}




					,

					"guides-mesheryctl-commands": {
						"id": "guides-mesheryctl-commands",
						"title": "",
						"categories": "",
						"url": " /guides/mesheryctl-commands",
						"content": ""
					}




					,

					"architecture-meshsync": {
						"id": "architecture-meshsync",
						"title": "",
						"categories": "",
						"url": " /architecture/meshsync",
						"content": ""
					}




					,

					"architecture-operator": {
						"id": "architecture-operator",
						"title": "",
						"categories": "",
						"url": " /architecture/operator",
						"content": ""
					}




					,

					"redirects-json": {
						"id": "redirects-json",
						"title": "",
						"categories": "",
						"url": " /redirects.json",
						"content": "{\"/architecture/adapters\":\"http://localhost:4000/concepts/architecture/adapters\",\"/architecture\":\"http://localhost:4000/concepts/architecture\",\"/architecture/broker\":\"http://localhost:4000/concepts/architecture/broker\",\"/architecture/database\":\"http://localhost:4000/concepts/architecture/database\",\"/reference/extensibility\":\"http://localhost:4000/extensibility\",\"/project/\":\"http://localhost:4000/project\",\"/installation/\":\"http://localhost:4000/installation/quick-start\",\"/guides/mesheryctl\":\"http://localhost:4000/reference/mesheryctl\",\"/guides/mesheryctl-commands\":\"http://localhost:4000/reference/mesheryctl\",\"/architecture/meshsync\":\"http://localhost:4000/concepts/architecture/meshsync\",\"/architecture/operator\":\"http://localhost:4000/concepts/architecture/operator\"}"
					}




					,

					"pages-project-contributing-gitflow": {
						"id": "pages-project-contributing-gitflow",
						"title": "Working by Forking",
						"categories": "",
						"url": " /pages/project/CONTRIBUTING-gitflow/",
						"content": "# Working by Forking\nJust head over to the GitHub page and click the \"Fork\" button. It's just that simple. Once you've done that, you can use your favorite git client to clone your repo or just head straight to the command line:\n\n## Clone your fork to your local machine\n```\ngit clone git@github.com:USERNAME/FORKED-PROJECT.git\n```\nKeeping Your Fork Up to Date\nWhile this isn't a necessary step, if you plan on doing anything more than just a tiny quick fix, you'll want to make sure you keep your fork up to date by tracking the original \"upstream\" repo that you forked. To do this, you'll need to add a remote:\n\n## Add 'upstream' repo to list of remotes\n```\ngit remote add upstream https://github.com/layer5io/meshery.git\n``` \n(\"meshery\" is used as the example repo. Be sure to reference the _actual_ repo you're contributing to e.g. \"meshery-linkerd\").\n\n## Verify the new remote named 'upstream'\n```\ngit remote -v\n```\nWhenever you want to update your fork with the latest upstream changes, you'll need to first fetch the upstream repo's branches and latest commits to bring them into your repository:\n\n## Fetch from upstream remote\n```\ngit fetch upstream\n```\n\n## View all branches, including those from upstream\n```\ngit branch -va\n```\nNow, check out your master branch and merge the upstream repo's master branch:\n\n## Checkout your master branch and merge upstream\n```\ngit checkout master\ngit merge upstream/master\n```\nIf there are no unique commits on the local master branch, git will simply perform a fast-forward. However, if you have been making changes on master (in the vast majority of cases you probably shouldn't be - see the next section, you may have to deal with conflicts. When doing so, be careful to respect the changes made upstream.\n\nNow, your local master branch is up-to-date with everything modified upstream.\n\n**Create a Branch** (doing your work)\nWhenever you begin work on a new feature or bugfix, it's important that you create a new branch. Not only is it proper git workflow, but it also keeps your changes organized and separated from the master branch so that you can easily submit and manage multiple pull requests for every task you complete.\n\nTo create a new branch and start working on it, perform the following flow.\n\n## Check out the master branch - you want your new branch to come from the master\n```\ngit checkout master\n```\n\n## Create a new branch (give your branch its own simple informative name)\nFor enhancements use `feature/your_username/issue#` or `feature/your_username/name_of_feature`\n\nFor bugs use `bug/your_username/issue#` or `bug/your_username/name_of_bug`\n\n```\ngit branch f					e				a		ture/jdoe/567\n```\n\n## Switch to your new branch\n```\ngit checkout feature/jdoe/567\n```\nNow, go to town hacking away and making whatever changes you want to.\n\n## Submitting your changes (a Pull Request)\nBefore submitting your pull request, you might want to do a few things to clean up your branch and make it as simple as possible for the original repo's maintainer to test, accept, and merge your work.\n\nIn the time that you've been working on your changes, if any commits have been made to the upstream master branch, you will need to rebase your development branch so that merging it will be a simple fast-forward that won't require any conflict resolution work.\n\n## Fetch upstream master and merge with your repo's master branch\n```\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\n```\n\n## If there were any new commits, rebase your development branch\n```\ngit checkout feature/jdoe/567\ngit rebase master\n```\nNow, it may be desirable to squash some of your smaller commits down into a small number of larger more cohesive commits. You can do this with an interactive rebase:\n\n## Rebase all commits on your development branch\n```\ngit checkout\ngit rebase -i master\n```\nThis will open up a text editor where you can specify which commits to squash.\n\n## Submitting\nOnce you've committed and pushed all of your changes to GitHub, go to the page for your fork on GitHub, select your development branch, and click the pull request button. If you need to make any adjustments to your pull request, just push the updates to GitHub. Your pull request will automatically track the changes in your development branch and update it."
					}



	};
</script>
<script src="/v0.4/assets/js/lunr.min.j	s              "></script>
<script src="/v0.4/assets/js/search.js"></script>


<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

<script>
$(document).ready(function() {

    var toc = $('#TOC');

    // Select each header
    sections = $('.td-content h1');
        $.each(sections, function(idx, v) {
            section = $(v);
            var div_id = $(section).attr('id');
            if(!section.hasClass('noTOC')){
               var div_text = section.text().split('¶')[0];
              var parent = $("#" + div_id)
              var content = '<li id="link_' + div_id + '" class="md-nav__item"><a class="md-nav__link" href="#' + div_id + '" title="' + div_text +'">' + div_text +'</a></li>';
              $(toc).append(content);
            }

            // Add section code to subnavigation
            var children = $('<nav class="md-nav"><ul class="md-nav__list"></nav></ul>')
            var contenders = $("#" + div_id).nextUntil("h1");
            $.each(contenders, function(idx, contender){
                 if( !$(contender).hasClass("noTOC") && ($(contender).is('h2') || $(contender).is('h3')) ) {
                   var contender_id = $(contender).attr('id');
                   var contender_text = $(contender).text().split('¶')[0];
                   var content = '<li class="md-nav__item"><a class="md-nav__link" href="#' + contender_id + '" title="' + contender_text +'">' + contender_text +'</a></li>';
                   children.append(content);
                }
             })
             $("#link_" + div_id).append(children);
        });
    });
</script>

              <br/>


           </div>
          </main>
        </div>
      </div>
      <footer class="bg-dark py-3 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
<!-- meshery-custom-begin"
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">

<ul class="list-inline mb-0">
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="" aria-label="Twitter" data-original-title="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/layer5">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="" aria-label="GitHub" data-original-title="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/layer5io/meshery">
      <i class="fab fa-github"></i>
    </a>
  </li>
</ul>
meshery-custom-end -->

<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
  <small class="text-white">© 2020 Layer5 All Rights Reserved</small>


  <!-- meshery-custom-begin -->

  <p class="mt-2">

  <div class="footer-icons-list">

    <div class="footer-icons">
      <a class="social__link social__link--mail" href="mailto:community@layer5.io">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px" >
          <path fill="currentColor" d="M326.7,166.2c2-1.6,5-0.1,5,2.4v106c0,13.7-11.1,24.9-24.9,24.9H91.2c-13.7,0-24.9-11.1-24.9-24.9v-106
            c0-2.6,3-4,5-2.4c11.6,9,27,20.5,79.9,58.9c10.9,8,29.4,24.8,47.8,24.7c18.5,0.2,37.3-17,47.8-24.7
            C299.7,186.7,315.1,175.2,326.7,166.2z M199,233.2c12,0.2,29.3-15.1,38.1-21.5c68.8-49.9,74-54.3,89.9-66.7c3-2.3,4.8-6,4.8-9.8
            v-9.8c0-13.7-11.1-24.9-24.9-24.9H91.2c-13.7,0-24.9,11.1-24.9,24.9v9.8c0,3.8,1.8,7.4,4.8,9.8c15.9,12.4,21.1,16.8,89.9,66.7
            C169.7,218,187,233.4,199,233.2L199,233.2z"/>
        </svg>

      <span class="footer-icons-text">Get connected with the Layer5 community</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--slack" href="http://slack.layer5.io/" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px" >
          <path fill="currentColor" stroke="currentColor" stroke-width="3" stroke-miterlimit="10" d="M214.6,76.3c-2.7-0.3-5.7,0.3-8.1,1.2c-10.5,3.6-16.2,15-12.6,25.5l8.4,24.9l-48,16.2l-7.8-24
            c-3.6-10.5-15-16.2-25.5-12.6c-10.5,3.6-16.5,15-12.9,25.5l7.8,23.7L91,165.1c-10.5,3.6-16.2,15.3-12.6,25.8s15,16.2,25.5,12.6
            l24.9-8.1l16.2,47.7l-24,7.8c-10.5,3.6-16.2,15-12.6,25.5c3.6,10.5,15,16.5,25.5,12.9l23.7-7.8l8.4,24.6
            c3.6,10.5,15.3,16.2,25.8,12.6s16.2-15,12.6-25.5l-8.4-24.9l47.7-16.2l7.8,24c3.6,10.5,15,16.2,25.5,12.6
            c10.5-3.6,16.5-15,12.9-25.5l-7.8-23.7l24.9-8.4c10.5-3.6,16.2-15.3,12.6-25.8c-3.6-10.5-15-16.2-25.5-12.6l-24.9,8.4L253,153.4
            l24-7.8c10.5-3.6,16.2-15,12.6-25.5c-3.6-10.5-15-16.5-25.5-12.9l-23.7,7.8L232,90.1C229.3,82,222.4,76.9,214.6,76.3z M214.9,166.3
            l16.2,47.7l-47.7,16.2l-16.2-47.7L214.9,166.3z"/>
        </svg>

      <span class="footer-icons-text">Join the Layer5 Slack</span></a>
    </div>

	<div class="footer-icons">
      <a class="social__link social__link--calender" href="https://bit.ly/2SbrRhe" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="-200 -60 820 740" width="50px" height="50px">
          <path fill="currentColor" stroke="currentColor" stroke-width="3" stroke-miterlimit="10" d="M336 292v24c0 6.6-5.4 12-12 12h-76v76c0
		  6.6-5.4 12-12 12h-24c-6.6 0-12-5.4-12-12v-76h-76c-6.6 0-12-5.4-12-12v-24c0-6.6 5.4-12 12-12h76v-76c0-6.6 5.4-12 12-12h24c6.6 0 12
		  5.4 12 12v76h76c6.6 0 12 5.4 12 12zm112-180v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6
		  5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0
		  3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"/>
        </svg>

        <span class="footer-icons-text">Subscribe to the community calender</span></a>
    </div>

   <div class="footer-icons">
      <a class="social__link social__link--twitter" href="https://twitter.com/layer5" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" d="M153.6,301.6c94.3,0,145.9-78.2,145.9-145.9c0-2.2,0-4.4-0.1-6.6c10-7.2,18.7-16.3,25.6-26.6
          c-9.2,4.1-19.1,6.8-29.5,8.1c10.6-6.3,18.7-16.4,22.6-28.4c-9.9,5.9-20.9,10.1-32.6,12.4c-9.4-10-22.7-16.2-37.4-16.2
          c-28.3,0-51.3,23-51.3,51.3c0,4,0.5,7.9,1.3,11.7c-42.6-2.1-80.4-22.6-105.7-53.6c-4.4,7.6-6.9,16.4-6.9,25.8
          c0,17.8,9.1,33.5,22.8,42.7c-8.4-0.3-16.3-2.6-23.2-6.4c0,0.2,0,0.4,0,0.7c0,24.8,17.7,45.6,41.1,50.3c-4.3,1.2-8.8,1.8-13.5,1.8
          c-3.3,0-6.5-0.3-9.6-0.9c6.5,20.4,25.5,35.2,47.9,35.6c-17.6,13.8-39.7,22-63.7,22c-4.1,0-8.2-0.2-12.2-0.7
          C97.7,293.1,124.7,301.6,153.6,301.6"/>
        </svg>

      <span class="footer-icons-text">Follow Layer5 on Twitter</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--github" href="https://github.com/layer5io" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M203.9,60c-75.6,0-137,61.3-137,137c0,60.5,39.2,111.9,93.7,130c6.8,1.3,9.3-3,9.3-6.6c0-3.3-0.1-11.9-0.2-23.3
         c-38.1,8.3-46.1-18.4-46.1-18.4c-6.2-15.8-15.2-20-15.2-20c-12.4-8.5,0.9-8.3,0.9-8.3c13.7,1,21,14.1,21,14.1
         c12.2,20.9,32.1,14.9,39.9,11.4c1.2-8.9,4.8-14.9,8.7-18.3c-30.4-3.5-62.4-15.2-62.4-67.7c0-15,5.3-27.2,14.1-36.8
         c-1.4-3.5-6.1-17.4,1.3-36.3c0,0,11.5-3.7,37.7,14c10.9-3,22.6-4.6,34.3-4.6c11.6,0.1,23.4,1.6,34.3,4.6c26.2-17.7,37.6-14,37.6-14
         c7.5,18.9,2.8,32.8,1.4,36.3c8.8,9.6,14.1,21.8,14.1,36.8c0,52.6-32,64.2-62.5,67.6c4.9,4.2,9.3,12.6,9.3,25.4
         c0,18.3-0.2,33.1-0.2,37.6c0,3.7,2.5,7.9,9.4,6.6c54.4-18.2,93.6-69.5,93.6-130C340.9,121.3,279.5,60,203.9,60z"/>
        </svg>

      <span class="footer-icons-text">Contribute to Layer5 projects</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--youtube" href="https://www.youtube.com/playlist?list=PL3A-A6hPO2IMPPqVjuzgqNU5xwnFFn3n0" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" d="M358.3,119.9c-3.8-14.3-15-25.6-29.2-29.4C303.3,83.6,200,83.6,200,83.6s-103.3,0-129.1,6.9
           c-14.2,3.8-25.4,15.1-29.2,29.4c-6.9,25.9-6.9,80.1-6.9,80.1s0,54.1,6.9,80.1c3.8,14.3,15,25.6,29.2,29.4c25.8,7,129.1,7,129.1,7
           s103.3,0,129.1-7c14.2-3.8,25.4-15.1,29.2-29.4c6.9-25.9,6.9-80.1,6.9-80.1S365.2,145.9,358.3,119.9z"/>
           <polygon fill="#3C494F" points="166.2,249.1 252.6,200 166.2,150.9 "/>
        </svg>
      <span class="footer-icons-text">Watch community meeting recordings</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--docker" href="https://hub.docker.com/u/layer5/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" stroke="#FFFFFF" stroke-miterlimit="10" d="M369.8,159.9c-11.4-6.7-26.6-7.5-39.4-3.7c-1.6-13.8-10.6-25.8-21.3-34.3l-4.3-3.5l-3.7,4.3
           c-7.2,8.3-9.3,22.1-8.3,32.7c0.8,7.7,3.2,15.7,8,22.1c-3.7,2.1-7.7,5.1-11.4,6.4c-7.5,2.7-15.7,5.3-23.7,5.3h-17.8v-37.5h-34.6
           V85.1h-39.9v31.9h-66.5v34.6H72.2v37.3H42.4l-0.5,4c-1.3,17,0.8,33.5,8,49.2l2.9,5.9l0.3,0.5c21,35.7,57.8,50.6,97.9,50.6
           c77.7,0,141.9-34.9,171.1-108.1c19.7,1.1,39.9-4.8,49.5-23.7l2.4-4.8L369.8,159.9L369.8,159.9z M112.1,125h26.6v29.3h-26.6V125z
            M147,242.7c0,4.5-3.7,8.3-8.3,8.3s-8.3-3.7-8.3-8.3c0-4.5,3.7-8.3,8.3-8.3C143.3,234.7,147,238.2,147,242.7z M112.1,159.6h26.6
           v29.3h-26.6C112.1,188.9,112.1,159.6,112.1,159.6z M77.5,159.6h29.3v29.3H77.5V159.6z M151.3,293.3c-42.1-0.3-64.7-14.4-83.3-33
           c5.6,0.3,10.9,0.5,15.7,0.5c4.3,0,8.5,0,12.5-0.3c10.4-0.5,19.4-1.9,26.9-4c6.1,14.1,17.3,27.1,37.3,36.7H151.3z M173.4,188.9
           h-29.3v-29.3h29.3V188.9z M173.4,154.3h-29.3V125h29.3V154.3z M208,188.9h-29.3v-29.3H208V188.9z M208,154.3h-29.3V125H208V154.3z
            M208,119.7h-29.3V90.4H208V119.7z M242.6,188.9h-29.3v-29.3h29.3V188.9z M140.9,237.4c-0.5-0.3-1.3-0.5-2.1-0.5
           c-3.2,0-5.9,2.7-5.9,5.9c0,3.2,2.7,5.9,5.9,5.9c3.2,0,5.9-2.7,5.9-5.9c0-0.8-0.3-1.6-0.5-2.1c-0.5,0.8-1.1,1.3-2.1,1.3
           c-1.3,0-2.4-1.1-2.4-2.4C139.8,238.4,140.4,237.6,140.9,237.4z"/>
        </svg>
      <span class="footer-icons-text">Access Docker images for Layer5 projects</span></a>
    </div>
  </div>
    </p>
  <!-- meshery-custom-end -->
      </div>
    </div>
  </div>
</footer>

<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>

<script type="text/javascript" src="/v0.4/assets/js/lightbox.js"></script>
<link rel="stylesheet" href="/v0.4/assets/css/lightbox.css">

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/v0.4/assets/js/main.js"></script>

    <script async src='https://www.google-analytics.com/analytics.js'></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-00000000-0', 'auto');
	ga('send', 'pageview');
}
</script>

  </body>
</html>
<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

<script>
$(document).ready(function() {

    var toc = $('#TOC');

    // Select each header
    sections = $('.td-content h1');
        $.each(sections, function(idx, v) {
            section = $(v);
            var div_id = $(section).attr('id');
            if(!section.hasClass('noTOC')){
               var div_text = section.text().split('¶')[0];
              var parent = $("#" + div_id)
              var content = '<li id="link_' + div_id + '" class="md-nav__item"><a class="md-nav__link" href="#' + div_id + '" title="' + div_text +'">' + div_text +'</a></li>';
              $(toc).append(content);
            }

            // Add section code to subnavigation
            var children = $('<nav class="md-nav"><ul class="md-nav__list"></nav></ul>')
            var contenders = $("#" + div_id).nextUntil("h1");
            $.each(contenders, function(idx, contender){
               if( !$(contender).hasClass("noTOC") && ($(contender).is('h2') || $(contender).is('h3')) ) {
                   var contender_id = $(contender).attr('id');
                   var contender_text = $(contender).text().split('¶')[0];
                   var content = '<li class="md-nav__item"><a class="md-nav__link" href="#' + contender_id + '" title="' + contender_text +'">' + contender_text +'</a></li>';
                   children.append(content);
                }
             })
             $("#link_" + div_id).append(children);
        });
    });
</script>