<!DOCTYPE html>
<html lang="en" class="no-js">
  <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>
  <head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.55.6" />

<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">

<link rel="alternate" type="application/rss&#43;xml" href="/v0.4/index.xml">

<link rel="shortcut icon" href="/v0.4/assets/favicons/favicon.ico" >
<link rel="apple-touch-icon" href="/v0.4/assets/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="36x36">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="48x48">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="72x72">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="96x196">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="/v0.4/assets/favicons/android-192x192.png"sizes="192x192">

<title>Documentation</title>
<meta property="og:title" content="Documentation" />
<meta property="og:description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://localhost:4000" />
<meta property="og:site_name" content="http://localhost:4000" />

<meta itemprop="name" content="Documentation">
<meta itemprop="description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Documentation"/>
<meta name="twitter:description" content="Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.
"/>

<link rel="stylesheet" href="/v0.4/assets/css/main.css">
<link rel="stylesheet" href="/v0.4/assets/css/palette.css">
<link rel="stylesheet" href="/v0.4/assets/css/anchorjs.css">
<link rel="stylesheet" href="/v0.4/assets/css/sass.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css">

<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>
  <!-- Anchorjs included for adding hover anchor links to headings -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js"></script>
  <script>  
  $(function() {
  /** AnchorJS options and selector */  
   anchors.options = {
      visible : 'hover',
      placement: 'left'
   };
   anchors.add('h1, h2, h3, h4, h5');
   });
   </script>
</head>
<style>

</style>
  <body class="td-section">
    <header>
  <nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
    <a class="navbar-brand" href="/v0.4/">
      <div class="navbar-logo">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 279.49 51.83"><defs><style>.cls-1{fill:#00d3a9}.cls-2{fill:#00b39f}.cls-3{fill:#fff}</style></defs><title>Asset 14</title><g id="Layer_2" data-name="Layer 2"><g id="Layer_1-2" data-name="Layer 1"><polygon points="26.68 12.21 26.68 24.59 37.4 18.38 26.68 12.21" class="cls-1"/><polygon points="26.68 27.18 26.68 39.62 37.5 33.43 26.68 27.18" class="cls-1"/><polygon points="25.13 24.51 25.13 12.32 14.54 18.39 25.13 24.51" class="cls-2"/><path d="M3.88,39.58a26,26,0,0,0,8.22,8.27v-13Z" class="cls-2"/><polygon points="25.13 39.56 25.13 27.27 14.51 33.42 25.13 39.56" class="cls-2"/><polygon points="13.64 47.07 24.4 40.92 13.64 34.7 13.64 47.07" class="cls-1"/><polygon points="38.24 47.14 38.24 34.79 27.5 40.93 38.24 47.14" class="cls-2"/><path d="M48.76,38.14A25.71,25.71,0,0,0,51.8,27L40.6,33.44Z" class="cls-2"/><polygon points="39.78 32.13 50.58 25.95 39.78 19.75 39.78 32.13" class="cls-1"/><polygon points="38.24 17.08 38.24 4.81 27.55 10.94 38.24 17.08" class="cls-2"/><polygon points="38.24 32.07 38.24 19.68 27.52 25.89 38.24 32.07" class="cls-2"/><polygon points="25.9 51.83 25.91 51.83 25.9 51.83 25.9 51.83" class="cls-2"/><polygon points="13.64 19.66 13.64 32.14 24.43 25.89 13.64 19.66" class="cls-1"/><path d="M25.13,0A25.75,25.75,0,0,0,13.75,3L25.13,9.55Z" class="cls-2"/><polygon points="13.64 4.72 13.64 17.13 24.44 10.93 13.64 4.72" class="cls-1"/><path d="M12.1,4a26,26,0,0,0-8.22,8.27L12.1,17Z" class="cls-2"/><path d="M38.17,3.07A25.8,25.8,0,0,0,26.68,0V9.65Z" class="cls-1"/><path d="M0,26.82A25.76,25.76,0,0,0,3.1,38.24l8.32-4.82Z" class="cls-1"/><path d="M3.1,13.58A25.67,25.67,0,0,0,0,24.94l11.44-6.55Z" class="cls-1"/><path d="M13.73,48.8a25.81,25.81,0,0,0,11.4,3V42.28Z" class="cls-2"/><path d="M48,12.28A25.91,25.91,0,0,0,39.78,4V17Z" class="cls-1"/><path d="M39.78,47.8A26,26,0,0,0,48,39.48l-8.21-4.73Z" class="cls-1"/><path d="M51.8,24.88a25.84,25.84,0,0,0-3.07-11.27l-8.24,4.77Z" class="cls-2"/><path d="M26.68,51.82a25.81,25.81,0,0,0,11.37-3L26.68,42.24Z" class="cls-1"/><polygon points="12.1 32.03 12.1 19.79 1.47 25.88 12.1 32.03" class="cls-2"/><polygon points="197.13 19 197.13 20.13 197.13 25.45 197.13 31.94 197.13 41.41 222.35 41.41 222.35 36.09 202.45 36.09 202.45 31.94 202.45 30.77 217.74 30.77 217.74 25.45 202.45 25.45 202.45 20.13 222.35 20.13 222.35 14.81 197.13 14.81 197.13 19" class="cls-3"/><polygon points="100.14 19 100.14 20.13 100.14 25.45 100.14 31.94 100.14 41.41 125.35 41.41 125.35 36.09 105.46 36.09 105.46 31.94 105.46 30.77 120.74 30.77 120.74 25.45 105.46 25.45 105.46 20.13 125.35 20.13 125.35 14.81 100.14 14.81 100.14 19" class="cls-3"/><path d="M160.26,34.46a6.61,6.61,0,0,1-.55,2.69,7,7,0,0,1-1.51,2.22A7.34,7.34,0,0,1,156,40.86a6.7,6.7,0,0,1-2.71.55H128.38v-5.6h24.89a1.35,1.35,0,0,0,1.35-1.35V32.29A1.33,1.33,0,0,0,153.27,31H135.36a6.78,6.78,0,0,1-2.69-.55,7.19,7.19,0,0,1-2.24-1.51,7,7,0,0,1-1.5-2.23,6.62,6.62,0,0,1-.55-2.7V21.8a6.75,6.75,0,0,1,.55-2.72,7,7,0,0,1,1.5-2.21,7.19,7.19,0,0,1,2.24-1.51,6.61,6.61,0,0,1,2.69-.55h24.9v5.64h-24.9a1.27,1.27,0,0,0-1,.39,1.31,1.31,0,0,0-.4,1V24a1.31,1.31,0,0,0,.4,1,1.27,1.27,0,0,0,1,.39h17.91a6.7,6.7,0,0,1,2.71.55,7.11,7.11,0,0,1,3.73,3.72,6.74,6.74,0,0,1,.55,2.71Z" class="cls-3"/><path d="M193.81,41.41h-5.07V31H169V41.41h-5.08V25.31h24.86V14.81h5.07ZM169,22.81h-5.08v-8H169Z" class="cls-3"/><polygon points="266.19 24.12 259.55 14.81 252.9 14.81 263.54 30.77 263.54 41.41 268.86 41.41 268.86 30.77 279.49 14.81 272.93 14.81 266.19 24.12" class="cls-3"/><path d="M231.4,19.88H245v5.53h-11v5.08h2.52l9.65,10.92h6.57l-9.65-10.92h3.76A4.13,4.13,0,0,0,251,26.36V18.94a4.13,4.13,0,0,0-4.13-4.13H226.19v26.6h5.32Z" class="cls-3"/><path d="M96.05,41.41H90.41V22a1.38,1.38,0,0,0-.13-.6,1.56,1.56,0,0,0-.33-.5,1.77,1.77,0,0,0-.5-.34,1.53,1.53,0,0,0-.6-.12H62.78V14.81H88.85a6.88,6.88,0,0,1,2.78.57,7.08,7.08,0,0,1,3.85,3.85A6.88,6.88,0,0,1,96.05,22Zm-27.63,0H62.78v-21l5.64-1.55Zm13.8,0H76.58v-18h5.64Z" class="cls-3"/></g></g></svg><span class="font-weight-bold" style="vertical-align: bottom"
          >Documentation</span
        >
      </div>
    </a>
    <div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
      <ul class="navbar-nav mt-2 mt-lg-0">
        <!-- 
			<li class="nav-item mr-4 mb-2 mb-lg-0">
        <a class="nav-link" href="https://github.com/layer5io/meshery" target="_blank"><span>GitHub</span></a>
      </li>  -->

        <!-- Internal links -->
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="/v0.4/installation/quick-start"
            ><span>Quick Start</span></a
          >
        </li>
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="/v0.4/installation/platforms"
            ><span>All Platforms</span></a
          >
        </li>
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="https://meshery.io"
            ><span>Project</span></a
          >
        </li>
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="http://slack.layer5.io"
            ><span>Slack</span></a
          >
        </li>
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="https://github.com/layer5io/meshery"
            ><span>GitHub</span></a
          >
        </li>
        
        <li class="nav-item mr-4 mb-2 mb-lg-0">
          <a
            class="nav-link"
            href="/v0.4/es"
            ><span>ğŸ‡²ğŸ‡½ EspaÃ±ol</span></a
          >
        </li>
        
      </ul>
    </div>
            <!--Version Selector -->

            <select onchange="window.location=this.value" class="appearance-none flex-1 w-full px-0 py-1 placeholder-gray-900 tracking-wide focus:outline-none version-selector" name="versioningSelection" id="versioningSelection">
              <!-- <option value="">Versions</option> -->
              
    
              <!-- we get the version selected, and put it to the right option  --><option  value="/v0.4" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>v0.4</span>
              </option>
              <!-- we get the version selected, and put it to the right option  --><option  value="/" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>latest</span>
              </option>
              <!-- we get the version selected, and put it to the right option  --><option  value="/v0.5" class="nav-item mr-4 mb-2 mb-lg-0 text-black">
                <span>v0.5</span>
              </option>
              
              </select>
        
            </ul>
        </div>

    <!--Search Bar
    <div class="navbar-nav d-none d-lg-block"><input type="search" class="form-control td-search-input" placeholder="&#xf002 Search this siteâ€¦" aria-label="Search this siteâ€¦" autocomplete="off"></div>-->

    <!-- meshery-custom-begin

	<div class="navbar-nav d-none d-lg-block">
          <a class="gh-source" data-gh-source="github" href="https://github.com/layer5io/meshery" title="Go to repository" data-md-state="done">
          <div class="gh-source__repository">
            <i class="fab fa fa-github fa-2x" style='padding-right:20px; float:left; margin-top:5px'></i>
            layer5io/meshery
          <ul class="gh-source__facts"><li class="gh-source__fact" id='stars'></li><li id="forks" class="gh-source__fact"></li></ul></div></a>
        </div>
      </div>

meshery-custom-end -->
  </nav>
</header>

<!-- meshery-custom-begin

<script>
$(document).ready(function() {
  var url = "https://api.github.com/search/repositories?q=layer5io/meshery";
  fetch(url, { 
      headers: {"Accept":"application/vnd.github.preview"}
  }).then(function(e) {
    return e.json()
  }).then(function(r) {
     console.log(r.items[0])
     stars = r.items[0]['stargazers_count']
     forks = r.items[0]['forks_count']
     $('#stars').text(stars + " Stars")
     $('#forks').text(forks + " Forks")
  });
});
</script>

meshery-custom-end -->

    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none">
          <div id="td-sidebar-menu" class="td-sidebar__inner">  
  <form class="td-sidebar__search d-flex align-items-center">
 <input type="search" class="form-control td-search-input fas fa-search" placeholder="&#xf002" aria-label="Search this siteâ€¦" autocomplete="off">
    <button class="btn btn-link td-sidebar__toggle d-md-none p-0 ml-3 fas fa-bars" type="button" data-toggle="collapse" data-target="#td-section-nav" aria-controls="td-docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    </button>
  </form>  

  <nav class="collapse td-sidebar-nav pt-2 pl-4" id="td-section-nav">
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Documentation</a>
    </li>
    
      <ul>
        <li class="collapse show" id="documentation">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/overview" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Overview</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/project" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Project</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/installation/quick-start" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Quick Start</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/installation/platforms" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Supported Platforms</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/concepts" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Concepts</a>
    </li>
    
      <ul>
        <li class="collapse show" id="concepts">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/concepts/architecture" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Architecture</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/concepts/architecture/adapters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Adapters</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/functionality" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Functionality</a>
    </li>
    
      <ul>
        <li class="collapse show" id="functionality">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/functionality/lifecycle-management" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Lifecycle Management</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/functionality/performance-management" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Performance Management</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/functionality/service-mesh-interface" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Service Mesh Interface (SMI)</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/service-meshes" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Service Meshes</a>
    </li>
    
      <ul>
        <li class="collapse show" id="service-meshes">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/app-mesh" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">App Mesh</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/cpx" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Citrix Service Mesh</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/consul" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Consul</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/istio" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Istio</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/kuma" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Kuma</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/linkerd" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Linkerd</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/nsm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Network Service Mesh</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/nginx-sm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">NGINX Service Mesh</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/octarine" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Octarine</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/osm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Open Service Mesh</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/tanzu-sm" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Tanzu</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/service-meshes/adapters/traefik-mesh" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Traefik Mesh</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/guides" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Guides</a>
    </li>
    
      <ul>
        <li class="collapse show" id="guides">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/sample-apps" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Deploying Sample Applications</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/meshery-metrics" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Integrating Prometheus and Grafana</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/upgrade" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Upgrading Meshery</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/mesheryctl" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Using mesheryctl</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/guides/multiple-adapters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Using Multiple Meshery Adapters</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/extensibility" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Extensibility</a>
    </li>
    
      <ul>
        <li class="collapse show" id="extensibility">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/extensibility/adapters" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Service Mesh Adapters</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/extensibility/load-generators" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Load Generators</a>
              </li>
              
            
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/extensibility/providers" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">Providers</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  <ul class="td-sidebar-nav__section pr-md-3">
    
    
    <li class="td-sidebar-nav__section-title">
      <a  href="/v0.4/reference" class="align-left pl-0 pr-2 active td-sidebar-link td-sidebar-link__section">Reference</a>
    </li>
    
      <ul>
        <li class="collapse show" id="reference">
            <ul class="td-sidebar-nav__section pr-md-3">
              
              <li class="td-sidebar-nav__section-title">
                <a href="/v0.4/reference/mesheryctl" class="align-left pl-0 pr-2 td-sidebar-link td-sidebar-link__section">mesheryctl Command Reference</a>
              </li>
              
            
          </ul>
      </ul>  
        
  </ul>
  
  </nav>
</div>
          </div>
          <div class="d-none d-xl-block col-xl-2 td-toc d-print-none">
              <div class="td-page-meta ml-2 pb-1 pt-2 mb-0">
                  <strong>Tools</strong>
<a href="https://github.com/layer5io/meshery/issues/new?assignees=&labels=area/docs&template=documentation.md&title=&#91;Docs&#93;" target="_blank"><i class="fab fa-github fa-fw"></i> Create doc issue</a>
<a href="https://github.com/layer5io/meshery/blob/master/docs/pages/search.html" target="_blank"><i class="fa fa-edit fa-fw"></i> Edit this page</a>
<strong>Contents</strong>


<!-- this will parse through the header fields and add a button to open
     an issue / ask a question on Github. The editable field should be in
     the post frontend matter, and refer to the label to open the issue for -->
     

              </div>
              <nav id="TableOfContents"><ul>
              <li><ul id="TOC">
                <!-- Links will be appended here-->
              </ul></li>
              </ul></nav>
          </div>
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            <nav aria-label="breadcrumb" class="d-none d-md-block d-print-none">
	      <ol class="breadcrumb spb-1">
                <li class="breadcrumb-item active" aria-current="page">
      <!-- meshery-custom-begin -->
        <div id="breadcrumbs">

<a href="/v0.4/">home</a>

  
    / 
  

</div>

<!-- <a href="http://idratherbewriting.com" class="noCrossRef productSubtitle"> Home </a> > <a class="noCrossRef productSubtitle" href="http://localhost:4000">Learn API Doc</a> > search.html -->

	      <!-- <a href="/v0.4/search/"></a> -->
		  <!-- meshery-custom-end -->
                </li>
	      </ol>
           </nav>
           <div class="td-content">
            
            <h1></h1>
            
	           <input class="form-control td-search-input fa fa-search" type="search" name="q" id="search-input" placeholder="&#xf002 Search this siteâ€¦"  style="margin-top:5px" autofocus>
<i style="color:white; margin-right:8px; margin-left:5px" class="fa fa-search"></i>

<p><span id="search-process">Loading</span> results <span id="search-query-container" style="display: none;">for "<strong id="search-query"></strong>"</span></p>

<ul id="search-results"></ul>

<script>
	window.data = {
		
		
				
		
				
					
					
					"es-project-contributing-flow": {
						"id": "es-project-contributing-flow",
						"title": "Contribuir Flujo",
						"categories": "",
						"url": " /es/project/contributing-flow",
						"content": "Trabajando por Fork\n\nSimplemente dirÃ­gete a la pÃ¡gina de GitHub y haz clic en el botÃ³n â€œForkâ€. Es asÃ­ de simple. Una vez que hayas hecho eso, puedes usar tu cliente git favorito para clonar tu repositorio o simplemente dirigirse directamente a la lÃ­nea de comando:\n\nClona tu fork en tu mÃ¡quina local\n\ngit clone git@github.com:USERNAME/FORKED-PROJECT.git\n\n\nMantener Tu Fork Actualizado\nSi bien este no es un paso necesario, si planeas hacer algo mÃ¡s que una pequeÃ±a soluciÃ³n rÃ¡pida, querrÃ¡s asegurarte de mantener tu fork actualizado rastreando el repositorio â€œupstreamâ€ original al que hiciste â€œforkâ€. Para hacer esto, deberÃ¡s agregar un remoto:\n\nAgregar repositorio â€˜upstreamâ€™ a la lista de remotos\n\ngit remote add upstream https://github.com/layer5io/meshery.git\n\n\n(â€œmesheryâ€ se usa como repositorio de ejemplo. AsegÃºrate de hacer referencia al repositorio actual al que estÃ¡ contribuyendo, por ejemplo, â€œmeshery-linkerdâ€).\n\nVerifica el nuevo repositorio remoto llamado â€˜upstreamâ€™\n\ngit remote -v\n\n\nSiempre que quieras actualizar tu fork con los Ãºltimos cambios de â€˜upstreamâ€™, primero deberÃ¡s buscar las ramas del repositorio â€˜upstreamâ€™ y los Ãºltimos â€œcommitsâ€ para llevarlos a tu repositorio:\n\nObtener desde el remoto â€˜upstreamâ€™\n\ngit fetch upstream\n\n\nVer todas las ramas, incluidas las de â€˜upstreamâ€™\n\ngit branch -va\n\n\nAhora, revisa tu rama â€œmasterâ€ y combina la rama â€œmasterâ€ del repositorio â€˜upstreamâ€™:\n\nHaz â€œcheckoutâ€ a tu rama â€œmasterâ€ y haz â€œmergeâ€ de â€˜upstreamâ€™\n\ngit checkout master\ngit merge upstream/master\n\n\nSi no hay â€œcommitsâ€ Ãºnicos en la rama â€œmasterâ€ local, git simplemente realizarÃ¡ un â€œfast-forwardâ€. Sin embargo, si has realizado cambios en â€œmasterâ€ (en la gran mayorÃ­a de los casos, probablemente no deberÃ­as hacerlo), consulta la siguiente secciÃ³n, es posible que tengas que lidiar con conflictos. Al hacerlo, ten cuidado de respetar los cambios realizados anteriormente.\n\nAhora, tu rama â€œmasterâ€ local estÃ¡ actualizada con todo lo modificado en â€˜upstreamâ€™.\n\nCrear una â€œBranchâ€ (haciendo tu trabajo)\nSiempre que comiences a trabajar en una nueva funciÃ³n o correcciÃ³n de â€œbugsâ€, es importante que crees una nueva rama. No solo es un flujo de trabajo de git adecuado, sino que tambiÃ©n mantiene tus cambios organizados y separados de la rama â€œmasterâ€ para que puedas enviar y administrar fÃ¡cilmente mÃºltiples â€œpull requestsâ€ para cada tarea que completes.\n\nPara crear una nueva rama y comenzar a trabajar en ella, realiza el siguiente flujo.\n\nConsulta la rama â€œmasterâ€: quieres que tu nueva rama provenga de la rama â€œmasterâ€.\n\ngit checkout master\n\n\nCrea una nueva rama (dale a tu rama su propio nombre informativo simple)\n\nPara mejoras, utiliza feature/tu_nombre/issue# o feature/tu_nombre/nombre_del_feature\n\nPara â€œbugsâ€ usa bug/tu_nombre/issue# o bug/tu_nombre/nombre_del_bug\n\ngit branch feature/jdoe/567\n\n\nCambia a tu nueva rama\n\ngit checkout feature/jdoe/567\n\n\nAhora, ve a la ciudad hackeando y haciendo los cambios que quieras.\n\nEnviar tus cambios (un â€œPull Requestâ€)\n\nAntes de enviar tu â€œpull requestâ€, es posible que quieras hacer algunas cosas para limpiar tu rama y hacer que sea lo mÃ¡s simple posible para que el â€œmaintainerâ€ del repositorio original pruebe, acepte y haga â€œmergeâ€ de tu trabajo.\n\nEn el tiempo que has estado trabajando en tus cambios, si se han hecho â€œcommitsâ€ en la rama â€œmasterâ€ â€˜upstreamâ€™, deberÃ¡s hacer â€œrebaseâ€ a tu rama de desarrollo para que al hacerle â€œmergeâ€ sea un â€œfast-forwardâ€ simple que no requiera ninguna trabajo de resoluciÃ³n de conflictos.\n\nObten los cambios de â€œmasterâ€ â€˜upstreamâ€™ y haz â€œmergeâ€ con la rama â€œmasterâ€ de tu repositorio\n\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\n\n\nSi hubo nuevos â€œcommitsâ€, haz â€œrebaseâ€ a tu rama de desarrollo\n\ngit checkout feature/jdoe/567\ngit rebase master\n\n\nAhora, puede ser deseable reducir algunos de tus â€œcommitsâ€ mÃ¡s pequeÃ±os al juntarlos en una pequeÃ±a cantidad de â€œcommitsâ€ mÃ¡s grandes y cohesivos. Puedes hacer esto con un â€œrebaseâ€ interactivo:\n\nHaz â€œrebaseâ€ a todos tus â€œcommitsâ€ en tu rama de desarrollo\n\ngit checkout\ngit rebase -i master\n\n\nEsto abrirÃ¡ un editor de texto donde puedes especificar que â€œcommitsâ€ aplastar.\n\nEntrega\n\nUna vez que hayas hecho tus â€œcommitsâ€ y enviado todos tus cambios a GitHub, ve a la pÃ¡gina de tu â€œforkâ€ en GitHub, selecciona tu rama de desarrollo y haz clic en el botÃ³n de â€œpull requestâ€. Si necesitas realizar algÃºn ajuste en tu â€œpull requestâ€, simplemente envÃ­a las actualizaciones a GitHub. Tu â€œpull requestâ€ rastrearÃ¡ automÃ¡ticamente los cambios en tu rama de desarrollo y se actualizarÃ¡."
					}
					
				
		
				
					,
					
					"project-faq": {
						"id": "project-faq",
						"title": "FAQ",
						"categories": "",
						"url": " /project/faq",
						"content": "Question: Why was Meshery created?\n\nAnswer: As an open source, vendor neutral project, Meshery was created out the necessity to enable service mesh adopters to overcome the challenge of complex virtual networking; to come to expect more from their infrastructure; to enable the world to understand and operate any service mesh with confidence.\n\n\nDon't find an answer to your question here? Ask in the #support channel in the Layer5 Slack.\n\nWhat is the difference between make run-local and mesheryctl system start? Do they both run Meshery on my local machine?\n\nAnswer: Yes, both of them do run Meshery on your local machine. make run local builds Meshery from source and runs it on your local OS, while mesheryctl system start runs Meshery as a set of containers in Docker on your local machine."
					}
					
				
		
				
					,
					
					"concepts-architecture-adapters": {
						"id": "concepts-architecture-adapters",
						"title": "Adapters",
						"categories": "",
						"url": " /concepts/architecture/adapters",
						"content": "As the multi-mesh manager, Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n\nWhat are Meshery Adapters?\n\nAdapters allow Meshery to interface with the different service meshes, exposing their differentiated value to users.\n\nMeshery has adapters for managing the following service meshes.\n\n\n  \n    \n      Adapter Status\n      Service Mesh\n      Service Mesh Version\n      Port\n    \n  \n  \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Consul\n      v1.8.2\n      10002/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Istio\n      v1.8.1\n      10000/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Linkerd\n      v2.5.0\n      10001/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Open Service Mesh\n      v0.5.0\n      10009/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Octarine\n      v1.0\n      10003/tcp\n    \n    \n      stable\n       Meshery Adapter for Meshery Adapter for Network Service Mesh\n      v0.2.1\n      10004/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Kuma\n      v1.0\n      10007/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Citrix Service Mesh\n      1.0\n      10008/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for Traefik Mesh\n      v1.0\n      10006/tcp\n    \n    \n      beta\n       Meshery Adapter for Meshery Adapter for NGINX Service Mesh\n      v0.6.0\n      10010/tcp\n    \n    \n      alpha\n       Meshery Adapter for Meshery Adapter for Tanzu Service Mesh\n      pre-GA\n      10010/tcp\n    \n    \n      alpha\n       Meshery Adapter for Meshery Adapter for App Mesh\n      v0.1.0\n      10005/tcp\n    \n  \n\n\nAdapter FAQs\n\nIs each service mesh adapter made equal?\nNo, different service mesh adapters are written to expose the unique value of each service mesh. Consequently, they are not equally capable just as each service mesh is not equally capable as the other.\n\nAdapters have a set of operations which are grouped based on predefined operation types. See the extensibility page for more details on adapter operations.\n\nHow can I create a new adapter?\n\nSee the extensibility documentation for details on how new Meshery adapters are made.\n\nCan I run more than one instance of the same Meshery adapter?\nThe default configuration of a Meshery deployment includes one instance of each of the Meshery adapters (that have reached a stable version status). You may choose to run multiple instances of the same type of Meshery adapter; e.g. two instances of the meshery-istio adapter. To do so, modify ~/.meshery/meshery.yaml to include multiple copies of the given adapter.\n\nSee the â€œMultiple Adaptersâ€ guide for more information."
					}
					
				
		
				
					,
					
					"extensibility-adapters": {
						"id": "extensibility-adapters",
						"title": "Extensibility: Service Mesh Adapters",
						"categories": "",
						"url": " /extensibility/adapters",
						"content": "What are Meshery Adapters?\n\nAdapters allow Meshery to interface with the different service meshes. Review the list of all available service mesh adapters. See the Meshery Architecture diagrams for visuals on how adapters relate to other Meshery components.\n\nMeshery upholds the following guiding principles for adapter design:\n\n\n  Adapters allow Meshery to interface with the different service meshes, exposing their differentiated value to users.\n    \n      Service mesh projects should be encouraged to maintain their own adapters. Allowing them to expose their differentiated capabilities encourages this.\n    \n  \n  Adapters should avoid wheel reinvention, but seek to leverage the functionality provided by service meshes under management.\n    \n      This both reduces sustaining costs and improves reliability.\n    \n  \n\n\nAdapter Capabilities\nMeshery communicates with adapters over grpc. Adapters establish communication with the service mesh. Adapters have a predefined set of operations which are grouped based on predefined operation types.\n\nThe predefined operation types are:\n\n\n  Install\n  Sample application\n  Config\n  Validate\n  Custom\n\n\nHow to create new adapter?\n\nMeshery uses adapters to manage and interact with different service meshes. Meshery adapters are written in Go. Whether you are creating a new adapter or modifying an existing adapter, be sure to read the Meshery Adapters design specification.\n\nTip: The Meshery Adapter for Istio is a good reference adapter to use as an example of a Meshery Adapter.\n\nMeshery Adapter Codebase Overview\n\nCommon libraries are used to avoid code duplication and apply DRY.\n\nMeshKit\n\nThe code hierarchy is pluggable and independent from one another. There can be N number of packages depending upon the use case.\n\n  errors/ - holds the implementations and the error handlers and error codes which are used across projects.\n  logger/ - holds the implementations of logging handler and custom attributes to add if any.\n  utils/ - holds all the utility functions that are specific to meshery projects and are to be used generically across all of them.\n  tracing/ - holds the implementations of tracing handlers with different tracing providers like jaeger,newrelic, etc.\n\n\nEach package inside a meshkit is a handler interface implementation, the implementation could be from any third-party packages or the go-kit.\n\nMeshery Adapter Libary\n\nThis section contains a high level overview of the meshery-adapter-library, its purpose and architecture. For details, the reader is referred to the documentation and the code in the repository.\n\nThe main purpose of the meshery-adapter-library is to:\n\n  provide a set of interfaces, some with default implementations, to be used and extended by adapters.\n  implement common cross cutting concerns like logging, errors, and tracing\n  provide a mini framework implementing the gRPC server that allows plugging in the mesh specific configuration and - operations implemented in the adapters.\n  provide middleware extension points\n\n\nOverview and Usage\nThe library consists of interfaces and default implementations for the main and common functionality of an adapter. It also provides a mini-framework that runs the gRPC adapter service, calling the functions of handlers injected by the adapter code. This is represented in an UML-ish style in the figure below. The library is used in all of Mesheryâ€™s adapters.\n\nMeshery Adapter for XXX Service Mesh\n\nDevelopment Process\nWith the CONTRIBUTING.md in mind, understand that development follows the usual fork-and-pull request workflow described here, see also GitHub Process. On forking GitHub deactivates all workflows. It is safe and good practice to activate them such that the code is validated on each push. This requires that branches filter for â€œon pushâ€ is set to â€˜**â€™ to be triggered also on branches containing â€˜/â€™  in their name.  The actions are parameterized using secrets (see Build &amp; Release Strategy). The Docker image is only built and pushed to Docker Hub if a tag is pushed and the corresponding authentication information is configured. The only secret that should be set in each fork is GO_VERSION, specified in Build &amp; Release Strategy, otherwise, the corresponding actionâ€™s default version is used.\n\nEach commit has to be signed off, see Contributing Overview.\n\nRunning an adapter as a container\nTesting your local changes running as a container can be accomplished in two ways:\n\n\n  Define the adapterâ€™s address in the UI: Unless the running container is named as specified in the docker-run target in the Makefile, the container has to be removed manually first. Then, run make docker followed by make docker-run. Then, connect to the adapter in the UI in â€œSettings&gt;Service Meshesâ€ using localhost:&lt;port&gt; if the meshery server is running as a binary, or : if it is running as a docker container.\n  Using mesheryctl: In ~/.meshery/meshery.yaml, change the tag specifying the image of the adapter to â€œlatestâ€. Run make docker, followed by mesheryctl system start --skip-update. This assumes mesheryctl system start has been executed at least once before.\n\n\nRunning an adapter as a process\n\nAnother way to test your local changes is to run the adapter as a process. To do this, clone the meshery repository, and start meshery using make run-local-cloud. Start the adapter from your IDE, or by executing make run. Then, in the meshery interface, add the adapter using â€œlocalhost:â€."
					}
					
				
		
				
					,
					
					"installation-platforms-aks": {
						"id": "installation-platforms-aks",
						"title": "AKS",
						"categories": "",
						"url": " /installation/platforms/aks",
						"content": "Quick Start with AKS \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on AKS:\n\n\n  Connect Meshery to your AKS cluster\n    \n      Meshery CLI (mesheryctl)\n      Azure CLI (az)\n    \n  \n  Install Meshery on your AKS cluster\n  Access Mesheryâ€™s UI\n\n\nConnect Meshery to Azure Kubernetes Cluster\n\nThe following set of instructions expects you to have created a AKS cluster in your resource group Configure Meshery to connect to your AKS cluster by executing:\n\n\n \n mesheryctl system config aks\n \n \n\nManual Steps\n\nAlternatively, you may execute the following steps to manually configure Meshery to connect to your AKS cluster.\n\n\n  \n    Install Azure CLI(az), and login\nto your azure account using az login.\n  \n  \n    After successfull login, you have to select the subscription with which your AKS is associated with\n  \n\n\n \n az account set --subscription \n \n \n\n  Get the kubeconfig from your AKS cluster\n\n\n \n az aks get-credentials --resource-group  --name \n \n \n\n  Set your cluster context and check your cluster-info\n\n\n \n kubectl set-context \n kubectl cluster-info\n \n \n\nInstall Meshery into your AKS cluster\n\n\n \n $ kubectl create ns meshery\n $ helm repo add meshery https://meshery.io/charts/\n $ helm install meshery --namespace meshery meshery/meshery\n \n \n\nPort forward to the Meshery UI\n\n\n \n export POD_NAME=$(kubectl get pods --namespace meshery -l \"app.kubernetes.io/name=meshery,app.kubernetes.io/instance=meshery\" -o jsonpath=\"{.items[0].metadata.name}\")\n kubectl --namespace meshery port-forward $POD_NAME 8080:8080\n \n \n\nMeshery should now be running in your AKS cluster and the Meshery UI should be locally accessible. Navigate to http://localhost:9081 to log into Meshery."
					}
					
				
		
				
					,
					
					"es-installation-platforms-aks": {
						"id": "es-installation-platforms-aks",
						"title": "AKS",
						"categories": "",
						"url": " /es/installation/platforms/aks",
						"content": "Inicio rÃ¡pido con el Servicio Kubernetes de Azure (AKS)\n\nKubernetes administrado\n\nPara ejecutar Meshery en un ambiente administrado de Kubernetes, deberÃ¡ asignar una ServiceAccount existente o crear una nueva ServiceAccount:\n\nNota: asegÃºrese de poder acceder a AKS con la CLI(IntÃ©rprete de LÃ­nes de comandos) de Azure (az) siguiendo la  GuÃ­a de inicio rÃ¡pido de AKS .\n\nÂ¡Las instrucciones completas estarÃ¡n disponible pronto!"
					}
					
				
		
				
					,
					
					"extensibility-api": {
						"id": "extensibility-api",
						"title": "Extensibility: APIs",
						"categories": "",
						"url": " /extensibility/api",
						"content": "Mesheryâ€™s APIs\n\nEach of Mesheryâ€™s APIs are subject to the following authentication and authorization system.\n\nAuthentication\n\nRequests to any of the API endpoints must be authenticated and include a valid JWT access token in the HTTP headers. Type of authentication is determined by the selected Provider. Use of the Local Provider, â€œNoneâ€, puts Meshery into single-user mode and does not require authentication.\n\nAuthorization\n\nCurrently, Meshery only requires a valid token in order to allow clients to invoke its APIs.\n\nEndpoints\n\nEach of the API endpoints are exposed through server.go. Endpoints are grouped by function (e.g. /api/mesh or /api/perf).\n\nAlternatively, Remote Providers can extend Mesheryâ€™s endpoints behind the /api/extensions/ endpoint.\n\nGraphQL\n\nMeshery provides a GraphQl API available through the default port of /tcp.\n\nREST\n\nMeshery provides a REST API available through the default port of 9081/tcp."
					}
					
				
		
				
					,
					
					"concepts-architecture": {
						"id": "concepts-architecture",
						"title": "Architecture",
						"categories": "",
						"url": " /concepts/architecture",
						"content": "Architectural Components and Their Languages\n\nMeshery and its components are written using the following languages and technologies.\n\n\n  \n    \n      Components\n      Languages and Technologies\n    \n  \n  \n    \n      Meshery Server\n      Golang, gRPC, GraphQL, SQLlite\n    \n    \n      Meshery Adapters\n      Golang, gRPC\n    \n    \n      Meshery WASM Filters\n      Rust and C++\n    \n    \n      Meshery UI\n      ReactJS, NextJS, BillboardJS\n    \n    \n      Meshery Provider UI\n      ReactJS, NextJS\n    \n    \n      Meshery Remote Providers\n      any - must adhere to Meshery Extension Points\n    \n    \n      Meshery Operator\n      Golang, NATS\n    \n    \n      MeshSync\n      Golang\n    \n    \n      Meshery Database\n      Golang, SQL\n    \n  \n\n\nDeployments\n\nMeshery deploys as a set of containers. Mesheryâ€™s containers can be deployed to either Docker or Kubernetes.\n\n\n\nClients\n\nMesheryâ€™s REST API may be consumed by any number of clients. Clients need to present valid JWT token.\n\n\n\nProviders\n\nAs a point of extension, Meshery supports two types of providers: Local and Remote.\n\n\n\nObject Model\n\nThis diagram outlines logical constructs within Meshery and their relationships.\n\n\n\nMeshery Operator and MeshSync\n\nMeshery Operator is the multi-service mesh operator (a Kubernetes custom controller) that manages MeshSync and itâ€™s messaging broker.\n\n\n\nSee the Operator section for more information on the function of an operator and MeshSync section for more information on the function of meshsync.\n\nDatabase\n\nMeshery Serverâ€™s database is responsible for collecting and centralizing the state of all elements under management, including infrastructure, application, and Mesheryâ€™s own components. Mesheryâ€™s database, while persisted to file, is treated as a cache.\n\n\n\nSee the Database section for more information on the function of the database.\n\nNetwork Ports\n\nMeshery uses the following list of network ports to interface with its various components:\n\n\n  \n    \n      Component\n      Port\n    \n  \n  \n    \n      Meshery REST API\n      9081/tcp\n    \n    \n      Meshery GraphQL\n      9081/tcp\n    \n    \n      Meshery Broker\n      4222/tcp, 6222/tcp, 8222/tcp, 7777/tcp, 7422/tcp, 7522/tcp\n    \n    \n      Learn Layer5 Application\n      10011/tcp\n    \n    \n      Meshery Adapters\n      10000+/tcp\n    \n    \n      Meshery Remote Providers\n      443/tcp\n    \n  \n\n\nAdapter Ports\n\n\n  \n    \n      Service Mesh\n      Port\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10005/tcp\n    \n    \n       Meshery Adapter for Consul\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10002/tcp\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10008/tcp\n    \n    \n       Meshery Adapter for Istio\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10000/tcp\n    \n    \n       Meshery Adapter for Kuma\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10007/tcp\n    \n    \n       Meshery Adapter for Linkerd\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10001/tcp\n    \n    \n       Meshery Adapter for NGINX Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10010/tcp\n    \n    \n       Meshery Adapter for Network Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10004/tcp\n    \n    \n       Meshery Adapter for Octarine\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10003/tcp\n    \n    \n       Meshery Adapter for Open Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10009/tcp\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10010/tcp\n    \n    \n       Meshery Adapter for Traefik Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10006/tcp\n    \n  \n\n\nSee the Adapters section for more information on the function of an adapter.\n\nStatefulness in Meshery components\n\nSome components within Mesheryâ€™s architecture are concerned with persisting data while others are only\nconcerned with a long-lived configuration, while others have no state at all.\n\n\n  \n    \n      Components\n      Persistence\n      Description\n    \n  \n  \n    \n      mesheryctl\n      stateless\n      command line interface that has a configuration file\n    \n    \n      Meshery Adapters\n      stateless\n      interface with service meshes on a transactional basis\n    \n    \n      Meshery Server\n      caches state\n      application cache is stored in userâ€™s $HOME/.meshery/ folder\n    \n    \n      Meshery Providers\n      stateful\n      location of persistent user preferences, environment, tests and so on\n    \n    \n      Meshery Operator\n      stateless\n      operator of Meshery custom controllers, notably MeshSync\n    \n    \n      MeshSync\n      stateless\n      Kubernetes custom controller, continuously running discovery"
					}
					
				
		
				
					,
					
					"es-architecture": {
						"id": "es-architecture",
						"title": "Arquitectura de Meshery",
						"categories": "",
						"url": " /es/architecture",
						"content": "Arquitectura\n\nLa arquitectura de Meshery puede ser vista desde dos perspectivas:\n\n1. Clientes\n2. Proveedores\n\n\n\n1. Arquitectura del Client\n\n\n\n2. Arquitectura del Proveedor\n\n\n\nPuertos de Red\n\nMeshery utiliza la siguiente lista de puertos de red para conectarse con sus mÃºltiples componentes:\n\n\n  \n    \n      ApplicaciÃ³n de Red\n      Puerto\n    \n  \n  \n    \n      Meshery REST API\n      9081/tcp\n    \n    \n      Learn Layer5 Application\n      10011\n    \n  \n\n\nPuertos del Adaptador\n\n\n  \n    \n      Service Mesh\n      Puerto\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10005/tcp\n    \n    \n       Meshery Adapter for Consul\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10002/tcp\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10008/tcp\n    \n    \n       Meshery Adapter for Istio\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10000/tcp\n    \n    \n       Meshery Adapter for Kuma\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10007/tcp\n    \n    \n       Meshery Adapter for Linkerd\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10001/tcp\n    \n    \n       Meshery Adapter for NGINX Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10010/tcp\n    \n    \n       Meshery Adapter for Network Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10004/tcp\n    \n    \n       Meshery Adapter for Octarine\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10003/tcp\n    \n    \n       Meshery Adapter for Open Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10009/tcp\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10010/tcp\n    \n    \n       Meshery Adapter for Traefik Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  10006/tcp\n    \n  \n\n\nVÃ©ase la secciÃ³n de Adaptadores para mÃ¡s informaciÃ³n sobre el funcionamiento de un adaptador.\n\n**Estado en los componentes de Meshery **\n\nAlgunos componentes dentro la arquitectura de Meshery se preocupan por la persistencia de datos mientras que otros se preocupan por una configuraciÃ³n duradera, mientras que otros no lo consideran.\n\n\n  \n    \n      Componentes\n      Persistencia\n      DescripciÃ³n\n    \n  \n  \n    \n      mesheryctl\n      stateless\n      interface de lÃ­nea de comando con un archivo de configuraciÃ³n\n    \n    \n      Adaptadores de Meshery\n      stateless\n      interface con service meshes con una base transaccional\n    \n    \n      Servidor de Meshery\n      cachÃ© de estado\n      cachÃ© de aplicaciÃ³n guardada en la carpeta de usuario $HOME/.meshery/`\n    \n    \n      Proveedores de Meshery\n      stateful\n      ubicaciÃ³n de preferencias persitentes de usuario, ambiente, pruebas, entre otros"
					}
					
				
		
				
		
				
					,
					
					"concepts-architecture-broker": {
						"id": "concepts-architecture-broker",
						"title": "Broker",
						"categories": "",
						"url": " /concepts/architecture/broker",
						"content": "Broker is a custom kubernetes controller that empowers data streaming across different components of meshery, which are either inside or outside of the kubernetes cluster.\n\nBroker FAQs\n=======\nBroker is a custom Kubernetes controller that provides data streaming across independent components of Meshery whether those components are running inside or outside of the Kubernetes cluster.\n\nBroker FAQs\n\nHow many Brokers can run?\nIt is recommended to run one broker instance for each kubernetes cluster, However the instance itself can be scaled up based on the incoming data volume in each of the cluster. The scaling is independent of the number of instances running.\n\nWhat does an HA configuration look like?\nWe leverage on the kubernetes functionality in terms of the High-Availability behaviour. Meaning, the broker instance gets instantiated/restarted on its own when an issue occurs. In part, Meshery-Operator is also resposible for keeping the broker functional.\n\nWhat stateful characteristics does the Broker have?\nAll the messages that are published to the broker is persisted in-memory within the broker instance until it get consumed. Persistent-volume/Disk-space is not currently being used by the Broker.\n\nHow do I know if the Broker is working? How do I troubleshoot the Broker?\nThe Broker instance is deployed inside the kubernetes cluster as a Statefulset. In the case where the broker doesnt seem to work, here are a few steps to troubleshoot the instance:\n\n\n  Make sure the pods corresponding to the Statefulset is up and running.\n  Make sure the kubernetes cluster has support for kubernetes Service type LoadBalancer or NodePort.\n  Ensure connectivity between the Meshery-Server and the Broker service endpoint."
					}
					
				
		
				
					,
					
					"project-build-and-release": {
						"id": "project-build-and-release",
						"title": "Build &amp; Release (CI)",
						"categories": "",
						"url": " /project/build-and-release",
						"content": "Mesheryâ€™s build and release system incorporates many tools, organized into different workflows each triggered by different events. Mesheryâ€™s build and release system does not run on a schedule, but is event-driven. GitHub Actions are used to define Mesheryâ€™s CI workflows. New builds of Meshery and its various components are automatically generated upon push, release, and other similar events, typically in relation to their respective master branches.\n\nArtifacts\n\nToday, Meshery and Meshery adapters are released as Docker container images, available on Docker Hub. Meshery adapters are out-of-process adapters (meaning not compiled into the main Meshery binary), and as such, are independent build artifacts.The process of creating Docker images, tagging with the git commit SHA and pushing to Docker Hub is being done automatically using GitHub Actions.\n\nArtifact Repositories\n\nArtifacts produced in the build processes are published and persisted in different public repositories and in different formats.\n\n\n  \n    \n      Location\n      Project\n      Repository\n    \n  \n  \n    \n      Docker Hub\n      Meshery\n      https://hub.docker.com/r/layer5/meshery\n    \n    \n      GitHub\n      mesheryctl\n      https://github.com/layer5io/meshery/releases\n    \n    \n      Docker Hub\n      Meshery Adapter for &lt;service-mesh&gt;\n      https://hub.docker.com/r/layer5/meshery-&lt;service-mesh&gt;\n    \n    \n      Docs\n      Meshery Documentation\n      https://docs.meshery.io\n    \n    \n      GitHub\n      Service Mesh Performance\n      https://github.com/layer5io/service-mesh-performance\n    \n  \n\n\nSecrets\n\nSome portions of the workflow require secrets to accomplish their tasks. These secrets are defined within the respective repositories and accessible to workflows during runtime. Currently defined secrets include:\n\n\n  DOCKER_USERNAME: Username of the Docker Hub user with the right privileges to push images\n  DOCKER_PASSWORD: Password for the Docker Hub user\n  GO_VERSION: As of December 9th 2020 it is 1.15\n  IMAGE_NAME: appropriate image name for each of the Docker container images. All are under the layer5io org.\n  SLACK_BOT_TOKEN: Used for notification of new GitHub stars given to the Meshery repo.\n  CYPRESS_RECORD_KEY`: Used for integration with the Layer5 account on Cypress.\n  GLOBAL_TOKEN: Used for securely transmitting performance test results for the None Provider.\n\n\nThe Docker Hub user, mesheryci, belongs to the â€œciusersâ€ team in Docker Hub and acts as the service account under which these automated builds are being pushed. Every time a new Docker Hub repository is created we have to grant â€œAdminâ€ (in order to update the README in the Docker Hub repository) permissions to the ciusers team.\n\nChecks and Tests\nMesheryâ€™s CI workflow incorporates several checks (partial list below) during merges and/or commits to any branches and pull requests to master branch to prevent broken code from being merged into master.\n\nCollectively, Meshery repositories will generally have CI workflow for commits and pull requests that consist of the following actions:\n\n\n  Lint check (golint)\n  Static analysis check (staticcheck)\n  Vet (govet)\n  Security checks (gosec)\n  Unit tests (go tests)\n  Build (go build)\n  Release binaries through GoReleaser (only for mesheryctl in the Meshery repository)\n  Docker build, tag and push\n\n\nAutomated Builds\n\nAll Meshery GitHub repositories are configured with GitHub Actions. Everytime a pull request is submitted against the master branch of any repository, that repositoryâ€™s GitHub Actions will be invoked (whether the PR is merged or not). Workflows defined in Meshery repository will generally (but not always) perform the following actions:\n\n\n  trigger a Docker build to build a Docker container image\n  generate two Docker tags:\n    \n      a tag containing the git merge SHA\n      a tag containing that particular releaseâ€™s git tag (if one is present)\n    \n  \n  assign each of these two tags to the new container image as well as the latest tag.\n  push the new Docker tags and image to Docker Hub.\n\n\nBuilding mesheryctl\n\nAs a special case, the meshery repository contains an additional artifact produced during each build. This artifact is mesheryctl which is built as an executable binary. In order to make the job of building mesheryctl easier for a combination of different platform architectures and operating systems, we are using GoReleaser. Irrespective of branch, for every git commit and git push to the meshery repository, GoReleaser will execute and generate the OS and arch-specific binaries ( but will NOT publish them to GitHub). Even though mesheryctl binaries are built each time a pull request is merged to master, only stable channel artifacts are published (persisted).\n\nReleasing mesheryctl to GitHub\n\nOnly when a git tag containing  a semantic version number is present (is a commit in the master branch) will GoReleaser execute, generate the archives, and also publish the archives to Mesheryâ€™s GitHub releases automatically. GoReleaser is configured to generate artifacts for the following OS, ARCH combination:\n\n\n  Darwin - i386, x86_64\n  Linux - i386, x86_64\n  Windows - i386, x86_64\n  FreeBSD - i386, x86_64\n\n\nThe artifacts will be made available as a tar.gz archive for all the operating systems. mesheryctl is bundled into packages for commonly used package managers: homebrew and scoop.\n\nHomebrew\n\nGoReleaser facilitates the creation of a brew formula for mesheryctl. The homebrew-tap repository is the location for Layer5â€™s brew formulas.\n\nScoop\n\nGoReleaser facilitates the creation of a Scoop app for mesheryctl. The scoop-bucket repository is the location of Layer5â€™s Scoop bucket.\n\nRelease Versioning\n\nWe follow the commonly used semantic versioning for Meshery, Meshery Adapter and Performance Benchmark Specification releases. Given a version number MAJOR.MINOR.PATCH.BUILD, increment the:\n\n\n  MAJOR version - major changes with rare potential for incompatible API changes.\n  MINOR version - add functionality in a backwards-compatible manner.\n  PATCH version - mostly for bug and security fixes.\n  AlPHA/BETA/RC - used to facilitate early testing of an upcoming release.\n\n\nComponent Versioning\n\nMeshery comprises a number of components including a server, adapters, UI, and CLI. As an application, Meshery is a composition of these different functional components. While all of Mesheryâ€™s components generally deploy as a collective unit (together), each component is versioned independently, so as to allow them to be loosely coupled and iterate on functionality independently.  Some of the components must be upgraded simultaneously, while others may be upgraded independently. See Upgrading Meshery for more information.\n\nGitHub release tags will contain a semantic version number. Semantic version numbers will have to be managed manually by tagging a relevant commit in the master branch with a semantic version number (example: v1.2.3).\n\nRelease Process\n\nDocumentation of Meshery releases contains a table of releases and release notes and should be updated with each release.\n\nAutomated Releases\n\nReleases are manually triggered by a member of the release team publishing a release. Release names and release tags need to be assigned by the publishing team member. GitHub Action workflows will trigger and take care of running the required steps and publishing all artifacts (e.g., binary and docker images).\n\nWorkflow Triggers\n\nThe following events will trigger one or more workflows:\n\n\n  Tagged Release\n  Commit pushed to the master branch\n  PR opened or commit pushed to PR branch\n  PR merged to the master branch\n\n\nRelease Notes\n\nWhile use of GitHub Actions facilitates automated builds, ReleaseDrafter is helping with facilitating automated release notes and versioning.\nGenerating Release Notes\n\nReleaseDrafter generates a GitHub tag and release draft. ReleaseDrafter action will trigger and will automatically draft release notes according to the configuration set-up. ReleaseDrafter drafts releases as soon as a commit is made into master after the previous release. The GitHub Action, ReleaseDrafter, is compatible with semantic releases and is used to auto-increment the semantic version number by looking at the previous release version.\n\nAutomated Release Notes Publishing\n\nThe publishing of release notes to Meshery Docs is automated. Triggered by a release event, a workflow will checkout the Meshery repo, copy the auto-drafted release notes into a Jekyll collection in Meshery Docs, and generate a pull request.\n\nAutomated Pull Request Labeler\n\nA GitHub Issue labeler bot is configured to automatically assign labels to issues based on which files have changed in which directories. For example, a pull request with changes to files in the â€œ/docs/**â€ folder will receive the â€œarea/docsâ€ label. Presence of the â€œarea/docsâ€ label is used to trigger documentation builds and Netlify builds of the Meshery Docs. Similar labels are assigned and used to trigger workflows or used as conditional flags in workflows to determine which workflows or which steps in a workflows to run.\n\nRelease Channels\n\nArtifacts of the builds for Meshery and its components are published under two different release channels, so that improved controls may be provided to both Meshery users and Meshery developers. The two release channels are edge and stable release channels.\n\nRelative to stable releases, edge releases occur much more frequently. Edge releases are made with each merge to master, unless that merge to master is for a stable release. Stable releases are made with each merge to master when a GitHub release tag is also present in the workflow.\n\nStable Channel\n\nThe following is an example of the release channels and the docker tags used to differentiate them. The latest tag will be applied only to images in the stable release channel. Here are two releases with two different images.\n\nLatest Stable Image\n\n\n  layer5/meshery:stable-latest\n  layer5/meshery:stable-v0.4.1\n  layer5/meshery:stable-324vdgb (sha)\n\n\nOlder Stable Image\n\n\n  layer5/meshery:stable-v0.4.0\n  layer5/meshery:stable-289d02 (sha)\n\n\nEvery docker image built receives either the edge tags or the stable tabs. Which set of image tags assigned is determined by whether a release tag is present or not. In other words, stable channel docker images get the â€œstableâ€ tags only in the presence of a release tag (e.g. v0.4.1).\n\nEdge Channel\n\nThe edge release channel generally contains code less tested, less â€œbakedâ€. The primary reason for â€œedgeâ€ is to allow contributors and advanced users to get at features sooner than later. Some features need testing that is best facilitated by letting users with tolerance and patience try them out.\n\nStable and edge releases are both published to the same Docker Hub repository. Docker Hub repositories differentiate release channels by image tag. The following Docker images tagging convention is followed:\n\nLatest Edge Image\n\n\n  layer5/meshery:edge-latest\n  layer5/meshery:edge-289d02 (sha)\n\n\nOlder Edge Image\n\n\n  layer5/meshery:edge-324vdgb (sha)\n\n\nSwitching Between Meshery Release Channels\n\nUsers are empowered to switch between release channels at their leisure.\n\nSwitching Release Channels Using mesheryctl\n\nUsers can use mesheryctl to switch between release channels, e.g. mesheryctl system channel [stable|edge].  Alternatively, users can manually switch between channels by updating the docker image tags in their meshery.yaml / Kubernetes manifest files. This command generates a meshery.yml (a docker-compose file) with release channel-appropriate tags for the different Docker container images.\n\nViewing Release Channel and Version Information in Meshery UI\n\nUsers are shown their Meshery deploymentâ€™s release channel subscription enient new setting in the Preferences area of the Meshery UI, so that people can alternatively use the UI to switch between channels if they like. Version numbers for Meshery adapters are also shown in the UI.\n\nRelease Cadence\n\nMinor releases of the Meshery project are release frequently (on a monthly basis on average) with patch releases made on-demand in-between those times. The project does not have long term releases that are sustained with bug fixes, yet. Bug fixes and patches will be released as needed on the latest release version.\n\nRelease Support\n\nGeneral community support and commercial support from Layer5 is available. Separately, third parties and partners may offer longer-term support solutions.\n\nPre v1.0\n\nProject focuses on functionality, quality and adoption, while retaining the flexibility for shifts in architecture.\n\nPost v1.0\n\nOnce a 1.0 release has been made, Around once a month or so, the project maintainers will take one of these daily builds and run it through a number of additional qualification tests and tag the build as a Stable release. Around once a quarter or so, the project maintainers take one of these Stable releases, run through a bunch more tests and tag the build as a Long Term Support (LTS) release. Finally, if we find something wrong with an LTS release, we issue patches.\n\nThe different types (Daily, Stable, LTS) represent different product quality levels and different levels of support from the Meshery team. In this context, support means that we will produce patch releases for critical issues and offer technical assistance."
					}
					
				
		
				
					,
					
					"project-contributing": {
						"id": "project-contributing",
						"title": "Contributing",
						"categories": "",
						"url": " /project/contributing",
						"content": "Please do! Thanks for your help! :balloon:\n\nThis project is community-built and welcomes collaboration. Contributors are expected to adhere to the CNCFâ€™s Code of Conduct.\nNot sure where to start?\n\nFollow these steps and youâ€™ll be right at home.\n\n\n  \n    See the Community Welcome Guide for how, where, and why to contribute.\n  \n  \n    Sign up for a MeshMate to find the perfect Mentor to help you explore the Layer5 projects and find your place in the community:\n    \n      Familiarize yourself with all the Layer5 projects (Take a look at the Community Drive and the Layer5 Repository Overview: Spend time understanding each of the Layer5 initiatives through high-level overviews available in the community drive and through discussions with your MeshMate.\n      Identify your area of interest: Use the time with your MeshMate to familiarize yourself with the architecture and technologies used in the projects. Inform your MeshMate of your current skills and what skills you aim to develop.\n      Run Meshery: Put on your user hat and walk-through all of Mesheryâ€™s features and functions as a user.\n      Build Meshery: Confirm that you have a usable development environment.\n      Communicate with the Layer5 community by joining the Slack account.\n      Contribute by grabbing any open issue with the help-wanted label and jump in. If needed, create a new issue. All pull requests should reference an open issue. Include keywords in your pull request descriptions, as well as commit messages, to automatically close issues in GitHub.\n    \n  \n\n\nSections\n\n  General Contribution Flow\n  Developer Certificate of Origin\n  Meshery Contribution Flow\n    \n      Meshery Documentation\n      Meshery Backend\n        \n          Writing a Meshery Adapter\n        \n      \n      Meshery UI\nRelevant coding style guidelines are the Go Code Review Comments and the Formatting and style section of Peter Bourgonâ€™s Go: Best Practices for Production Environments.\n    \n  \n\n\nGeneral Contribution Flow\n\nTo contribute to Meshery, please follow the fork-and-pull request workflow described here.\n\nSigning-off on Commits (Developer Certificate of Origin)\n\nTo contribute to this project, you must agree to the Developer Certificate of\nOrigin (DCO) for each commit you make. The DCO is a simple statement that you,\nas a contributor, have the legal right to make the contribution.\n\nSee the DCO file for the full text of what you must agree to\nand how it works here.\nTo signify that you agree to the DCO for contributions, you simply add a line to each of your\ngit commit messages:\n\nSigned-off-by: Jane Smith &lt;jane.smith@example.com&gt;\n\n\nIn most cases, you can add this signoff to your commit automatically with the\n-s or --signoff flag to git commit. You must use your real name and a reachable email\naddress (sorry, no pseudonyms or anonymous contributions). An example of signing off on a commit:\n$ commit -s -m â€œmy commit message w/signoffâ€\n\n\nTo ensure all your commits are signed, you may choose to add this alias to your global .gitconfig:\n\n~/.gitconfig\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n\nOr you may configure your IDE, for example, Visual Studio Code to automatically sign-off commits for you:\n\n\n\nDocumentation Contribution Flow\nPlease contribute! Meshery documentation uses GitHub Pages to host the docs site. Learn more about Mesheryâ€™s documentation framework. The process of contributing follows this flow:\n\n\n  Create a fork, if you have not already, by following the steps described here\n  In the local copy of your fork, navigate to the docs folder.\ncd docs\n  Create and checkout a new branch to make changes within\ngit checkout -b &lt;my-changes&gt;\n  Edit/add documentation.\nvi &lt;specific page&gt;.md\n  Run site locally to preview changes.\nmake site\n  Commit, sign-off, and push changes to your remote branch.\ngit push origin &lt;my-changes&gt;\n  Open a pull request (in your web browser) against our main repo: https://github.com/layer5io/meshery.\n\n\nMeshery Contribution Flow\nMeshery is written in Go (Golang) and leverages Go Modules. UI is built on React and Next.js. To make building and packaging easier a Makefile is included in the main repository folder.\n\nRelevant coding style guidelines are the Go Code Review Comments and the Formatting and style section of Peter Bourgonâ€™s Go: Best \nPractices for Production Environments.\n\nPlease note: All make commands should be run in a terminal from within the Mesheryâ€™s main folder.\n\nPrerequisites for building Meshery in your development environment:\n\n  Go version 1.11+ installed if you want to build and/or make changes to the existing code.\n  GOPATH environment variable should be configured appropriately\n  npm and node should be installed on your machine, preferably the latest versions.\n  Fork this repository (git clone https://github.com/layer5io/meshery.git), clone your forked version of Meshery to your local, preferably outside GOPATH. If you happen to checkout Meshery inside your GOPATH and you have a version of Go prior to version 1.13, please set an environment variable GO111MODULE=on to enable GO Modules.\n\n\nBuild and run Meshery server\nTo build &amp; run the Meshery server code, run the following command:\nmake run-local\n\n\nAny time changes are made to the GO code, you will have to stop the server and run the above command again.\nOnce the Meshery server is up and running, you should be able to access Meshery on your localhost on port 9081 at http://localhost:9081. One thing to note, you might NOT see the Meshery UI until the UI code is built as well.\nAfter running Meshery server, you will need to select your Cloud Provider by navigating to localhost:9081. Only then you will be able to use the Meshery UI on port 3000.\n\nBuilding Docker image\nTo build a Docker image of Meshery, please ensure you have Docker installed to be able to build the image. Now, run the following command to build the Docker image:\nmake docker\n\n\nWriting a Meshery Adapter\nMeshery uses adapters to provision and interact with different service meshes. Follow these instructions to create a new adapter or modify and existing adapter.\n\n\n  Get the proto buf spec file from Meshery repo:\nwget https://raw.githubusercontent.com/layer5io/meshery/master/meshes/meshops.proto\n  Generate code\n    \n      Using Go as an example, do the following:\n        \n          adding GOPATH to PATH: export PATH=$PATH:$GOPATH/bin\n          install grpc: go get -u google.golang.org/grpc\n          install protoc plugin for go: go get -u github.com/golang/protobuf/protoc-gen-go\n          Generate Go code: protoc -I meshes/ meshes/meshops.proto --go_out=plugins=grpc:./meshes/\n        \n      \n      For other languages, please refer to gRPC.io for language-specific guides.\n    \n  \n  Implement the service methods and expose the gRPC server on a port of your choice (e.g. 10000).\n\n\nTip: The Meshery Adapter for Istio is a good reference adapter to use as an example of a Meshery Adapter written in Go.\n\nmesheryctl Contribution Flow\n\nmesheryctl is written in Golang or the Go Programming Language. For development use Go version 1.15+.\n\nThe /mesheryctl folder contains the complete code for mesheryctl.\n\nAfter making changes, run make in the mesheryctl folder to build the binary. You can then use the binary by, say, ./mesheryctl system start.\n\nmesheryctl command reference\n\nDetailed documentation of the mesheryctl commands is available in the Meshery Docs.\n\nGuidelines and resources for contributing to mesheryctl\n\nmesheryctl might be the interface that the users first have with Meshery. As such, mesheryctl needs to provide a great UX.\n\nThe following principles should be taken in mind while designing mesheryctl commands-\n\n\n  Provide user experiences that are familiar.\n  Make the commands and their behavior intuitive.\n  Avoid long commands with chained series of flags.\n  Design with automated testing in mind, e.g. provide possibility to specify output format as json (-o json) for easy inspection of command response.\n\n\nPart of delivering a great user experience is providing intuitive interfaces. In the case of mesheryctl, we should take inspiration from and deliver similar user experiences as popular CLIs do in this ecosystem, like kubectl and docker. Here is relevant kubectl information to reference - Kubectl SIG CLI Community Meeting Minutes, contributing to kubectl, code.\n\nmesheryctl uses the Cobra framework. A good first-step towards contributing to mesheryctl would be to familiarise yourself with the Cobra concepts.\n\nFor manipulating config files, mesheryctl uses Viper.\n\nA central struct is maintained in the mesheryctl/internal/cli/root/config/config.go file. These are updated and should be used for getting the Meshery configuration.\n\nFor logs, mesheryctl uses Logrus. Going through the docs and understanding the different log-levels will help a lot.\n\nmesheryctl uses golangci-lint. Refer it for lint checks.\n\nUI Contribution Flow\nMeshery is written in Go (Golang) and leverages Go Modules. UI is built on React and Next.js. To make building and packaging easier a Makefile is included in the main repository folder.\n\nInstall UI dependencies\nTo install/update the UI dependencies:\nmake setup-ui-libs\n\n\nBuild and export UI\nTo build and export the UI code:\nmake build-ui\n\n\nNow that the UI code is built, Meshery UI will be available at http://localhost:9081.\nAny time changes are made to the UI code, the above code will have to run to rebuild the UI.\n\nUI Development Server\nIf you want to work on the UI, it will be a good idea to use the included UI development server. You can run the UI development server by running the following command:\nmake run-ui-dev\n\n\nMake sure to have Meshery server configured, up and running on the default port http://localhost:9081 before proceeding to access and work on the UI server at http://localhost:3000.\nAny UI changes made now will automatically be recompiled and served in the browser.\n\nRunning Meshery from IDE\nIf you want to run Meshery from IDE like Goland, VSCode. set below environment variable\nPROVIDER_BASE_URLS=\"https://meshery.layer5.io\"\nPORT=9081\nDEBUG=true\nADAPTER_URLS=mesherylocal.layer5.io:10000 mesherylocal.layer5.io:10001 mesherylocal.layer5.io:10002 mesherylocal.layer5.io:10003 mesherylocal.layer5.io:10004 mesherylocal.layer5.io:10005 mesherylocal.layer5.io:10006 mesherylocal.layer5.io:10007 mesherylocal.layer5.io:10008 mesherylocal.layer5.io:10009\n\ngo tool argument\n-tags draft\n\nupdate /etc/hosts\n127.0.0.1 mesherylocal.layer5.io"
					}
					
				
		
				
					,
					
					"es-project-contributing": {
						"id": "es-project-contributing",
						"title": "Contribuir",
						"categories": "",
						"url": " /es/project/contributing",
						"content": "DescripciÃ³n general de contribuciÃ³n\n\nPor favor, Â¡hazlo! Â¡Gracias por tu ayuda! :balloon:\n\nEste proyecto estÃ¡ construido por la comunidad y la colaboraciÃ³n es bienvenida. Se espera que cada persona colaboradora se adhiera al CÃ³digo de conducta de CNCF.\n\nÂ¿No estÃ¡s seguro/a por dÃ³nde empezar?\n\nSigue estos pasos y te sentirÃ¡s como en casa.\n\n\n  Consulte la GuÃ­a de bienvenida de la comunidad para saber cÃ³mo, dÃ³nde y por quÃ© contribuir.\n  RegÃ­strate para un MeshMate y encontrar el Mentor (o Mentora) perfecto que te ayude a explorar los proyectos de Layer5 y encontrar tu lugar en la comunidad:\n\n\n\n  FamiliarÃ­zate con todos los proyectos de Layer5 (echale un vistazo al Drive de la Comunidad y la lista de repositorios de Layer5: Dedicale tiempo a comprender cada una de las iniciativas de Layer5 a travÃ©s de descripciones de alto nivel disponibles en el drive de comunidad y a travÃ©s de discusiones con tu Mesh Mate.\n  Identifica tu Ã¡rea de interÃ©s: Usa el tiempo con tu MeshMate para familiarizarte con la arquitectura y las tecnologÃ­as utilizadas en los proyectos. Informa a tu MeshMate de tus habilidades actuales y las habilidades que pretendes desarrollar.\n  Ejecuta Meshery: Ponte en los zapatos del usuario y recorre todas las caracterÃ­sticas y funciones de Meshery como usuario.\n  Construye Meshery: Asegurate que tienes un entorno de desarrollo usable.\n  Comunicate con la comunidad de Layer5 uniÃ©ndote a la cuenta de Slack.\n  Contribuye tomando cualquier issue abierto con la etiqueta help wanted y entrale. Si es necesario, crea un nuevo issue. Todas las pull requests deben hacer referencia a un issue abierto. Incluye palabras clave en las descripciones de tus pull requests, asÃ­ como mensajes de commits, para cerrar automÃ¡ticamente los issues en GitHub.\n\n\nSecciones\n\n\n  Flujo general de contribuciones\n  Certificado de origen del desarrollador\n  Flujo de contribuciÃ³n de Meshery\n    \n      DocumentaciÃ³n de Meshery\n      Meshery Backend\n        \n          Escribir un Meshery Adapter\n        \n      \n      Meshery UI\nLas pautas de estilo de codificaciÃ³n relevantes son los comentarios de revisiÃ³n de Go Code Review y la secciÃ³n de formato y estilo de Go Code: las mejores prÃ¡cticas para entornos de producciÃ³n de Peter Bourgon.\n    \n  \n\n\nFlujo de contribuciÃ³n general\n\nPara contribuir a Meshery, siga el flujo de trabajo de fork-and-pull descrito aquÃ­.\n\nCertificado de origen del desarrollador\n\nPara contribuir a este proyecto, debes aceptar el Certificado de\norigen de desarrollador (DCO en inglÃ©s Developer Certificate of Origin) para cada commit que haces. El DCO es una simple declaraciÃ³n de que tu, como contribuyente, tienes el derecho legal de hacer la contribuciÃ³n.\n\nConsulta el archivo DCO para obtener el texto completo de lo que debes aceptar y cÃ³mo funciona aquÃ­.\nPara indicar que estÃ¡s de acuerdo con el DCO para las contribuciones, simplemente agregues una lÃ­nea a cada uno de tus commits git:\n\nSigned-off-by: Jane Smith &lt;jane.smith@example.com&gt;\n\n\nEn la mayorÃ­a de los casos, puedes agregar esta firma a tu confirmaciÃ³n automÃ¡ticamente con la marca -s o --signoff en git commit. Debes usar tu nombre real y un correo electrÃ³nico accesible (lo sentimos, no se permiten seudÃ³nimos ni contribuciones anÃ³nimas). Un ejemplo de firma de una confirmaciÃ³n:\n\n$ commit -s -m â€œmy commit message w/signoffâ€\n\n\nPara asegurarte de que todas tus confirmaciones estÃ¡n firmadas, puedes optar por agregar este alias a su global .gitconfig:\n~/.gitconfig\n\n[alias]\n  amend = commit -s --amend\n  cm = commit -s -m\n  commit = commit -s\n\n\nO puedes configurar tu IDE, por ejemplo , Visual Studio Code para cerrar automÃ¡ticamente las confirmaciones por ti:\n\n\n\nFlujo de contribuciÃ³n a la documentaciÃ³n\n\nÂ¡Por favor contribuye! La documentaciÃ³n de Meshery utiliza pÃ¡ginas de GitHub para alojar el sitio de documentos. Obten mÃ¡s informaciÃ³n sobre el framework de documentaciÃ³n de Meshery. El flujo de proceso de contribuciÃ³n es el siguente:\n\n\n  Crea un fork, si aÃºn no lo has hecho, sigue los pasos descritos aquÃ­\n  En la copia local del fork, navega a la carpeta docs:\ncd docs\n  Crea una nueva rama para realizar cambios:\ngit checkout -b &lt;my-changes&gt;\n  Edita/agrega documentaciÃ³n:\nvi &lt;specific page&gt;.md\n  Ejecuta el sitio localmente para obtener una vista previa de los cambios:\nmake site\n  Has commit, sign-off, y envÃ­a los cambios a tu rama remota\ngit push origin &lt;my-changes&gt;\n  Abre pull request (en su navegador web) en nuestro repositorio principal: https://github.com/layer5io/meshery.\n\n\nFlujo de contribuciÃ³n de Meshery\n\nMeshery estÃ¡ escrito en Go (Golang) y usa los mÃ³dulos Go. La interfaz de usuario se basa en React y Next.js. Para facilitar la creaciÃ³n y el packaging, se incluye un archivo Makefile en la carpeta principal del repositorio.\n\nLas guÃ­as de estilo de programacciÃ³n relevantes son los Comentarios de revisiÃ³n de cÃ³digo de Go y la secciÃ³n Formato y estilo de Peter Bourgonâ€™s Go:BestPractices for Production.\n\nPor favor toma en cuenta: Todos los comandos make deben ejecutarse en una terminal desde la carpeta principal de Meshery.\n\nRequisitos previos para construir Meshery en tu entorno de desarrollo:\n\n\n  Tener la versiÃ³n 1.11+ deGo instalada si quieres compilar y/o hacer cambios en el cÃ³digo existente.\n  La variable de entorno GOPATH debe configurarse de manera apropiada.\n  npm y node deben estar instalados en tu mÃ¡quina, preferiblemente las Ãºltimas versiones.\n  Haz fork de este repoisitorio (https://github.com/layer5io/meshery.git), clona tu version forked de Meshery a tu maquina local, preferiblemente fuera de tu GOPATH. Si llegase a suceder que copiaras Meshery dentro de tu GOPATH y tuvieras una version de go Go anterior a la versiÃ³n 1.13, por favor establece la variable de entorno GO111MODULE=on para habilitar los modulos de Go.\n\n\nConstruir y ejecutar el servidor Meshery\n\nPara construir y ejecutar el cÃ³digo del servidor Meshery, ejecuta el siguiente comando:\n\nmake run-local\n\n\nCada vez que se realicen cambios en el cÃ³digo GO, tendrÃ¡s que detener el servidor y ejecutar el comando anterior nuevamente.\nUna vez que el servidor Meshery esta en funcionamiento, deberÃ­as poder acceder a Meshery en tu localhost en el puerto 9081 en http://localhost:9081. Una cosa para tomar en cuenta, es que posiblemente NO veas la interfaz de usuario de Meshery hasta que tambiÃ©n hayas creado el cÃ³digo de la interfaz de usuario.\nDespuÃ©s de ejecutar el servidor Meshery, deberÃ¡s seleccionar tu Proveedor de nube navegando a localhost:9081. Solo entonces podrÃ¡s utilizar la interfaz de usuario de Meshery en el puerto 3000.\n\nCreaciÃ³n de una imagen de Docker\n\nPara crear una imagen de Docker de Meshery, asegÃºrete de tener instalado Docker para poder crear la imagen. Ahora, ejecuta el siguiente comando para construir la imagen de Docker:\n\nmake docker\n\n\nEscribiendo un Adaptador de Meshery\n\nMeshery usa adaptadores para hacer provisiones e interactuar con diferentes meshes de servicio. Sigue estas instrucciones para crear un nuevo adaptador o modificar un adaptador existente.\n\n\n  ObtÃ©n el archivo proto buf spec del repositorio de Meshery:\nwget https://raw.githubusercontent.com/layer5io/meshery/master/meshes/meshops.proto\n  Genera el cÃ³digo\n    \n      Usando Go como ejemplo, haz lo siguiente::\n        \n          agrega GOPATH a tu PATH: export PATH=$PATH:$GOPATH/bin\n          instala grpc: go get -u google.golang.org/grpc\n          instala el plugin protoc para go: go get -u github.com/golang/protobuf/protoc-gen-go\n          Genenra el cÃ³digo de Go: protoc -I meshes/ meshes/meshops.proto --go_out=plugins=grpc:./meshes/\n        \n      \n      Para otros lenguajes consulta gRPC.io para las guÃ­as especificas del lenguaje.\n    \n  \n  Implementa los mÃ©todos de servicio (service method) y expÃ³n el puerto de gRPC en el puerto de tu elecciÃ³n (por ejemplo 10000).\n\n\nTip: El adaptador de Meshery para Istio es un buen adaptador de referencia para usar como ejemplo de un adaptador Meshery escrito en Go.\n\nFlujo de ContribuciÃ³n al UI\n\nMeshery estÃ¡ escrito en Go (Golang) y aprovecha los mÃ³dulos Go. La interfaz de usuario se basa en React y Next.js. Para facilitar la creaciÃ³n y el empaquetado, se incluye un archivo Makefile en la carpeta principal del repositorio.\n\nInstalar las dependencias de UI\n\nPara instalar/actualizar las dependencias de UI:\n\nmake setup-ui-libs\n\n\nConstruir y exportar UI\n\nPara construir y exportar el cÃ³digo de UI:\n\nmake build-ui\n\n\nAhora que el cÃ³digo de la interfaz de usuario estÃ¡ creado, la interfaz de usuario de Meshery estarÃ¡ disponible en http: // localhost: 9081.\nCada vez que se realizan cambios en el cÃ³digo de la interfaz de usuario, el cÃ³digo anterior deberÃ¡ ejecutarse para reconstruir la interfaz de usuario.\n\nServidor de desarrollo de UI\n\nSi deseas trabajar en la UI, serÃ¡ una buena idea utilizar el servidor de desarrollo de UI incluido. Puedes ejecutar el servidor de desarrollo de UI ejecutando el siguiente comando:\n\nmake run-ui-dev\n\n\nAsegÃºrete de tener el servidor Meshery configurado y en funcionamiento en el puerto predeterminado http://localhost:9081 antes de proceder a acceder y trabajar en el servidor de UI en http://localhost:3000.\nCualquier cambio en la interfaz de usuario realizado ahora se volverÃ¡ a compilar y se servirÃ¡ automÃ¡ticamente en el navegador.\n\nEjecutando Meshery desde IDE\n\nSi deseas ejecutar Meshery desde un IDE como Goland, VSCode. establece la variable de entorno descrito aqui:\n\nPROVIDER_BASE_URLS=\"https://meshery.layer5.io\"\nPORT=9081\nDEBUG=true\nADAPTER_URLS=mesherylocal.layer5.io:10000 mesherylocal.layer5.io:10001 mesherylocal.layer5.io:10002 mesherylocal.layer5.io:10003 mesherylocal.layer5.io:10004 mesherylocal.layer5.io:10005 mesherylocal.layer5.io:10006 mesherylocal.layer5.io:10007 mesherylocal.layer5.io:10008 mesherylocal.layer5.io:10009\n\n\nargumento de go tool\n\n-tags draft\n\n\nactualiza /etc/hosts\n\n127.0.0.1 mesherylocal.layer5.io"
					}
					
				
		
				
					,
					
					"concepts-architecture-database": {
						"id": "concepts-architecture-database",
						"title": "Database",
						"categories": "",
						"url": " /concepts/architecture/database",
						"content": "What are the Meshery Databases?\n\nMeshery Databases function as repositories for MeshSync, user preferences and system settings. Both databases are considered ephemeral and should be treated as caches. Data retention is tethered to the lifetime of their Meshery Server instance. Remote Providers may offer long-term data persistence. Mesheryâ€™s APIs offer mechansims for clients, like mesheryctl and Meshery UI to retrieve data.\n\nSee the figure below for addtional details of the data formats supported and type of data stored.\n\n\n\nComponents\n\nMeshery Database has several kinds of database implementations to support various usecases. They are listed below:\n\n\n  \n    \n      Component\n      Library\n    \n  \n  \n    \n      Bitcask\n      github.com/prologic/bitcask\n    \n    \n      SQLite\n      gorm.io/gorm, gorm.io/driver/sqlite"
					}
					
				
		
				
					,
					
					"installation-platforms-docker": {
						"id": "installation-platforms-docker",
						"title": "Docker",
						"categories": "",
						"url": " /installation/platforms/docker",
						"content": "Quick Start with Docker \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nDeploying Meshery on Docker\n\nFollow these installation steps to use Docker and Docker Compose to run Meshery. Users often choose this installation approach in order to run Meshery on their local machine. If you need to install docker, see Getting Started with Docker and if you need to install docker-compose, see Installing Docker Compose.\n\nStart Meshery by executing:\n\n\n \n mesheryctl system start\n \n \n\nOnce you have verified that all the services are up and running, Meshery UI will be accessible on your local machine on port 9081. Open your browser and access Meshery at http://localhost:9081. Log into the Provider of your choice.\n\nUpon starting Meshery successfully, instructions to access Meshery will be printed on the sceen. See these guides for usage tips."
					}
					
				
		
				
					,
					
					"es-installation-platforms-docker": {
						"id": "es-installation-platforms-docker",
						"title": "Docker",
						"categories": "",
						"url": " /es/installation/platforms/docker",
						"content": "Inicio rÃ¡pido con Docker\n\nNota: se necesita un mÃ­nimo de 4 GB de RAM para los despliegues de Istio (y la aplicaciÃ³n de muestra BookInfo).\n\nPasos\n\nSiga estos pasos de instalaciÃ³n para usar Docker y Docker Compose para ejecutar Meshery. Los usuarios a menudo eligen abordar la instalaciÃ³n de esta manera para ejecutar Meshery en su mÃ¡quina local. Si necesita instalar docker, consulte IntroducciÃ³n a Docker y si necesita instalar docker-compose, consulte InstalaciÃ³n de Docker Compose.\n\nEl repositorio de Meshery incluye un archivo docker-compose.yaml. Podemos usar docker-compose para activar todos los servicios de Meshery ejecutando:\n\n\n \n $ curl -L https://git.io/meshery | bash -\n \n \n\nUna vez que haya verificado que todos los servicios estÃ¡n en funcionamiento, la interfaz de usuario de Meshery serÃ¡ accesible en su mÃ¡quina local en el puerto 9081. Abra su navegador y acceda a Meshery en http://localhost:9081.\nSe le redireccionarÃ¡ a una pÃ¡gina de inicio de sesiÃ³n social donde puede elegir uno de los mÃ©todos de inicio de sesiÃ³n social disponibles para iniciar sesiÃ³n en Meshery.\n\nAl iniciar Meshery correctamente, las instrucciones para acceder a Meshery se imprimirÃ¡n en la pantalla. Eche un vistazo a las guÃ­as Meshery para obtener consejos de uso avanzados."
					}
					
				
		
				
					,
					
					"installation-platforms-eks": {
						"id": "installation-platforms-eks",
						"title": "EKS",
						"categories": "",
						"url": " /installation/platforms/eks",
						"content": "Quick Start with EKS \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\n\n\nComing soon"
					}
					
				
		
				
					,
					
					"es-installation-platforms-eks": {
						"id": "es-installation-platforms-eks",
						"title": "EKS",
						"categories": "",
						"url": " /es/installation/platforms/eks",
						"content": "Inicio rÃ¡pido con el Servicio Elastic Kubernetes de Amazon (EKS)\n\nPara brindar a Meshery el acceso necesario a su instancia de Kubernetes administrada,\nMeshery deberÃ¡ tener asignada una ServiceAccount (Cuenta de servicio). Se puede utilizar una â€œServiceAccountâ€ existente o crear una nueva.\n\n\n  AsegÃºrese de que la ServiceAccount que utiliza tenga asignada la funciÃ³n cluster-admin.\n  Configure Meshery para que se ejecute en EKS:\n    \n      ConfiguraciÃ³n automÃ¡tica\n      ConfiguraciÃ³n manual\n    \n  \n\n\nNota: asegÃºrese de poder acceder a EKS con kubectl siguiendo la GuÃ­a de EKS.\n\nConfiguraciÃ³n automÃ¡tica (Recomendada)\n\n\n  En su navegador, navegue hasta Meshery (por ejemplo http://localhost:9081) e inicie sesiÃ³n.\n  Descargue su token de autenticaciÃ³n de Meshery haciendo clic en Get Token en la secciÃ³n de su perfil de usuario.\n  Utilice este token de autenticaciÃ³n para ejecutar el siguiente comando:\n    $ mesheryctl system config eks --token &lt;RUTA A ARCHIVO DE TOKEN&gt;\n    \n  \n\n\nEste comando actualiza su kubeconfig para proporcionar a Meshery acceso a su instancia administrada de Kubernetes.\nUna vez configurado, prosiga a utilizar Meshery (mesheryctl system start).\n\nConfiguraciÃ³n Manual(Opcional)\n\nSi el procedimiento de ConfiguraciÃ³n automÃ¡tica falla o si desea preparar manualmente su archivo kubeconfig para proveer a Meshery con el acceso necesario a su instancia administrada de Kubernetes, realice las siguientes acciones:\n\n\n  \n    Cree una ServiceAccount con el rol de cluster-admin\n\n    $ kubectl create serviceaccount meshery\n    \n  \n  \n    Agregando/Vinculando el rol cluster-admin a la nueva cuenta de servicio meshery\n\n    $ kubectl create clusterrolebinding meshery-binding --clusterrole=cluster-admin \\\n--serviceaccount=default:meshery\n    \n  \n  \n    Obtenga el nombre secreto de ServiceAccount.\n\n    $ kubectl get secrets\n\nNAME                           TYPE                                  DATA   AGE\ndefault-token-fnfjp            kubernetes.io/service-account-token   3      95d\nmeshery-token-5z9xj               kubernetes.io/service-account-token   3      66m\n    \n\n    Nota: AquÃ­ el nombre secreto es meshery-token-5z9xj\n  \n  \n    Obtenga el secreto/token:\n\n    $ kubectl describe secret  sa-1-token-5z9xj\nName:         meshery-token-5z9xj\nNamespace:    default\nLabels:       &lt;none&gt;\nAnnotations:  kubernetes.io/service-account.name: meshery\n              kubernetes.io/service-account.uid: 397XXX-XXX-XXXX-XXXXX-XXXXX\n\nType:  kubernetes.io/service-account-token\n\nData\n====\nca.crt:     1025 bytes\nnamespace:  7 bytes\ntoken:      XXXhbGciOiJSUXXXX\n    \n  \n  Genere un nuevo archivo yaml kubeconfig a usar como entrada para Meshery.\n  \n    Establezca las Credential de configuraciÃ³n usando el token generado anteriormente.\n\n    $ kubectl config set-credentials meshery --token=XXXXX\n\no/p:User \"meshery\" set.\n    \n  \n  \n    Establezca el contexto actual para la nueva cuenta de servicio meshery\n\n    $ kubectl config set-context --current --user=meshery\n\no/p:\nContext \"aws\" modified.\n    \n  \n  \n    Genere el archivo yaml kubeconfig para usar como entrada a Meshery.\n\n    $ kubectl config view --minify --flatten &gt;  config_aws_eks.yaml\n    \n  \n\n\nMeshery ahora deberÃ­a estar conectado con su instancia administrada de Kubernetes. Eche un vistazo a las GuÃ­as Meshery para ver mÃ¡s consejos de uso avanzados."
					}
					
				
		
				
					,
					
					"extensibility": {
						"id": "extensibility",
						"title": "Extensibility",
						"categories": "",
						"url": " /extensibility",
						"content": "Meshery has an extensible architecture with several extension points. Meshery provides several extension points for working with different service meshes via adapters, different load generators and different providers. Meshery also offers a REST API.\n\nGuiding Principles for Extensibility\n\nThe following principles are upheld in the design of Mesheryâ€™s extensibility.\n\n\n  Recognize that different deployment environments have different systems to integrate with.\n  Offer a default experience that provides the optimal user experience.\n\n\nExtension Points\n\nMeshery is not just an application. It is a set of microservices where the central component is itself called Meshery. Integrators may extend Meshery by taking advantage of designated Extension Points. Extension points come in various forms and are available through Mesheryâ€™s architecture.\n\n\n\nFigure: Extension points available throughout Meshery\n\nThe following points of extension are currently incorporated into Meshery.\n\nTypes of Extension Points\n\n\n  Providers\n  Load Generators\n  Adapters\n  REST API\n  GraphQL API"
					}
					
				
		
				
					,
					
					"feed-xml": {
						"id": "feed-xml",
						"title": "",
						"categories": "",
						"url": " /feed.xml",
						"content": "Documentation\n    Documentation for Meshery, the multi-service mesh management plane for Istio, Linkerd, Consul, Network Service Mesh, Octarine, Envoy, Kuma, Traefik Mesh, App Mesh, Citrix Service Mesh and other service meshes.\n\n    http://localhost:4000/\n    \n    Fri, 02 Sep 2022 21:17:51 +0530\n    Fri, 02 Sep 2022 21:17:51 +0530\n    Jekyll v3.9.0"
					}
					
				
		
				
					,
					
					"installation-platforms-gke": {
						"id": "installation-platforms-gke",
						"title": "GKE",
						"categories": "",
						"url": " /installation/platforms/gke",
						"content": "Quick Start with GKE \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on GKE\n\nIn order to provide Meshery with the necessary access to your managed Kubernetes instance, \nMeshery will need to be assigned a ServiceAccount. An existing ServiceAccount can be used or a new one created. Ensure that the ServiceAccount you use has the cluster-admin role assigned.\n\nMeshery will use this ServiceAccount to interact with your managed Kubernetes instance. Use either of the following two methods to prepare a compatible kubeconfig file:\n\n\n  Automatic Configuration\n  Manual configuration\n\n\nAutomatic Configuration (Recommended)\n\n\n  In your browser, navigate to Meshery (e.g., http://localhost:9081) and login.\n  Download your Meshery authentication token by clicking Get Token under your user profile.\n  Use this authentication token to execute the following command:\n\n\n\n \n $ mesheryctl system config gke --token *PATH_TO_TOKEN*\n \n \n\nThis command updates your kubeconfig to provide Meshery with access to your managed Kubernetes instance.\nOnce configured, proceed with using Meshery:\nmesheryctl system start\n\nManual Configuration (Optional)\n\nIf the Automatic Configuration procedure fails or you would like to manually prepare your kubeconfig file to provide Meshery with the necessary access to your managed Kubernetes instance, perform the following actions:\n\n\n  Download the generate_kubeconfig_gke.sh shell script.\n  \n    Execute this shell script identifying ServiceAccount name and Namespace arguments, like so:\n\n    \n \n ./generate_kubeconfig_gke.sh cluster-admin-sa-gke default\n \n \n  \n  \n    Once the script is complete, you may proceed to start Meshery with the GKE-compatible configuration by executing:\n\n    \n \n $ mesheryctl system start\n \n \n  \n  In your browser, navigate to Meshery (e.g., http://localhost:9081) and login.\n  Under Settings â€“&gt; Environment, provide the generated file (config-cluster-admin-sa-gke-default.yaml) as the kubeconfig file.\n\n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}
					
				
		
				
					,
					
					"es-installation-platforms-gke": {
						"id": "es-installation-platforms-gke",
						"title": "GKE",
						"categories": "",
						"url": " /es/installation/platforms/gke",
						"content": "Inicio rÃ¡pido con Google Kubernetes Engine (GKE)\n\nPara otorgar a Meshery el acceso necesario a su instancia de Kubernetes administrada,\nMeshery deberÃ¡ tener asignada una ServiceAccount ( Cuenta de servicio ). Se puede utilizar una ServiceAccount existente o crear una nueva. AsegÃºrese de que la ServiceAccount que utilize tenga asignada el rol de cluster-admin.\n\nMeshery usarÃ¡ esta ServiceAccount para interactuar con su instancia administrada de Kubernetes. Utilice cualquiera de los dos mÃ©todos siguientes para preparar un archivo kubeconfig compatible:\n\n\n  ConfiguraciÃ³n automÃ¡tica\n  ConfiguraciÃ³n manual\n\n\nConfiguraciÃ³n AutomÃ¡tica (Recomendada)\n\n\n  En su navegador, navegue hasta Meshery (por ejemplo, http://localhost:9081) e inicie sesiÃ³n.\n  Descargue su token de autenticaciÃ³n de Meshery haciendo clic en Get Token debajo de su perfil de usuario.\n  Utilice este token de autenticaciÃ³n para ejecutar el siguiente comando:\n    $ mesheryctl system config gke --token &lt;RUTA AL ARCHIVO DE TOKEN&gt;\n    \n  \n\n\nEste comando actualiza su kubeconfig para proporcionar a Meshery acceso a su instancia administrada de Kubernetes.\nUna vez configurado, proceda con Meshery (mesheryctl system start).\n\nConfiguraciÃ³n Manual (Opcional)\n\nSi el procedimiento ConfiguraciÃ³n automÃ¡tica falla Ã³ si desea preparar manualmente su archivo kubeconfig para proporcionar a Meshery el acceso necesario a su instancia administrada de Kubernetes, realice las siguientes acciones:\n\n\n  Descargue el script de shell generate_kubeconfig_gke.sh.\n  \n    Ejecute este script de shell que identifica el nombre de la cuenta de servicio y los argumentos del espacio de nombres, de esta manera:\n\n    ./generate_kubeconfig_gke.sh cluster-admin-sa-gke default\n    \n  \n  \n    Una vez que el script haya terminado por completo, puede proceder a iniciar Meshery con la configuraciÃ³n compatible con GKE ejecutando:\n\n    $ mesheryctl system start\n    \n  \n  En su navegador, navegue hasta Meshery (por ejemplo,, http://localhost:9081) e inicie su sesiÃ³n.\n  En la secciÃ³n Settingsâ€“&gt;Environment, introduzca el archivo generado (config-cluster-admin-sa-gke-default.yaml) como el archivo kubeconfig.\n\n\nMeshery ahora deberÃ­a estar conectado con su instancia administrada de Kubernetes. Entre a visualizar las guÃ­as Meshery para que obtenga consejos de uso avanzado."
					}
					
				
		
				
					,
					
					"project": {
						"id": "project",
						"title": "Layer5 Community",
						"categories": "",
						"url": " /project",
						"content": "The Meshery project is maintained by the Layer5 community. We are an open source organization that adheres to the CNCFâ€™s Code of Conduct. Our projects advance the state of the art surrounding service meshes and enable adopters of Cloud Native technologies and techniques to do so with confidence. Our shared commitment to the open source spirit pushes Layer5 projects forward.\n\nCommunity First\n\nThe Layer5 community represents the largest collection of service mesh projects and their maintainers in the world.\nThe Meshery project is community-built and welcomes collaboration! \n Fork here on Github\n\n\n  Join weekly community meeting Fridays from 10am to 11am Central.\n    \n      Watch community meeting recordings and subscribe to the community calendar.\n    \n  \n  Access the community drive (request access).\n\n\nGetting involved in the Community\n\nWant to get involved with project, join our Slack and one of the community members will make sure you are not left out. We always have a role for everyone whether to be a code-writer, a community manager, user, advocate, or just to listen in. Layer5 community is always open and warmly welcomes you. Check out our community welcome guide for more details.\nIf this is your first time making open source contribution, you are in the right place! Check out our first timersâ€™ welcome guide.\n\nPlease see our contributing guide for more details.\n\nPresentations\n\n\n\nDelivered at Service Mesh Day 2019\n\nPast presentations of Meshery:\n\n\n  Oâ€™Reilly OSCON 2020\n  Oâ€™Reilly Infrastructure &amp; Ops 2020\n  InnoTech Dallas 2020\n  KubeCon EU 2020\n  DockerCon 2020 (deck, video)\n  Open Source 101 at Home\n  Docker Captains Roundtable 2020\n  Cloud Native Austin 2020\n  NSMCon 2019 talk (video, deck)\n  Service Mesh Day 2019\n  DockerCon 2019 Open Source Summit\n  KubeCon EU 2019 (video, deck)\n  KubeCon EU 2019 Istio Founders Meetup\n  Cloud Native Rejekts EU 2019\n  Container World 2019\n  Solving the Service Mesh Adopterâ€™s Dilemma (deck, event,video)\n\n\nTalking about Meshery?\n\nGiving a talk or hosting a meetup about Meshery? Leverage existing slides or request swag to support your talk.\n\n\n    Share your event\n    Access slides and resources"
					}
					
				
		
				
					,
					
					"es-installation": {
						"id": "es-installation",
						"title": "Installation Guide",
						"categories": "",
						"url": " /es/installation",
						"content": "Inicio RÃ¡pido\n\nPoner a correr Meshery en un sistema habilitado con Docker, es fÃ¡cil. Usa la interfaz de linea de comandos Meshery, mesheryctl, para empezar Meshery en cualquiera de sus plataformas soportadas.\n\nUsando mesheryctl\n\nmesheryctl es una interfaz de lÃ­nea de comandos para administrar un Desplegado (deployment) Meshery. mesheryctl le permite controlar el ciclo de vida de Meshery con comandos como start, stop, status, reset. Ejecutando reset removerÃ¡ todas las instancias de contenedor activas, poda las imÃ¡genes jaladas y remueve todos los volÃºmenes locales creados iniciando Meshery.\n\nMac Ã³ Linux\n\nEmplea tu elecciÃ³n de homebrew o bash para instalar mesheryctl. Tu solo necesitas usarlo una vez.\n\nHomebrew\n\nInstala mesheryctl y ejecuta Meshery en Mac con Homebrew.\n\nInstalando con Homebrew\n\nPara instalar mesheryctl, ejecute el siguiente comando:\n\nbrew tap layer5io/tap\nbrew install mesheryctl\nmesheryctl system start\n\n\nActualizando con Homebrew\n\nPara actualizar mesheryctl, ejecute el siguiente comando:\n\nbrew upgrade mesheryctl\n\n\nBash\n\nInstalando con Bash\n\nInstala mesheryctl y ejecuta Meshery en Mac Ã³ Linux con este script:\n\ncurl -L https://git.io/meshery | bash -\n\n\nActualizando con Bash\n\nActualiza mesheryctl y corre Meshery en Mac Ã³ Linux con este script:\n\ncurl -L https://git.io/meshery | bash -\n\n\nWindows\n\nInstalando el binario mesheryctl\n\nDescarga y descomprime mesheryctl desde la pÃ¡gina de Liberaciones Meshery. Agrega mesheryctl a tu PATH para facilitar el uso. DespuÃ©s, ejecuta:\n\n./mesheryctl system start\n\n\nScoop\n\nUsa Scoop para instalar Meshery en tu mÃ¡quina Windows.\n\nInstalando con Scoop\n\nAgrega el Meshery Scoop Bucket e instala:\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\nActualizando con Scoop\n\nPara actualizar mesheryctl, ejecuta el siguiente comando:\n\nscoop update mesheryctl\n\n\nInstalaciÃ³n Advanzada\n\nLos Usuarios pueden controlar la imagen de contenedor especÃ­fico y etiqueta(versiÃ³n) de Meshery que quieran ejecutar mediante la ediciÃ³n de su archivo local ~/.meshery/meshery.yaml (un archivo de docker compose).\nAlineado con la imagen de contenedor Meshery, en lugar de dejar la etiqueta implÃ­cita :stable-latest detrÃ¡s de la imagen: layer5/meshery, los usuarios, en vez de esto, identificarÃ¡n una etiqueta de imagen especÃ­fica asÃ­:\n\nversion: '3'\nservices:\n  meshery:\n    image: layer5/meshery:v0.5.0\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n\n\n\n\nCuando Meshery estÃ¡ levantado y corriendo, las instrucciones para acceder Meshery serÃ¡n impresas en la pantalla y su navegador web por default deberÃ¡ ser dirigido a la pantalla de inicio de Meshery."
					}
					
				
		
				
					,
					
					"es-functionality": {
						"id": "es-functionality",
						"title": "Functionality",
						"categories": "",
						"url": " /es/functionality",
						"content": "Funcionalidades de Meshery\n\nEstas secciones proveen guÃ­as de usuario sobre las funcionalidades que ofrece Meshery.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Functionality\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Lifecycle Management\n      \n    \n    Lifecycle Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Performance Management\n      \n    \n    Performance Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Meshery and Service Mesh Interface (SMI)\n      \n    \n    \n    \n    SMI Conformance Capability"
					}
					
				
		
				
					,
					
					"service-meshes": {
						"id": "service-meshes",
						"title": "Service Meshes",
						"categories": "",
						"url": " /service-meshes",
						"content": "As the multi-mesh manager, Meshery offers support for more adapters than any other project or product in the world. Learn more about Meshery Adapters in the Architecture section.\n\nSupport for Service Meshes\n\n\n  \n    \n      Service Mesh\n      Service Mesh Version\n    \n  \n  \n    \n       Meshery Adapter for App Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v0.1.0\n    \n    \n       Meshery Adapter for Consul\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v1.8.2\n    \n    \n       Meshery Adapter for Citrix Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  1.0\n    \n    \n       Meshery Adapter for Istio\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v1.8.1\n    \n    \n       Meshery Adapter for Kuma\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v1.0\n    \n    \n       Meshery Adapter for Linkerd\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v2.5.0\n    \n    \n       Meshery Adapter for NGINX Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v0.6.0\n    \n    \n       Meshery Adapter for Network Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v0.2.1\n    \n    \n       Meshery Adapter for Octarine\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v1.0\n    \n    \n       Meshery Adapter for Open Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v0.5.0\n    \n    \n       Meshery Adapter for Tanzu Service Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  pre-GA\n    \n    \n       Meshery Adapter for Traefik Mesh\n      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â  v1.0\n    \n  \n\n\nMeshery supports the following service meshes. It uses both abstraction APIs and service mesh-specific adapters to interface with and manage service meshes. Review the full list of Meshery adapters."
					}
					
				
		
				
					,
					
					"es-project": {
						"id": "es-project",
						"title": "Proyecto",
						"categories": "",
						"url": " /es/project",
						"content": "Proyectos Layer5\n\nEl proyecto Meshery es mantenido por la comunidad Layer5. Somos una organizaciÃ³n de cÃ³digo abierto saludable que se rige por el CÃ³digo de conducta de CNCF.\n\nInvolucrarse en la comunidad\n\nSi quieres participar en el proyecto, Ãºnete a nuestro Slack y uno de los miembros de la comunidad se asegurarÃ¡ de que no te quedes fuera. Siempre tenemos un papel para todos, ya sea que seamos redactores de cÃ³digos, administradores de la comunidad, usuarios, defensores o simplemente para escuchar. La comunidad de Layer5 siempre estÃ¡ abierta y te da una calurosa bienvenida. Consulta nuestra guÃ­a de bienvenida de la comunidad para obtener mÃ¡s detalles.\nSi es la primera vez que realizas una contribuciÃ³n de cÃ³digo abierto, Â¡estÃ¡s en el lugar correcto! Consulta nuestra guÃ­a de bienvenida para principiantes.\n\nConsulta nuestra guÃ­a para contribuciones para obtener mÃ¡s detalles.\n\nAcerca de Layer5\n\nPrimero la comunidad\n\nLa comunidad Layer5 representa la colecciÃ³n mÃ¡s grande de proyectos de service mesh y sus maintainers en el mundo.\n\nPrimero el cÃ³digo abierto\n\nCreamos proyectos para proporcionar entornos de aprendizaje, implementaciÃ³n, mejores prÃ¡cticas operativas, evaluaciones comparativas de desempeÃ±o, creaciÃ³n de documentaciÃ³n, compartir oportunidades de networking y mÃ¡s. Nuestro compromiso compartido con el espÃ­ritu de cÃ³digo abierto impulsa los proyectos de Layer5 hacia adelante."
					}
					
				
		
				
					,
					
					"guides": {
						"id": "guides",
						"title": "Operation Guides",
						"categories": "",
						"url": " /guides",
						"content": "Guides to using Mesheryâ€™s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Using mesheryctl\n      \n    \n    Upgrade `mesheryctl` and Meshery\n      \n    \n    Deploying Sample Applications\n      \n    \n    Using Multiple Adapters\n      \n    \n    Using Metrics in Meshery"
					}
					
				
		
				
					,
					
					"reference": {
						"id": "reference",
						"title": "Reference",
						"categories": "",
						"url": " /reference",
						"content": "References for using Mesheryâ€™s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Extensibility: Service Mesh Adapters\n      \n        -  Meshery architecture is extensible. Meshery provides several extension points for working with different service meshes via adapters, load generators and providers.\n      \n      \n      \n    \n    Extensibility: Load Generators\n      \n        -  Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n      \n      \n      \n    \n    Extensibility: Providers\n      \n        -  Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes.\n      \n      \n      \n    \n    mesheryctl Command Reference\n      \n        -  A guide to Meshery's CLI: mesheryctl\n      \n      \n      \n    \n    Extensibility\n      \n        -  Meshery architecture is extensible. Meshery provides several extension points for working with different service meshes via adapters, load generators and providers.\n      \n      \n      \n    \n    Extensibility: APIs\n      \n        -  Meshery architecture is extensible, offering an array of extension points and REST and GraphQL APIs."
					}
					
				
		
				
					,
					
					"installation-quick-start": {
						"id": "installation-quick-start",
						"title": "Quick Start Guide",
						"categories": "",
						"url": " /installation/quick-start",
						"content": "Getting Meshery up and running locally on a Docker-enabled system is easy with Mesheryâ€™s command line interface, mesheryctl.\n\nConfigure Your Environment\n\nMeshery deploys as a set of Docker containers, which can be deployed to either a Docker host or Kubernetes cluster. See the complete list of its supported platforms.\n\nInstall Meshery\n\nUse the Meshery command line interface, , to install and start Meshery. Begin with Meshery by installing its command line client: mesheryctl. If you are on a MacOS or Linux system, you can download, install, and run to the management plane with the command shown in the figure.\n\n\n \n $ curl -L https://git.io/meshery | bash - \n \n \n\nDownload, install, and run Meshery in a single command.\n\nAccess Meshery\n\nVisit Mesheryâ€™s web-based user interface http://&lt;hostname&gt;:9081. When Meshery is installed on a Docker host, your default browser will be opened and navigated to http://localhost:9081.\n\nSelect a Provider\nSelect from the list of Providers in order to login to Meshery. Authenticate with your chosen your Provider.\n\n\n  \n\n\nConfigure Connection to Kubernetes\nMeshery attempts to auto detect your kubeconfig if it is stored in the default path ($HOME/.kube) on your system. In most deployments, Meshery will automatically connect to your Kubernetes cluster. Ensure that Meshery is connected to your your Kubernetes cluster.\n\nVisit  Settings:\n\n\n  \n  \n\nIf your config has not been auto-detected, you may manually locate and upload your kube config file and select the context name (docker-desktop, kind-clsuter, minikube etc.)\n\nVerify Mesheryâ€™s Deployment\nRun connectivity tests and verify the health of your Meshery system. Verify Mesheryâ€™s connection to Kubernetes by clicking on your configuration context name. You will be notified of your connection status. You can also verify a successful connection between Meshery and its adapters by clicking on any of the available Adapter Ports.\n\n\n\n\n\nOperate service meshes and their workloads\nYou may now proceed to install and work with any service mesh supported by Meshery.\n\n\n  \n Your browser does not support the video tag"
					}
					
				
		
				
					,
					
					"": {
						"id": "",
						"title": "Meshery Documentation",
						"categories": "",
						"url": " /",
						"content": "Meshery is the open source, service mesh management plane for enabling the adoption, operation, and management of any service mesh and their workloads.\n\n\n  \n  \n    \n        Quick&nbsp;Start\n    \n    Getting Started\n        Introducing Meshery\n        Project and Community        \n    \n    Supported Platforms\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        AKS\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Docker\n          \n          \n        \n        \n        \n        EKS\n          \n          \n        \n        \n        \n        \n        \n        GKE\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        KinD\n          \n          \n        \n        \n        \n        Kubernetes\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Minikube\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Windows\n          \n          \n        \n        \n        \n        \n        \n      \n  \n  \n  \n  \n    \n        Concepts\n    \n    Concepts\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Adapters\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      Architecture\n        \n        \n      \n      \n      \n      \n      \n      Broker\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      Database\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      MeshSync\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Operator\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n    Functionality\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Lifecycle Management\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Performance Management\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Meshery and Service Mesh Interface (SMI)\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    \n    Service Mesh Management\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n       Meshery Adapter for App Mesh\n       Meshery Adapter for Consul\n       Meshery Adapter for Citrix Service Mesh\n       Meshery Adapter for Istio\n       Meshery Adapter for Kuma\n       Meshery Adapter for Linkerd\n       Meshery Adapter for NGINX Service Mesh\n       Meshery Adapter for Network Service Mesh\n       Meshery Adapter for Octarine\n       Meshery Adapter for Open Service Mesh\n       Meshery Adapter for Tanzu Service Mesh\n       Meshery Adapter for Traefik Mesh\n      \n    \n  \n\n  \n  \n    \n        Guides\n    \n    Guides\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Using Metrics in Meshery\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Using Multiple Adapters\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Deploying Sample Applications\n        \n        \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      Upgrade `mesheryctl` and Meshery\n        \n        \n      \n      \n      \n      \n      \n      Using mesheryctl\n        \n        \n      \n    \n    Reference\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Service Mesh Adapters\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: APIs\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Load Generators\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        mesheryctl Command Reference\n          \n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        Extensibility: Providers"
					}
					
				
		
				
					,
					
					"concepts": {
						"id": "concepts",
						"title": "Concepts",
						"categories": "",
						"url": " /concepts",
						"content": "Concepts for understanding Mesheryâ€™s various features and components.\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Operator\n      \n        -  Meshery Operator controls and manages the lifeycle of components deployed inside a kubernetes cluster\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    MeshSync\n      \n        -  Meshery offers support for kubernetes cluster/service mesh state synchronization with the help of MeshSync.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Database\n      \n        -  Meshery offers support for internal caching with the help of file databases. This has been implemented with several libraries that supports different kinds of data formats.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    Broker\n      \n        -  Meshery broker component fascilitates data streaming between kubernetes cluster components and outside world.\n      \n      \n      \n    \n    \n    \n    \n    \n    Architecture\n      \n        -  overview of different individual components of Meshery architecture and how they interact as a system.\n      \n      \n      \n    \n    \n    \n    \n    \n    \n    \n    Adapters\n      \n        -  Meshery offers support for more adapters than any other project or product in the world. Meshery uses adapters for managing the various service meshes."
					}
					
				
		
				
					,
					
					"functionality": {
						"id": "functionality",
						"title": "Functionality",
						"categories": "",
						"url": " /functionality",
						"content": "These sections provide user guides to the functionality Meshery offers.\nMeshery Functionality\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Lifecycle Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Performance Management\n      \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    Meshery and Service Mesh Interface (SMI)"
					}
					
				
		
				
					,
					
					"es": {
						"id": "es",
						"title": "DocumentaciÃ³n en EspaÃ±ol ğŸ‡²ğŸ‡½",
						"categories": "",
						"url": " /es",
						"content": "DocumentaciÃ³n en EspaÃ±ol ğŸ‡²ğŸ‡½\n    \n\n\n\n\n\n    \n        Quick&nbsp;Start\n    \n    Getting Started\n        Introducing Meshery\n        Project and Community\n    \n    Supported Platforms\n        \n        \n        \n        \n          AKS\n          \n        \n        \n        \n        \n        \n        \n          Docker\n          \n        \n        \n          EKS\n          \n        \n        \n          GKE\n          \n        \n        \n        \n        \n        \n        \n          KinD\n          \n        \n        \n          Kubernetes\n          \n        \n        \n        \n        \n          Minikube\n          \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n          Windows"
					}
					
				
		
				
					,
					
					"guides-interpreting-performance-test-results": {
						"id": "guides-interpreting-performance-test-results",
						"title": "Interpreting Performance Test Results",
						"categories": "",
						"url": " /guides/interpreting-performance-test-results",
						"content": "Once a performance tests and run, itâ€™s disco analysis is performed and test results persisted. Results or downloadable and persisted in the Service Mesh Performance (SMP) format.\n\nGraphical View\n\n\n\n\n\nTests\n\nFor the best experience, you should compare between two or more tests of similar configuration. Tests that are configured with a high degree of variance (e.g., one test ran for a duration of 5 minutes, while another test ran for a duration of 1 hour) will produce comparisons that are more difficult to extrapolate insights from.\n\nLatency and throughput are the two most significantly examined signals.\n\nMeshery will use different algorithms to calculate results depending upon which load generator was used to run the test."
					}
					
				
		
				
					,
					
					"es-installation-platforms-kind": {
						"id": "es-installation-platforms-kind",
						"title": "KinD",
						"categories": "",
						"url": " /es/installation/platforms/kind",
						"content": "Inicio RÃ¡pido con KinD\n\nPara configurar y ejecutar Meshery en KinD:\n\n\n  Instalar kinD\n  Crear un cluster Kubernetes con kinD\n    \n      Acceder al cluster kinD\n    \n  \n  Alternativamente, Ejecute Helm\n\n\nInstalaciÃ³n\n\n\n  En Mac / Linux mediante Homebrew (Recomendado):\n\n\nbrew install kind\n\n\n\n  En macOS / Linux mediante curl:\n\n\ncurl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.8.1/kind-$(uname)-amd64\nchmod +x ./kind\nmv ./kind /some-dir-in-your-PATH/kind\n\n\nSi estÃ¡ ejecutando Ubuntu en WSL2, use la distro Docker Ubuntu para instalar Docker.\n\nCrear cluster usando KinD\n\nCon el fin de construir exitosamente el servidor Meshery en su servidor local, siga las instrucciones especÃ­ficas a su Sistema Operativo para completar la creaciÃ³n de un cluster KinD.\n\n1. KinD en WSL2\n\nPrimero que nada, obtendremos la direcciÃ³n ip de su distro WSL2 mediante:\n\nip addr | grep eth0\n\n\nUsted verÃ¡ una salida como:\n\n4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    inet 172.1.1.1/20 brd 172.1.1.255 scope global eth0\n\n\nCopie la direcciÃ³n IP, la usaremos en el siguiente paso.\n\nLo siguiente es, crear un archivo que tenga el nombre kind_cluster.yaml y capture la direcciÃ³n ip en el campo apiServerAddress:\n\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nnetworking:\n  apiServerAddress: \"172.1.1.1\"\n\n\nAhora cree el cluster KinD con el archivo de configuraciÃ³n kind_cluster.yaml:\n\nkind create cluster --config kind_cluster.yaml --name kind --wait 300s\n\n\nUsted verÃ¡:\n\nCreating cluster \"kind\" ...\n â€¢ Ensuring node image (kindest/node:v1.17.0) ğŸ–¼  ...\n âœ“ Ensuring node image (kindest/node:v1.17.0) ğŸ–¼\n â€¢ Preparing nodes ğŸ“¦   ...\n âœ“ Preparing nodes ğŸ“¦\n â€¢ Writing configuration ğŸ“œ  ...\n âœ“ Writing configuration ğŸ“œ\n â€¢ Starting control-plane ğŸ•¹ï¸  ...\n âœ“ Starting control-plane ğŸ•¹ï¸\n â€¢ Installing CNI ğŸ”Œ  ...\n âœ“ Installing CNI ğŸ”Œ\n â€¢ Installing StorageClass ğŸ’¾  ...\n âœ“ Installing StorageClass ğŸ’¾\n â€¢ Waiting â‰¤ 5m0s for control-plane = Ready â³  ...\n âœ“ Waiting â‰¤ 5m0s for control-plane = Ready â³\n â€¢ Ready after 59s ğŸ’š\nSet kubectl context to \"kind-kind\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kind\n\nNot sure what to do next? ğŸ˜… Check out https://kind.sigs.k8s.io/docs/user/quick-start/\n\n\n2. KinD en otros sistemas\n\nCrear un cluster Kubernetes es tan simple como ejecutar kind create cluster.\n\nPara obtener mÃ¡s configuraciÃ³n de la instalaciÃ³n, consulte la documentaciÃ³n oficial de KinD.\n\nAccediendo el cluster KinD\n\nDe forma predeterminada, la configuraciÃ³n de acceso al clÃºster se almacena en ${HOME}/.kube/config si la variable de entorno $KUBECONFIG no estÃ¡ establecida. Usted puede establecer esta variable de ambiente KUBECONFIG con el siguiente comando:\n\nexport KUBECONFIG=${HOME}/.kube/config\n\n\nUtilice el siguiente comando para verificar la conexiÃ³n del clÃºster y asegurarse de que el clÃºster al que se que conectÃ³, es el clÃºster que fue creado por KinD:\n\nkubectl cluster-info --context kind-kind\n\n\nPara borrar su cluster use:\n\nkind delete cluster --name kind\n\n\nUsando Helm\n\nHelm v3\n\nRecomendamos encarecidamente utilizar Helm v3, debido a que la versiÃ³n actual ya no incluye el componente Tiller(https://helm.sh/blog/helm-3-preview-pt2/#helm). Es mÃ¡s ligero y seguro de esta manera.\n\nEjecute lo siguienteg:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n\n\n\n  NodePort - Si su cluster no cuenta con un Controlador Ingress (Ingress Controller) o un balanceador de cargas, entonces utilice NodePort para exponer Meshery y que pueda ser modificado en values.yaml:\n\n\nservice:\n  type: NodePort\n  port: 8080\n  annotations: {}"
					}
					
				
		
				
					,
					
					"installation-platforms-kind": {
						"id": "installation-platforms-kind",
						"title": "KinD",
						"categories": "",
						"url": " /installation/platforms/kind",
						"content": "Quick Start with KinD \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on KinD\n\n\n  Install kinD\n  Create a Kubernetes cluster with kinD\n    \n      Access the kinD cluster\n    \n  \n  Alternatively, Run Helm\n\n\nInstallation\n\n\n  On Mac / Linux via Homebrew (Recommended):\n\n\n\n \n brew install kind\n \n \n\n\n  On macOS / Linux via curl:\n\n\n\n \n curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.8.1/kind-$(uname)-amd64\n chmod +x ./kind\n mv ./kind /some-dir-in-your-PATH/kind\n \n \n\nIf you are running Ubuntu on WSL2, use Docker Ubuntu distro to install Docker.\n\nCreate cluster using KinD\n\nIn order to successfully build the Meshery server on your local server, follow the instructions specific to your Operating System to complete the creation of a KinD cluster.\n\n1. KinD on WSL2\n\nFirst, we will get the ip address of your WSL2 distro by:\n\n\n \n ip addr | grep eth0\n \n \n\nYou will see the output like:\n\n\n \n 4: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000\n    inet 172.1.1.1/20 brd 172.1.1.255 scope global eth0\n \n \n\nCopy the ip address, we will use that in the next step.\n\nThen, create a file called kind_cluster.yaml and put the ip address under apiServerAddress:\n\n\n \n kind: Cluster\n apiVersion: kind.x-k8s.io/v1alpha4\n networking:\n   apiServerAddress: \"172.1.1.1\"\n \n \n\nNow create the KinD cluster with the config file kind_cluster.yaml:\n\n\n \n kind create cluster --config kind_cluster.yaml --name kind --wait 300s\n \n \n\nYou will see\n\nCreating cluster \"kind\" ...\n â€¢ Ensuring node image (kindest/node:v1.17.0) ğŸ–¼  ...\n âœ“ Ensuring node image (kindest/node:v1.17.0) ğŸ–¼\n â€¢ Preparing nodes ğŸ“¦   ...\n âœ“ Preparing nodes ğŸ“¦\n â€¢ Writing configuration ğŸ“œ  ...\n âœ“ Writing configuration ğŸ“œ\n â€¢ Starting control-plane ğŸ•¹ï¸  ...\n âœ“ Starting control-plane ğŸ•¹ï¸\n â€¢ Installing CNI ğŸ”Œ  ...\n âœ“ Installing CNI ğŸ”Œ\n â€¢ Installing StorageClass ğŸ’¾  ...\n âœ“ Installing StorageClass ğŸ’¾\n â€¢ Waiting â‰¤ 5m0s for control-plane = Ready â³  ...\n âœ“ Waiting â‰¤ 5m0s for control-plane = Ready â³\n â€¢ Ready after 59s ğŸ’š\nSet kubectl context to \"kind-kind\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-kind\n\nNot sure what to do next? ğŸ˜… Check out https://kind.sigs.k8s.io/docs/user/quick-start/\n\n\n2. KinD on other systems\n\nCreating a Kubernetes cluster is as simple as kind create cluster.\n\nFor more configuration of installation, please refer to KinD official documentation.\n\nAccess the KinD cluster\n\nBy default, the cluster access configuration is stored in ${HOME}/.kube/config if $KUBECONFIG environment variable is not set. You can set the KUBECONFIG environment with the command below:\n\n\n \n export KUBECONFIG=${HOME}/.kube/config\n \n \n\nUse the command below check the connection of the cluster and make sure the cluster you connected whatâ€™s the cluster was created by KinD:\n\n\n \n kubectl cluster-info --context kind-kind\n \n \n\nTo delete your cluster use:\n\n\n \n kind delete cluster --name kind\n \n \n\nUsing Helm\n\nHelm v3\n\nWe strongly recommend to use Helm v3, because of this version not including the Tiller(https://helm.sh/blog/helm-3-preview-pt2/#helm) component anymore. Itâ€™s lighter and safer.\n\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n \n \n\n\n  NodePort - If your cluster does not have an Ingress Controller or a load balancer, then use NodePort to expose Meshery and that can be modify under the chart values.yaml:\n\n\n\n \n service:\n   type: NodePort\n   port: 8080\n   annotations: {}\n \n \n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}
					
				
		
				
					,
					
					"es-installation-platforms-kubernetes": {
						"id": "es-installation-platforms-kubernetes",
						"title": "Kubernetes",
						"categories": "",
						"url": " /es/installation/platforms/kubernetes",
						"content": "Inicio RÃ¡pido con Kubernetes\n\nPara preparar y ejecutar Meshery en Kubernetes:\n\n\n  \n     Use Helm y configure un cluster Kubernetes \n  \n  \n    Ejecutar Meshery en un cluster Kubernetes existente\n  \n\n\nUsando Helm\n\n1. Helm v3\n\nEjecute lo siguiente:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n\n\n2. Helm v2\n\nEjecute lo siguiente:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n$ kubectl create namespace meshery\n$ helm template meshery --namespace meshery install/kubernetes/helm/meshery | kubectl apply -f -\n\n\nUsando el Manifiesto de Kubernetes\n\nMeshery tambiÃ©n puede ser desplegado(deployed) en un clÃºster de Kubernetes existente.Vea tabla de compatibilidades para la compatibilidad de versiones. Para instalar Meshery en su cluster, clone el repositorio de Meshery:\n\n$ git clone https://github.com/layer5io/meshery.git; cd meshery\n\n\nCree un nombre de espacio (namespace) como un nuevo espacio lÃ³gico para hospedar Meshery y sus componentes:\n\n$ kubectl create ns meshery\n\n\nTodos los yamls de despliegue necesarios para desplegar(deploy) Meshery se incluyen en la carpeta Ê»install / deployment_yamls / k8s` dentro de la carpeta Meshery clonada. Para implementar los yamls en el clÃºster, ejecute el siguiente comando:\n\n$ kubectl -n meshery apply -f install/deployment_yamls/k8s\n\n\nUna vez que se desplieguen los archivos yaml, necesitamos exponer el servicio meshery para poder acceder al servicio desde fuera del clÃºster. Hay varias formas de exponer un servicio en Kubernetes. AquÃ­ describiremos 3 formas comunes en las que podemos exponer un servicio:\n\n\n  Ingress - Si su cluster Kubernetes tiene un Controlador Ingress (Ingress Controller) funcional, entonces usted puede configurar un ingreso para exponer Meshery:\n\n\napiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\nname: meshery-ingress\nannotations:\n    kubernetes.io/ingress.class: \"nginx\"\nspec:\nrules:\n- host: *\n    http:\n    paths:\n    - path: /\n        backend:\n        serviceName: meshery-service\n        servicePort: 8080\n\n\n\n  \n    Balanceador de Cargas -\nSi su clÃºster de Kubernetes tiene un balanceador de carga externo, esta podrÃ­a ser la ruta lÃ³gica.\n  \n  \n    NodePort -\nSi su clÃºster no tiene un Controlador Ingress (Ingress Controller) o un balanceador de carga, use NodePort para exponer Meshery:\n  \n\n\napiVersion: v1\nkind: Service\nspec:\n    type: NodePort\n\n\nMeshery debe ahora ser conectado con su instancia administrada de Kubernetes. Eche un vistazo a las guÃ­as guÃ­as Meshery para tips de uso advanzado."
					}
					
				
		
				
					,
					
					"installation-platforms-kubernetes": {
						"id": "installation-platforms-kubernetes",
						"title": "Kubernetes",
						"categories": "",
						"url": " /installation/platforms/kubernetes",
						"content": "Quick Start with Kubernetes \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo set up and run Meshery on Kubernetes\n\n\n   Use Helm and set up a Kubernetes cluster\n  Run Meshery on existing Kubernetes cluster\n\n\nUsing Helm\n\n1. Helm v3\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm install meshery --namespace meshery install/kubernetes/helm/meshery\n \n \n\n2. Helm v2\nRun the following:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; cd meshery\n $ kubectl create namespace meshery\n $ helm template meshery --namespace meshery install/kubernetes/helm/meshery | kubectl apply -f -\n \n \n\nUsing Kubernetes Manifests\nMeshery can also be deployed on an existing Kubernetes cluster. See compatibility table for version compatibility. To install Meshery on your cluster, clone the Meshery repo:\n\n\n \n $ git clone https://github.com/layer5io/meshery.git; \n $ cd meshery\n \n \n\nCreate a namespace as a new logical space to host Meshery and its components:\n\n\n \n $ kubectl create ns meshery\n \n \n\nAll the needed deployment yamls for deploying Meshery are included in the install/deployment_yamls/k8s folder inside the cloned Meshery folder. To deploy the yamls on the cluster please run the following command:\n\n\n \n $ kubectl -n meshery apply -f install/deployment_yamls/k8s\n \n \n\nOnce the yaml files are deployed, we need to expose the meshery service to be able to access the service from outside the cluster. There are several ways a service can be exposed on Kubernetes. Here we will describe 3 common ways we can expose a service:\n\nIngress\n\nIf your Kubernetes cluster has a functional Ingress Controller, then you can configure an ingress to expose Meshery:\n\n\n \n apiVersion: extensions/v1beta1\n kind: Ingress\n metadata:\n name: meshery-ingress\n annotations:\n     kubernetes.io/ingress.class: \"nginx\"\n spec:\n rules:\n - host: *\n     http:\n     paths:\n     - path: /\n         backend:\n         serviceName: meshery-service\n         servicePort: 8080\n \n \n\n\n  \n    LoadBalancer - If your Kubernetes cluster has an external load balancer, this might be a logical route.\n  \n  \n    NodePort - If your cluster does not have an Ingress Controller or a load balancer, then use NodePort to expose Meshery:\n  \n\n\n\n \n apiVersion: v1\n kind: Service\n spec:\n     type: NodePort\n \n \n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}
					
				
		
				
					,
					
					"extensibility-load-generators": {
						"id": "extensibility-load-generators",
						"title": "Extensibility: Load Generators",
						"categories": "",
						"url": " /extensibility/load-generators",
						"content": "Users may prefer to use one load generator over the next given the difference of capabilities between load generators, so Meshery provides a load generator interface (a gRPC interface) behind which a load generator can be implemented. Meshery provides users with choice of which load generator they prefer to use for a given performance test. Users may set their configure their own preference of load generator different that the default load generator.\n\nWhat function do load generators in Meshery provide?\n\nLoad generators will provide the capability to run load tests from Meshery. As of today the load generators are embedded as libraries in Meshery and Meshery invokes the load generators APIs with the right load test options to run the load test. At the moment, Meshery has support for HTTP load generators. Support for GRPC and TCP load testing is on the roadmap. Meshery has functional integration with fortio, wrk2, and nighthawk.\n\nWhy support multiple load generators?\n\nDifferent use cases and different opinions call for different approaches to statistical analysis of the performance results. For example, wrk2 accounts for a concept called Coordinated Omission.\n\nWhich load generators does Meshery support?\n\n\n  fortio - Fortio load testing library, command line tool, advanced echo server and web UI in go (golang). Allows to specify a set query-per-second load and record latency histograms and other useful stats.\n  wrk2 - A constant throughput, correct latency recording variant of wrk.\n  nighthawk - Enables users to run distributed performance tests to better mimic real-world, distributed systems scenarios.\n    \n      See the GetNighthawk project."
					}
					
				
		
				
					,
					
					"assets-js-lunr-min-js": {
						"id": "assets-js-lunr-min-js",
						"title": "",
						"categories": "",
						"url": " /assets/js/lunr.min.js",
						"content": "/**\n * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 0.7.0\n * Copyright (C) 2016 Oliver Nightingale\n * MIT Licensed\n * @license\n */\n!function(){var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version=\"0.7.0\",t.utils={},t.utils.warn=function(t){return function(e){t.console&&console.warn&&console.warn(e)}}(this),t.utils.asString=function(t){return void 0===t||null===t?\"\":t.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var t=Array.prototype.slice.call(arguments),e=t.pop(),n=t;if(\"function\"!=typeof e)throw new TypeError(\"last argument must be a function\");n.forEach(function(t){this.hasHandler(t)||(this.events[t]=[]),this.events[t].push(e)},this)},t.EventEmitter.prototype.removeListener=function(t,e){if(this.hasHandler(t)){var n=this.events[t].indexOf(e);this.events[t].splice(n,1),this.events[t].length||delete this.events[t]}},t.EventEmitter.prototype.emit=function(t){if(this.hasHandler(t)){var e=Array.prototype.slice.call(arguments,1);this.events[t].forEach(function(t){t.apply(void 0,e)})}},t.EventEmitter.prototype.hasHandler=function(t){return t in this.events},t.tokenizer=function(e){return arguments.length&&null!=e&&void 0!=e?Array.isArray(e)?e.map(function(e){return t.utils.asString(e).toLowerCase()}):e.toString().trim().toLowerCase().split(t.tokenizer.seperator):[]},t.tokenizer.seperator=/[\\s\\-]+/,t.tokenizer.load=function(t){var e=this.registeredFunctions[t];if(!e)throw new Error(\"Cannot load un-registered function: \"+t);return e},t.tokenizer.label=\"default\",t.tokenizer.registeredFunctions={\"default\":t.tokenizer},t.tokenizer.registerFunction=function(e,n){n in this.registeredFunctions&&t.utils.warn(\"Overwriting existing tokenizer: \"+n),e.label=n,this.registeredFunctions[n]=e},t.Pipeline=function(){this._stack=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in this.registeredFunctions&&t.utils.warn(\"Overwriting existing registered function: \"+n),e.label=n,t.Pipeline.registeredFunctions[e.label]=e},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn(\"Function is not registered with pipeline. This may cause problems when serialising the index.\\n\",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.registeredFunctions[e];if(!i)throw new Error(\"Cannot load un-registered function: \"+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._stack.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._stack.indexOf(e);if(-1==i)throw new Error(\"Cannot find existingFn\");i+=1,this._stack.splice(i,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._stack.indexOf(e);if(-1==i)throw new Error(\"Cannot find existingFn\");this._stack.splice(i,0,n)},t.Pipeline.prototype.remove=function(t){var e=this._stack.indexOf(t);-1!=e&&this._stack.splice(e,1)},t.Pipeline.prototype.run=function(t){for(var e=[],n=t.length,i=this._stack.length,r=0;n>r;r++){for(var o=t[r],s=0;i>s&&(o=this._stack[s](o,r,t),void 0!==o&&\"\"!==o);s++);void 0!==o&&\"\"!==o&&e.push(o)}return e},t.Pipeline.prototype.reset=function(){this._stack=[]},t.Pipeline.prototype.toJSON=function(){return this._stack.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Vector=function(){this._magnitude=null,this.list=void 0,this.length=0},t.Vector.Node=function(t,e,n){this.idx=t,this.val=e,this.next=n},t.Vector.prototype.insert=function(e,n){this._magnitude=void 0;var i=this.list;if(!i)return this.list=new t.Vector.Node(e,n,i),this.length++;if(en.idx?n=n.next:(i+=e.val*n.val,e=e.next,n=n.next);return i},t.Vector.prototype.similarity=function(t){return this.dot(t)/(this.magnitude()*t.magnitude())},t.SortedSet=function(){this.length=0,this.elements=[]},t.SortedSet.load=function(t){var e=new this;return e.elements=t,e.length=t.length,e},t.SortedSet.prototype.add=function(){var t,e;for(t=0;t1;){if(o===t)return r;t>o&&(e=r),o>t&&(n=r),i=n-e,r=e+Math.floor(i/2),o=this.elements[r]}return o===t?r:-1},t.SortedSet.prototype.locationFor=function(t){for(var e=0,n=this.elements.length,i=n-e,r=e+Math.floor(i/2),o=this.elements[r];i>1;)t>o&&(e=r),o>t&&(n=r),i=n-e,r=e+Math.floor(i/2),o=this.elements[r];return o>t?r:t>o?r+1:void 0},t.SortedSet.prototype.intersect=function(e){for(var n=new t.SortedSet,i=0,r=0,o=this.length,s=e.length,a=this.elements,h=e.elements;;){if(i>o-1||r>s-1)break;a[i]!==h[r]?a[i]h[r]&&r++:(n.add(a[i]),i++,r++)}return n},t.SortedSet.prototype.clone=function(){var e=new t.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},t.SortedSet.prototype.union=function(t){var e,n,i;this.length>=t.length?(e=this,n=t):(e=t,n=this),i=e.clone();for(var r=0,o=n.toArray();rp;p++)c[p]===a&&d++;h+=d/f*l.boost}}this.tokenStore.add(a,{ref:o,tf:h})}n&&this.eventEmitter.emit(\"add\",e,this)},t.Index.prototype.remove=function(t,e){var n=t[this._ref],e=void 0===e?!0:e;if(this.documentStore.has(n)){var i=this.documentStore.get(n);this.documentStore.remove(n),i.forEach(function(t){this.tokenStore.remove(t,n)},this),e&&this.eventEmitter.emit(\"remove\",t,this)}},t.Index.prototype.update=function(t,e){var e=void 0===e?!0:e;this.remove(t,!1),this.add(t,!1),e&&this.eventEmitter.emit(\"update\",t,this)},t.Index.prototype.idf=function(t){var e=\"@\"+t;if(Object.prototype.hasOwnProperty.call(this._idfCache,e))return this._idfCache[e];var n=this.tokenStore.count(t),i=1;return n>0&&(i=1+Math.log(this.documentStore.length/n)),this._idfCache[e]=i},t.Index.prototype.search=function(e){var n=this.pipeline.run(this.tokenizerFn(e)),i=new t.Vector,r=[],o=this._fields.reduce(function(t,e){return t+e.boost},0),s=n.some(function(t){return this.tokenStore.has(t)},this);if(!s)return[];n.forEach(function(e,n,s){var a=1/s.length*this._fields.length*o,h=this,u=this.tokenStore.expand(e).reduce(function(n,r){var o=h.corpusTokens.indexOf(r),s=h.idf(r),u=1,l=new t.SortedSet;if(r!==e){var c=Math.max(3,r.length-e.length);u=1/Math.log(c)}o>-1&&i.insert(o,a*s*u);for(var f=h.tokenStore.get(r),d=Object.keys(f),p=d.length,v=0;p>v;v++)l.add(f[d[v]].ref);return n.union(l)},new t.SortedSet);r.push(u)},this);var a=r.reduce(function(t,e){return t.intersect(e)});return a.map(function(t){return{ref:t,score:i.similarity(this.documentVector(t))}},this).sort(function(t,e){return e.score-t.score})},t.Index.prototype.documentVector=function(e){for(var n=this.documentStore.get(e),i=n.length,r=new t.Vector,o=0;i>o;o++){var s=n.elements[o],a=this.tokenStore.get(s)[e].tf,h=this.idf(s);r.insert(this.corpusTokens.indexOf(s),a*h)}return r},t.Index.prototype.toJSON=function(){return{version:t.version,fields:this._fields,ref:this._ref,tokenizer:this.tokenizerFn.label,documentStore:this.documentStore.toJSON(),tokenStore:this.tokenStore.toJSON(),corpusTokens:this.corpusTokens.toJSON(),pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(t){var e=Array.prototype.slice.call(arguments,1);e.unshift(this),t.apply(this,e)},t.Store=function(){this.store={},this.length=0},t.Store.load=function(e){var n=new this;return n.length=e.length,n.store=Object.keys(e.store).reduce(function(n,i){return n[i]=t.SortedSet.load(e.store[i]),n},{}),n},t.Store.prototype.set=function(t,e){this.has(t)||this.length++,this.store[t]=e},t.Store.prototype.get=function(t){return this.store[t]},t.Store.prototype.has=function(t){return t in this.store},t.Store.prototype.remove=function(t){this.has(t)&&(delete this.store[t],this.length--)},t.Store.prototype.toJSON=function(){return{store:this.store,length:this.length}},t.stemmer=function(){var t={ational:\"ate\",tional:\"tion\",enci:\"ence\",anci:\"ance\",izer:\"ize\",bli:\"ble\",alli:\"al\",entli:\"ent\",eli:\"e\",ousli:\"ous\",ization:\"ize\",ation:\"ate\",ator:\"ate\",alism:\"al\",iveness:\"ive\",fulness:\"ful\",ousness:\"ous\",aliti:\"al\",iviti:\"ive\",biliti:\"ble\",logi:\"log\"},e={icate:\"ic\",ative:\"\",alize:\"al\",iciti:\"ic\",ical:\"ic\",ful:\"\",ness:\"\"},n=\"[^aeiou]\",i=\"[aeiouy]\",r=n+\"[^aeiouy]*\",o=i+\"[aeiou]*\",s=\"^(\"+r+\")?\"+o+r,a=\"^(\"+r+\")?\"+o+r+\"(\"+o+\")?$\",h=\"^(\"+r+\")?\"+o+r+o+r,u=\"^(\"+r+\")?\"+i,l=new RegExp(s),c=new RegExp(h),f=new RegExp(a),d=new RegExp(u),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,w=new RegExp(\"([^aeiouylsz])\\\\1$\"),k=new RegExp(\"^\"+r+i+\"[^aeiouwxy]$\"),x=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,F=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,_=/^(.+?)(s|t)(ion)$/,z=/^(.+?)e$/,O=/ll$/,P=new RegExp(\"^\"+r+i+\"[^aeiouwxy]$\"),T=function(n){var i,r,o,s,a,h,u;if(n.length<3)return n;if(o=n.substr(0,1),\"y\"==o&&(n=o.toUpperCase()+n.substr(1)),s=p,a=v,s.test(n)?n=n.replace(s,\"$1$2\"):a.test(n)&&(n=n.replace(a,\"$1$2\")),s=g,a=m,s.test(n)){var T=s.exec(n);s=l,s.test(T[1])&&(s=y,n=n.replace(s,\"\"))}else if(a.test(n)){var T=a.exec(n);i=T[1],a=d,a.test(i)&&(n=i,a=S,h=w,u=k,a.test(n)?n+=\"e\":h.test(n)?(s=y,n=n.replace(s,\"\")):u.test(n)&&(n+=\"e\"))}if(s=x,s.test(n)){var T=s.exec(n);i=T[1],n=i+\"i\"}if(s=b,s.test(n)){var T=s.exec(n);i=T[1],r=T[2],s=l,s.test(i)&&(n=i+t[r])}if(s=E,s.test(n)){var T=s.exec(n);i=T[1],r=T[2],s=l,s.test(i)&&(n=i+e[r])}if(s=F,a=_,s.test(n)){var T=s.exec(n);i=T[1],s=c,s.test(i)&&(n=i)}else if(a.test(n)){var T=a.exec(n);i=T[1]+T[2],a=c,a.test(i)&&(n=i)}if(s=z,s.test(n)){var T=s.exec(n);i=T[1],s=c,a=f,h=P,(s.test(i)||a.test(i)&&!h.test(i))&&(n=i)}return s=O,a=c,s.test(n)&&a.test(n)&&(s=y,n=n.replace(s,\"\")),\"y\"==o&&(n=o.toLowerCase()+n.substr(1)),n};return T}(),t.Pipeline.registerFunction(t.stemmer,\"stemmer\"),t.generateStopWordFilter=function(t){var e=t.reduce(function(t,e){return t[e]=e,t},{});return function(t){return t&&e[t]!==t?t:void 0}},t.stopWordFilter=t.generateStopWordFilter([\"a\",\"able\",\"about\",\"across\",\"after\",\"all\",\"almost\",\"also\",\"am\",\"among\",\"an\",\"and\",\"any\",\"are\",\"as\",\"at\",\"be\",\"because\",\"been\",\"but\",\"by\",\"can\",\"cannot\",\"could\",\"dear\",\"did\",\"do\",\"does\",\"either\",\"else\",\"ever\",\"every\",\"for\",\"from\",\"get\",\"got\",\"had\",\"has\",\"have\",\"he\",\"her\",\"hers\",\"him\",\"his\",\"how\",\"however\",\"i\",\"if\",\"in\",\"into\",\"is\",\"it\",\"its\",\"just\",\"least\",\"let\",\"like\",\"likely\",\"may\",\"me\",\"might\",\"most\",\"must\",\"my\",\"neither\",\"no\",\"nor\",\"not\",\"of\",\"off\",\"often\",\"on\",\"only\",\"or\",\"other\",\"our\",\"own\",\"rather\",\"said\",\"say\",\"says\",\"she\",\"should\",\"since\",\"so\",\"some\",\"than\",\"that\",\"the\",\"their\",\"them\",\"then\",\"there\",\"these\",\"they\",\"this\",\"tis\",\"to\",\"too\",\"twas\",\"us\",\"wants\",\"was\",\"we\",\"were\",\"what\",\"when\",\"where\",\"which\",\"while\",\"who\",\"whom\",\"why\",\"will\",\"with\",\"would\",\"yet\",\"you\",\"your\"]),t.Pipeline.registerFunction(t.stopWordFilter,\"stopWordFilter\"),t.trimmer=function(t){return t.replace(/^\\W+/,\"\").replace(/\\W+$/,\"\")},t.Pipeline.registerFunction(t.trimmer,\"trimmer\"),t.TokenStore=function(){this.root={docs:{}},this.length=0},t.TokenStore.load=function(t){var e=new this;return e.root=t.root,e.length=t.length,e},t.TokenStore.prototype.add=function(t,e,n){var n=n||this.root,i=t.charAt(0),r=t.slice(1);return i in n||(n[i]={docs:{}}),0===r.length?(n[i].docs[e.ref]=e,void(this.length+=1)):this.add(r,e,n[i])},t.TokenStore.prototype.has=function(t){if(!t)return!1;for(var e=this.root,n=0;n<t.length;n++){if(!e[t.charAt(n)])return!1;e=e[t.charAt(n)]}return!0},t.TokenStore.prototype.getNode=function(t){if(!t)return{};for(var e=this.root,n=0;n<t.length;n++){if(!e[t.charAt(n)])return{};e=e[t.charAt(n)]}return e},t.TokenStore.prototype.get=function(t,e){return this.getNode(t,e).docs||{}},t.TokenStore.prototype.count=function(t,e){return Object.keys(this.get(t,e)).length},t.TokenStore.prototype.remove=function(t,e){if(t){for(var n=this.root,i=0;i<t.length;i++){if(!(t.charAt(i)in n))return;n=n[t.charAt(i)]}delete n.docs[e]}},t.TokenStore.prototype.expand=function(t,e){var n=this.getNode(t),i=n.docs||{},e=e||[];return Object.keys(i).length&&e.push(t),Object.keys(n).forEach(function(n){\"docs\"!==n&&e.concat(this.expand(t+n,e))},this),e},t.TokenStore.prototype.toJSON=function(){return{root:this.root,length:this.length}},function(t,e){\"function\"==typeof define&&define.amd?define(e):\"object\"==typeof exports?module.exports=e():t.lunr=e()}(this,function(){return t})}();"
					}
					
				
		
				
		
				
					,
					
					"assets-js-main-js": {
						"id": "assets-js-main-js",
						"title": "",
						"categories": "",
						"url": " /assets/js/main.js",
						"content": "(function($) {\n    'use strict';\n    $(function() {\n        $('[data-toggle=\"tooltip\"]').tooltip();\n        $('[data-toggle=\"popover\"]').popover();\n        $('.popover-dismiss').popover({\n            trigger: 'focus'\n        })\n    });\n\n    function bottomPos(element) {\n        return element.offset().top + element.outerHeight();\n    }\n    $(function() {\n        var promo = $(\".js-td-cover\");\n        if (!promo.length) {\n            return\n        }\n        var promoOffset = bottomPos(promo);\n        var navbarOffset = $('.js-navbar-scroll').offset().top;\n        var threshold = Math.ceil($('.js-navbar-scroll').outerHeight());\n        if ((promoOffset - navbarOffset) ';\n       $(this).after(clipButton);\n});\n\nnew Clipboard('.clipbtn');"
					}
					
				
		
				
					,
					
					"es-functionality-lifecycle-management": {
						"id": "es-functionality-lifecycle-management",
						"title": "Lifecycle Management",
						"categories": "",
						"url": " /es/functionality/lifecycle-management",
						"content": "GestiÃ³n del ciclo de vida del service mesh\nMeshery soporta varios service mesh diferentes, de modo que puede aprender y comparar diferentes funcionalidades de service mesh. Una vez que haya seleccionado operar un service mesh determinado, Meshery le ayudarÃ¡ con las actividades en curso.\n\nDespliegue de un service mesh\nMeshery automatiza el aprovisionamiento de varios service mesh, permitiendo a los usuarios seleccionar diferentes perfiles de configuraciÃ³n para admitir una variedad de modelos de despliegue.\n\nInstalaciÃ³n de aplicaciones de muestra\nComÃºnmente junto a cada service mesh hay una aplicaciÃ³n de muestra que facilita la demostraciÃ³n del valor del service mesh dado. Meshery permite que rÃ¡pidamente despliegue la misma aplicaciÃ³n de muestra en diferentes service mesh.\n\nUso de configuraciÃ³n de service mesh personalizada\nMeshery le brinda la posibilidad, a usted como administrador, de personalizar el despliegue de su service mesh.\n\nEliminaciÃ³n de un service mesh\nAsÃ­ como Meshery automatiza el aprovisionamiento de varios service mesh, tambiÃ©n facilita el desaprovisionamiento de los service mesh.\n\nNotificaciones\nMeshery monitorea los service mesh y la salud de la aplicaciÃ³n. Meshery proporciona notificaciones de los problemas de ambiente, conflictos de aplicaciones con la configuraciÃ³n del service mesh.\n\nReconocer y descartar notificaciones\nLa mayorÃ­a de las notificaciones son informativas y pueden descartarse fÃ¡cilmente despuÃ©s de leerlas. Algunas notificaciones incluyen alertas accionables.\n\nActuar sobre las alertas\n\nLas notificaciones particulares que Meshery presenta son accionables inmediatamente. Estas se indican por un resaltado de color rojo. MantÃ©ngase atento ante estas alertas y actue de inmediato para asegurar un buen funcionamiento del service mesh."
					}
					
				
		
				
					,
					
					"functionality-lifecycle-management": {
						"id": "functionality-lifecycle-management",
						"title": "Lifecycle Management",
						"categories": "",
						"url": " /functionality/lifecycle-management",
						"content": "Service Mesh Lifecycle Management\n\nMeshery supports a number of different service meshes, so that you can learn and compare different service mesh functionality. Once you have selected to operate a given service mesh, Meshery will assist you with ongoing activities.\n\nDeploying a service mesh\n\nMeshery automates the provisioning of various service meshes, allowing users to select different configuration profiles in order to support a variety of deployment models.\n\nMeshery adapters will dynamically retrieve the specific service meshâ€™s release package upon initial deployment of a given service mesh. Meshery adapters cache (in .meshery/bin) the service mesh installation package.\n\nInstalling sample applications\n\nCommonly adjoining each service mesh is a sample application that facilitates demonstration of the value of the given service mesh. Meshery allows you to efficiently deploy the same sample application across different service meshes.\n\nUse custom service mesh configuration\n\nMeshery provides the ability for you as a service mesh manager to customize your service mesh deployment.\n\nDeleting a service mesh\n\nJust as Meshery automates the provisioning of various service meshes, so does it facilitate the deprovisioning of service meshes.\n\nNotifications\n\nMeshery tracks service mesh and application health. Meshery provides notification of environment issues, application conflicts with service mesh configuration.\n\nAcknowledging and dismissing notifications\n\nMany notifications are informational and can readily be dismissed after reading. Some notifications include actionable alerts.\n\nTaking action on alerts\n\nParticular notifications that Meshery presents are immediately actionable. These are denoted by a red colored highlight. Be on the lookout for these alerts and take action promptly to ensure a smooth running service mesh."
					}
					
				
		
				
					,
					
					"guides-meshery-metrics": {
						"id": "guides-meshery-metrics",
						"title": "Using Metrics in Meshery",
						"categories": "",
						"url": " /guides/meshery-metrics",
						"content": "Connect and use metrics in Meshery\n\nMeshery provides performance reports, including performance test results, node resource metrics etc. so that operators may easily understand the overhead of their service meshâ€™s control plane and data plane in context of the overhead incurred on nodes running within the cluster. In order to generate performance test reports of service meshes and their workloads, Meshery uses Grafana and/or Prometheus as visualization and metrics systems, respectively. This guide outlines the requirements necessary for Meshery to connect to these systems. The steps may vary depending upon the service mesh and its configuration.\n\nIn order to pull in these environment metrics, you can also manually configure Meshery to connect with your existing Grafana and/or Prometheus instances through the Meshery dashboard. Once they have been loaded and are displayed on the screen, you may also perform an ad-hoc test to check Mesheryâ€™s connection status.\n\n\n\nSuggested Reading\n\n\n  Guide: Interpreting Performance Test Results"
					}
					
				
		
				
					,
					
					"reference-mesheryctl": {
						"id": "reference-mesheryctl",
						"title": "mesheryctl Command Reference",
						"categories": "",
						"url": " /reference/mesheryctl",
						"content": "Categories and Command Structure\n\nMeshery CLI commands are categorized by function, which are:\n\n\n  mesheryctl - Global flags\n  mesheryctl system - Meshery Lifecycle and Troubleshooting\n  mesheryctl mesh - Service Mesh Lifecycle &amp; Configuration Management\n  mesheryctl perf -  Service Mesh Performance Management\n\n\nGlobal Commands and Flags\n\n\n  \n    \n      command\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      mesheryctl\n      Â \n      Displays help about any command.\n      mesheryctl\n    \n    \n      Â \n      version\n      Displays the version of the Meshery Client (mesheryctl) and the SHA of the release binary.\n      mesheryctl system version\n    \n    \n      Â \n      config\n      configures Meshery with the kubeconfig, generated with the help of user details, to provide cluster access for public clouds(GKE/EKS).\n      mesheryctl system config gke --token \"PATH TO TOKEN\"\n    \n    \n      Â \n      mesheryctl-config\n      (optional) path to Meshery Client (mesheryctl) configuration file (~/.meshery/mesheryctl.yaml) to overrides defaults.\n      mesheryctl perf &lt;args&gt; --mesheryctl-config=~/.meshery/mesheryctl.yaml\n    \n    \n      Â \n      verbose\n      (optional) Sets the log level to debug for verbose output.\n      mesheryctl &lt;command&gt; --verbose\n    \n    \n      Â \n      help\n      Displays helpful information about any command.\n      mesheryctl --help\n    \n  \n\n\nMeshery Lifecycle Management\n\nInstallation, troubleshooting and debugging of Meshery and its adapters.\n\n\n  \n    \n      command\n      arg\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      system\n      Â \n      Â \n      Â \n      mesheryctl system\n    \n    \n      Â \n      channel\n      Â \n      Switch between release channels.\n      mesheryctl system channel\n    \n    \n      Â \n      config\n      Â \n      Configures Meshery to use a Kubernetes cluster.\n      mesheryctl system config gke --token ~/Downloads/auth.json\n    \n    \n      Â \n      log\n      Â \n      Starts tailing Meshery server debug logs.\n      mesheryctl system log\n    \n    \n      Â \n      start\n      Â \n      Start all Meshery containers.\n      mesheryctl system start\n    \n    \n      Â \n      completion\n      Â \n      Generates completion script.\n      mesheryctl system completion [bash\\|zsh\\|fish]\n    \n    \n      Â \n      status\n      Â \n      Displays the status of Mesheryâ€™s containers (server and adapters).\n      mesheryctl system status\n    \n    \n      Â \n      stop\n      Â \n      Stop all Meshery containers.\n      mesheryctl system stop\n    \n    \n      Â \n      reset\n      Â \n      Resets meshery.yaml with copy from Meshery repo. Warning - Any local changes will be overwritten.\n      mesheryctl system reset\n    \n    \n      Â \n      update\n      Â \n      Pull new Meshery images from Docker Hub. Does not pulls new mesheryctl client. This command may be executed while Meshery is running.\n      mesheryctl system update\n    \n    \n      Â \n      help\n      Â \n      Displays help about any Meshery lifecycle management command.\n      mesheryctl system --help\n    \n    \n      Â \n      channel\n      switch\n      switch release channel and version\n      mesheryctl system channel switch [stable|stable-version|edge|edge-version]\n    \n    \n      Â \n      channel\n      view\n      view release channel and version\n      mesheryctl system channel view\n    \n    \n      Â \n      start\n      â€“reset\n      (optional) reset Mesheryâ€™s configuration file to default settings.\n      mesheryctl system start --reset\n    \n    \n      Â \n      start\n      â€“skip-update\n      (optional) skip updates available in Meshery.\n      mesheryctl system start --skip-update\n    \n    \n      Â \n      channel\n      set\n      set release channel and version.\n      mesheryctl system channel set [stable|stable-version|edge|edge-version]\n    \n    \n      Â \n      stop\n      â€“reset\n      (optional) reset Mesheryâ€™s configuration file to default settings.\n      mesheryctl system stop --reset\n    \n  \n\n\nPerformance Management\n\n\n  \n    \n      command\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      perf\n      Â \n      Performance management - baselining and testing.\n      mesheryctl perf --name \"a quick stress test\" --url http://192.168.1.15/productpage --qps 300 --concurrent-requests 2 --duration 30s --load-generator wrk2\n    \n    \n      Â \n      â€“mesh (optional)\n      Name of the service mesh. (default) empty string\n      Â \n    \n    \n      Â \n      â€“load-generator (optional)\n      Choice of load generator - fortio (OR) wrk2 (default) fortio\n      --load-generator=fortio\n    \n    \n      Â \n      â€“file (optional)\n      URI of the service mesh performance test configuration file. (default) empty string\n      --file soak-test-clusterA.yaml\n    \n    \n      Â \n      â€“qps (optional)\n      Queries per second (default) 0 (0 - means to use the CPU unbounded to generate as many requests as possible.\n      --qps 30\n    \n    \n      Â \n      â€“url (required)\n      URL of the endpoint send load to during testing.\n      http://my-service/api/v1/test\n    \n    \n      Â \n      â€“name (optional)\n      A memorable name for the test. (default) a random string\n      Â \n    \n    \n      Â \n      â€“concurrent-requests (optional)\n      Number of concurrent requests (default) 1\n      --concurrent-requests 10\n    \n    \n      Â \n      â€“duration(optional)\n      Duration of the test.\n      10s, 5m, 2h\n    \n    \n      Â \n      â€“help, -h\n      Displays help the performance management command.\n      mesheryctl perf --help\n    \n  \n\n\nService Mesh Lifecycle Management\n\n\n  \n    \n      command\n      arg\n      flag\n      function\n      Usage\n    \n  \n  \n    \n      mesh\n      Â \n      Â \n      Lifecycle management of service meshes\n      Â \n    \n    \n      Â \n      init\n      Â \n      Provision a service mesh\n      Â \n    \n    \n      Â \n      Â \n      â€“platform\n      Identify platform to provision service mesh on (e.g. Docker, K8s)\n      --platform docker\n    \n    \n      Â \n      Â \n      â€“profile\n      Use specific configuration profile\n      --profile mTLS\n    \n    \n      Â \n      Â \n      â€“help, -h\n      Displays help about any service mesh lifecycle management command.\n      mesheryctl help"
					}
					
				
		
				
					,
					
					"installation-mesheryctl": {
						"id": "installation-mesheryctl",
						"title": "Install mesheryctl",
						"categories": "",
						"url": " /installation/mesheryctl",
						"content": "Mesheryâ€™s command line client is mesheryctl. To install mesheryctl on your system, you may choose from any of the following supported methods.\n\nBash\n\nInstall\n\n\n \n curl -L https://git.io/meshery | bash -\n \n \n\nHomebrew\n\nInstall\n\nTo install mesheryctl using homebrew, execute the following commands.\n\n\n \n $ brew tap layer5io/tap\n $ brew install mesheryctl\n \n\n\nYou need to have brew installed on your Mac or Linux system to perform these actions.\n\nUpgrade\n\nTo upgrade mesheryctl, execute the following command.\n\n\n \n $ brew upgrade mesheryctl\n \n \n\nExample output of a successful upgrade:\nâœ  ~ brew upgrade mesheryctl\n==&gt; Upgrading 1 outdated package:\nlayer5io/tap/mesheryctl 0.3.2 -&gt; 0.3.4\n==&gt; Upgrading layer5io/tap/mesheryctl\n==&gt; Downloading https://github.com/layer5io/meshery/releases/download/v0.3.4/mesheryctl_0.3.4_Darwin_x86_64.zip\n==&gt; Downloading from https://github-production-release-asset-2e65be.s3.amazonaws.com/157554479/17522b00-2af0-11ea-8aef-cbfe8\n######################################################################## 100.0%\nğŸº  /usr/local/Cellar/mesheryctl/0.3.4: 5 files, 10.2MB, built in 4 seconds\nRemoving: /usr/local/Cellar/mesheryctl/0.3.2... (5 files, 10.2MB)\nRemoving: /Users/lee/Library/Caches/Homebrew/mesheryctl--0.3.2.zip... (3.9MB)\n==&gt; Checking for dependents of upgraded formulae...\n==&gt; No dependents found!\n\n\nScoop\n\nmesheryctl can be installed via Scoop (a package manager for Windows, just like apt for Ubuntu). To install mesheryctl using Scoop, execute the following commands.\n\nInstall\n\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\n\n\nYou need to have scoop installed on your Windows system to perform these actions.\n\nYouâ€™re ready to run Meshery. To do so, execute the following command.\n\n\n\nmesheryctl system start\n\n\n\n\nUpgrade\n\nTo upgrade mesheryctl, just execute the following command.\n\n\n\nscoop update mesheryctl\n\n\n\n\nContinue deploying Meshery onto one of the Supported Platforms."
					}
					
				
		
				
					,
					
					"reference-mesheryctl-commands-command-name-template": {
						"id": "reference-mesheryctl-commands-command-name-template",
						"title": "mesheryctl &lt;command name&gt;",
						"categories": "en",
						"url": " /reference/mesheryctl/commands/command_name_template",
						"content": "mesheryctl &#60;command name&#62;\n\n\nDescription of the command preferably in a paragraph.\n\n\n\n\n  \n    \n  mesheryctl &#60;command&#62; [flags] \n    \n  \n\n\n\nExamples\n\n\n  \n    \n\n  # use case 1 (brief description)\n  mesheryctl &#60;command&#62; [flags]\n  \n  # use case 2 (brief description)\n  mesheryctl &#60;command&#62; [flags] \n    \n  \n \n\n\nOptions\n\n\n  \n    \n  [flag] (data type) short description\n    \n  \n\n\n\n\nOptions inherited from parent commands\n\n  \n    \n  Possible Options inherited from parent command"
					}
					
				
		
				
					,
					
					"concepts-architecture-meshsync": {
						"id": "concepts-architecture-meshsync",
						"title": "MeshSync",
						"categories": "",
						"url": " /concepts/architecture/meshsync",
						"content": "MeshSync is a custom Kubernetes controller that provides tiered discovery and continual synchronization with Meshery Server as to the state of the Kubernetes cluster, service meshes, and their workloads.\n\nWhat are its core responsibilities?\n\nDiscover existing resources inside the kubernetes cluster\nThe resources that are present inside the cluster are discovered efficiently with the help of pipelines. The data is constructed in a particular format specific to meshery and publish across to different parts of the architecture.\n\nListening to events/changes on every component\nMeshSync implements several informers/listeners across each resource to listen to changes that occur to them. These are reflected at real time and are updated in their respective areas.\n\nMeshSync FAQs"
					}
					
				
		
				
					,
					
					"es-installation-platforms-minikube": {
						"id": "es-installation-platforms-minikube",
						"title": "Minikube",
						"categories": "",
						"url": " /es/installation/platforms/minikube",
						"content": "Inicio RÃ¡pido con Minikube\n\nPara configurar y ejecutar Meshery en Minikube:\n\n\n  Iniciar Minikube\n  Configurar Meshery para usar minkube\n  Ejecutar Meshery\n\n\nCompatibilidad\n\nLas siguientes versiones mÃ­nimas de componentes son requieridas:\n\n\n  \n    Nombre\n    VersiÃ³n \n  \n  \n    Minikube\n    1.0.0 \n  \n  \n    Kubernetes\n    1.14.1\n  \n  \n    kubectl\n    1.14.1\n  \n\n\nPasos\n\nEjecute los siguientes pasos en este orden:\n\n1. iniciar minikube\n\nminikube start --cpus 4 --memory 8192 --kubernetes-version=v1.14.1\n\n\nNota: la memoria mÃ­nima requerida es â€“memory=4096 (para despliegues de Istio solamente)\n\nNote: Si estÃ¡ utilizando manejador docker (docker driver), despuÃ©s de completar los pasos de instalaciÃ³n de Meshery, ejecute el siguiente comando para establecer la conectividad entre Meshery y el servidor Kubernetes.\n\ndocker network connect bridge meshery_meshery_1\n\n\n2. Configurar Meshery para usar minikube\n\n\n  Inicie sesiÃ³n en Meshery. En el menÃº de su perfil de usuario, haga clic en Get Token.\n  Use mesheryctl y asÃ­ configurar Meshery para usar minikube. Ejecute:\n\n\nmesheryctl system config minikube -t ~/Downloads/auth.json\n\n\nTambiÃ©n puede generar y cargar manualmente el archivo kubeconfig para que Meshery lo use:\n\nEste archivo de configuraciÃ³n serÃ¡ utilizado por Meshery.\n\nkubectl config view --minify --flatten &gt; config_minikube.yaml\n\n\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data: &lt; cert shortcutted &gt;\n    server: https://192.168.99.100:8443\n  name: minikube\ncontexts:\n- context:\n    cluster: minikube\n    user: minikube\n  name: minikube\ncurrent-context: minikube\nkind: Config\npreferences: {}\nusers:\n- name: minikube\n  user:\n    client-certificate-data: &lt;cert shortcutted &gt;\n    client-key-data: &lt; key shortcutted &gt;\n\n\nNota: AsegÃºrese que current-context (contexto actual) estÃ© establecido a minikube.\n\n3. Configurar Meshery\n\nSiga los pasos de instalaciÃ³n para instalar el CLI (IntÃ©rprete de LÃ­nea de Comandos) mesheryctl.\n\nMeshery ahora deberÃ­a estar conectado con su instancia administrada de Kubernetes. Eche un vistazo a guÃ­as Meshery para consejos de uso advanzado."
					}
					
				
		
				
					,
					
					"installation-platforms-minikube": {
						"id": "installation-platforms-minikube",
						"title": "Minikube",
						"categories": "",
						"url": " /installation/platforms/minikube",
						"content": "Quick Start with Minikube \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nTo Setup and run Meshery on Minikube :\n\n\n  Start Minikube\n  Configure Meshery to use minikube\n  Run Meshery\n\n\nCompatibility\nThe following minimum component versions are required:\n\n\n  \n    Name\n    Version\n  \n  \n    Minikube\n    1.0.0 \n  \n  \n    Kubernetes\n    1.14.1\n  \n  \n    kubectl\n    1.14.1\n  \n\n\nSteps\nPerform the following steps in order:\n\n1. Start minikube\n\n\n \n minikube start --cpus 4 --memory 8192 --kubernetes-version=v1.14.1\n \n \n\nNote: minimum memory required is â€“memory=4096 (for Istio deployments only)\n\nCheck up on your minikube cluster :\n\n\n  minikube status \n\n2. Install Meshery\n\nFollow the installation steps to setup the mesheryctl CLI and install Meshery.\n\nUsers using docker driver:\nAfter completing the Meshery installation, execute the following command to establish connectivity between Meshery and Kubernetes cluster:\n\n\n \n docker network connect bridge meshery_meshery_1\n \n \n\nTo establish connectivity between a particular Meshery Adapter and Kubernetes server, use â€œdocker psâ€ to identify the name of the desired container, and execute the following command:\n\n\n \n docker network connect bridge &amp;lt container name of the desired adapter &amp;gt\n \n \n\n2. Configure Meshery to use minikube\n\n\n  \n    Login to Meshery. Under your user profile, click Get Token.\n  \n  \n    Use mesheryctl to configure Meshery to use minikube. To allow Meshery to detect your config file, execute the following commands:\n  \n\n\n\n \n mesheryctl system config minikube -t ~/Downloads/auth.json\n \n \nOptionally configure Meshery to use minikube through the Web UI :\n\n  Run the below command to generate the â€œconfig_minikube.yamlâ€ file for your cluster:\n\n\n\n \n kubectl config view --minify --flatten &gt; config_minikube.yaml\n \n \n\n\n  Upload the generated config file by navigating to Settings &gt; Environment &gt; Out of Cluster Deployment in the Web UI and using the â€œUpload kubeconfigâ€ option.\n\n\nManual Steps\n\nYou may also manually generate and load the kubeconfig file for Meshery to use:\n\nThe following configuration yaml will be used by Meshery. Copy and paste the following in your config file :\n\n\n \n apiVersion: v1\n clusters:\n - cluster:\n     certificate-authority-data: &lt; cert shortcutted &gt;\n     server: https://192.168.99.100:8443\n   name: minikube\n contexts:\n - context:\n     cluster: minikube\n     user: minikube\n   name: minikube\n current-context: minikube\n kind: Config\n preferences: {}\n users:\n - name: minikube\n   user:\n     client-certificate-data: &lt; cert shortcutted &gt;\n     client-key-data: &lt; key shortcutted &gt;\n \n \n\nNote: Make sure current-context is set to minikube.\n\n\nTo allow Meshery to auto detect your config file, Run :\n\n \n kubectl config view --minify --flatten &gt; config_minikube.yaml\n \n\n\n\nMeshery should now be connected with your managed Kubernetes instance. Take a look at the Meshery guides for advanced usage tips."
					}
					
				
		
				
					,
					
					"guides-multiple-adapters": {
						"id": "guides-multiple-adapters",
						"title": "Using Multiple Adapters",
						"categories": "",
						"url": " /guides/multiple-adapters",
						"content": "Advanced Configuration\n\nMeshery is capable of running zero or more service mesh adapters. Without any service mesh adapters, some but not all of Mesheryâ€™s features will continue to function (e.g. performance testing of workloads not running on a service mesh).\n\nModifying the default adapter deployment configuration\nThe number of adapters, type of adapters, where they are deployed, how they are named and what port they are exposed on are all configurable deployment options. To modify the default configuration, find ~/.meshery/meshery.yaml on your system. ~/.meshery/meshery.yaml is a Docker Compose file.\n\nConfiguration: Running fewer Meshery adapters\nIn the ~/.meshery/meshery.yaml configuration file, remove the entry(ies) of the adapter(s) you are removing from your deployment.\n\nConfiguration: Running more than one instance of the same Meshery adapter\n\nThe default configuration of a Meshery deployment includes one instance of each of the Meshery adapters (that have reached a stable version status). You may choose to run multiple instances of the same type of Meshery adapter; e.g. two instances of the meshery-istio adapter. To do so, modify ~/.meshery/meshery.yaml to include multiple copies of the given adapter.\n\nDemo of Meshery managing service mesh deployments across multiple clusters:\n\n\n\nSee on YouTube: Cloud Native Austin Virtual Meetup: April 2020"
					}
					
				
		
				
		
				
					,
					
					"concepts-architecture-operator": {
						"id": "concepts-architecture-operator",
						"title": "Operator",
						"categories": "",
						"url": " /concepts/architecture/operator",
						"content": "Meshery operator is a kubernetes controller manager which is conceptually known as a kubernetes operator. This manages the lifecycle of every meshery component that is deployed or running inside the cluster.\n\nList of Controllers that is managed by the operator\n\nBroker Controller\n\nMeshery broker is one of the core components of the meshery architecture. This controller manages the lifecycle of broker that meshery uses for data streaming across the cluster and the outside world.\n\nSee the â€œMeshery Brokerâ€ for more information.\n\nMeshSync Controller\n\nMeshSync Controller manages the lifecycle of MeshSync that is deployed for resource synchronization for the cluster.\n\nSee the â€œMeshSyncâ€ for more information.\n\nOperator FAQs"
					}
					
				
		
				
					,
					
					"es-overview": {
						"id": "es-overview",
						"title": "DescripciÃ³n General",
						"categories": "",
						"url": " /es/overview",
						"content": "IntroducciÃ³n a Meshery\nEl plano de gestiÃ³n de service mesh adopta, opera y desarrolla sobre diferentes service meshes.\nMeshery facilita el aprendizaje sobre la funcionalidad y el desempeÃ±o de los service mesh e incorpora la recopilaciÃ³n y visualizaciÃ³n de mÃ©tricas de las aplicaciones que se ejecutan dentro de un service mesh o multiples service meshes.\nMeshery proporciona estas funcionalidades de alto nivel:\n\n\n  GestiÃ³n del desempeÃ±o de service meshes.\n  GestiÃ³n de configuraciÃ³n de service meshes.\n    \n      Mejores prÃ¡cticas de configuraciÃ³n.\n    \n  \n  GestiÃ³n del ciclo de vida de service meshes.\n  Interoperabilidad y asociaciÃ³n de service meshes.\n\n\n\n\nPresentado en Service Mesh Day 2019\n\nÂ¿QuÃ© desafÃ­os resuelve Meshery?\nGestiÃ³n de service mesh - uno o mÃºltiples service meshes.\n\nSiempre que haya que responder a estas preguntas sobre el desempeÃ±o, son subjetivas a la carga de trabajo y la infraestructura especÃ­ficas utilizadas para la mediciÃ³n. Ante este desafÃ­o, el proyecto Envoy, por ejemplo, se niega a publicar datos de desempeÃ±o porque tales pruebas pueden ser:\n\n  Confusas\n  Malinterpretadas.\n\n\nMÃ¡s allÃ¡ de la necesidad del desempeÃ±o y el alto consumo de datos bajo una permutaciÃ³n de diferentes cargas de trabajo (aplicaciones), los tipos y tamaÃ±os de los recursos de infraestructura, la necesidad de un proyecto multifuncional, y las comparaciones entre semejantes, son anhelados para facilitar una comparaciÃ³n de las diferencias de comportamiento entre service meshes y la selecciÃ³n de su uso. Los proyectos individuales son reservados en publicar resultados de pruebas de otras competencias de service mesh. Es necesario un anÃ¡lisis independiente, imparcial y creÃ­ble.\n\nLa intenciÃ³n de Meshery es ser un proveedor y una utilidad neutra de proyectos para evaluar de manera uniforme el desempeÃ±o de los service mesh. Entre proyectos de service mesh y servicios de proxy (y sorprendentemente, dentro de un mismo proyecto), existen diferentes nÃºmeros de herramientas y resultados. Meshery permite elegir un conjunto eficiente de herramientas para su ecosistema al proporcionar evaluaciones y mÃ©tricas de desempeÃ±o.\n\n\n  Al aprovechar Meshery, podrÃ¡s lograr una comparaciÃ³n de desempeÃ±o de los service meshes semejantes.\n  Realiza un seguimiento del desempeÃ±o de un service mesh de un release a otro.\n  Comprende las diferencias de comportamiento entre los service meshes.\n  Realiza un seguimiento del desempeÃ±o de su aplicaciÃ³n de una versiÃ³n a otra.\n\n\nMeshery es para Entusiastas y Operadores\nSea la opciÃ³n para implementar desde el DÃ­a 0 o el mantenimiento del DÃ­a 2 de despliegue, Meshery tiene capacidades Ãºtiles para cualquier circunstancia. La audicencia dirigida para un proyecto con Meshery serÃ­a cualquier tipo de operador  que aproveche el service mesh en su ecosistema; incluyendo desarrolladores, ingenieros de devops, quienes toman decisiones, arquitectos, y organizaciones que dependen de una plataforma de microservicios..\n\nMeshery es para la gestiÃ³n de desempeÃ±o: pruebas y comparaciones de mercado\nMeshery ayuda a los usuarios a sopesar el valor de la implementaciÃ³n de un service mesh con la alta carga involucrada a la ejecuciÃ³n del mismo. Meshery proporciona un anÃ¡lisis estadÃ­stico de la latencia de las solicitudes y el rendimiento que se observan a travÃ©s de las permutaciones de su carga de trabajo, infraestructura y la configuraciÃ³n del service mesh.\nAdemÃ¡s de solicitar la latencia y el rendimiento, Meshery tambiÃ©n rastrea la sobrecarga de memoria y el CPU en los nodos del clÃºster. Mide el plano de datos y el plano de control con diferentes conjuntos de cargas de trabajo e infraestructuras.\n\n\nEstablece un desempeÃ±o de marca y rastrea el desempeÃ±o como estÃ¡ndar a medida que cambia en el tiempo.\n\nMeshery es para cualquier service mesh\nLa diversidad de infraestructuras es una realidad para cualquier organizaciÃ³n. Ya sea que se estÃ© ejecutando un solo service mesh o varios tipos de service meshes, en Meshery encontrarÃ¡s que soporta una diversidad de infraestructura (o bien, la falta de una).\n\n\n  Adaptadores disponibles de service mesh - Adaptadores de service mesh soportados por Mashery.\n\n\n\n  \n    \n      Plataforma    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for Consul\n      stable\n    \n    \n      Meshery Adapter for Istio\n      stable\n    \n    \n      Meshery Adapter for Linkerd\n      stable\n    \n    \n      Meshery Adapter for Network Service Mesh\n      stable\n    \n    \n      Meshery Adapter for Octarine\n      stable\n    \n    \n      Meshery Adapter for Open Service Mesh\n      stable\n    \n  \n\n\n\n\n  Adaptadores en progreso de service mesh - Adaptadores de service mesh sometidos por la comunidad y en desarrollo\n\n\n\n  \n    \n      Plataforma    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for Citrix Service Mesh\n      beta\n    \n    \n      Meshery Adapter for Kuma\n      beta\n    \n    \n      Meshery Adapter for NGINX Service Mesh\n      beta\n    \n    \n      Meshery Adapter for Traefik Mesh\n      beta\n    \n  \n\n\n\n\n  Adaptadores de service mesh que buscamos apoyo - Adaptadores de service mesh que se encuentran en bÃºsqueda de ayuda de la comunidad.\n\n\n\n  \n    \n      Plataforma        Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Estado\n    \n  \n  \n    \n      Meshery Adapter for App Mesh\n      alpha\n    \n    \n      Meshery Adapter for Tanzu Service Mesh\n      alpha\n    \n  \n\n\nComunidad\nEste proyecto es hecho por la comunidad y toda colaboraciÃ³n es bienvenida! Fork here on Github\n\n\n  Ãšnete a la reuniÃ³n semanal de la comunidad Viernes de 10am a 11am Horario Central.\n    \n      Observa las grabaciones de la comunidad y suscrÃ­bete al calendario de la comunidad.\n    \n  \n  Ingresa al drive de la comunidad (solicita acceso).\n\n\nFAQ\n\nÂ¿Por quÃ© usar Meshery?\n\n  Porque es un proyecto de cÃ³digo abierto, proveedor neutral de proyectos que facilita las pruebas en meshes.\n  Porque fortio no estÃ¡ empaquetado en una utilidad de prueba de mesh, sino que es solo un generador de carga en sÃ­ mismo.\n  Debido a que regpatrol es de cÃ³digo cerrado, el cÃ³digo binario no es liberado, embebido para un mesh y es producido por un proveedor de ese mesh.\n\n\nÂ¿Por quÃ© crear Meshery y no usar otra herramienta de marca?\nMeshery estÃ¡ diseÃ±ado especÃ­ficamente para facilitar la evaluaciÃ³n comparativa de los service mesh y sus cargas de trabajo, al contrario de otras herramientas. Sin embargo tambiÃ©n existen otras herramientas que se utilizan para la evaluaciÃ³n comparativa de los service meshes, como regpatrol. Regpatrol es utilizado por IBM, el cual no es cÃ³digo abierto ni estÃ¡ disponible en su forma binaria para su uso, posee las siguientes diferencias con Meshery:\n\n  TelemetrÃ­a: regpatrol obtiene la telemetrÃ­a del adaptador Mixer Prometheus y utiliza el agente de nodo propietario de IBM.\n  Meshery se obtiene del adaptador Mixer Prometheus y utiliza el exportador de nodos Prometheus.\n  Tipo de trÃ¡fico: regpatrol usa JMeter, que puede analizar las respuestas y realizar pruebas funcionales.\n  Meshery estÃ¡ usando fortio, que es solo para pruebas de generaciÃ³n y rendimiento.\n\n\nRecursos\n\nPresentaciones de Meshery\n\n\n  Oâ€™Reilly OSCON 2020\n  Oâ€™Reilly Infrastructure &amp; Ops 2020\n  InnoTech Dallas 2020\n  KubeCon EU 2020\n  DockerCon 2020 (deck, video)\n  Open Source 101 at Home\n  Docker Captains Roundtable 2020\n  Cloud Native Austin 2020\n  NSMCon 2019 talk (video, deck)\n  Service Mesh Day 2019\n  DockerCon 2019 Open Source Summit\n  KubeCon EU 2019 (video, deck)\n  KubeCon EU 2019 Istio Founders Meetup\n  Cloud Native Rejekts EU 2019\n  Container World 2019\n  Solving the Service Mesh Adopterâ€™s Dilemma (deck, event,video)\n\n\nOtros Recursos\n\n  ComparaciÃ³n de Service Meshes\n  Herramientas de Service meshes\n  Libros sobre Service Mesh\n  Workshops sobre Service Mesh"
					}
					
				
		
				
					,
					
					"overview": {
						"id": "overview",
						"title": "Overview",
						"categories": "",
						"url": " /overview",
						"content": "As the service mesh management plane, Meshery enables the adoption, operation, and management of any service mesh and their workloads. Mesheryâ€™s powerful performance management functionality is accomplished through implementation of Service Mesh Performance (SMP). Mesheryâ€™s multi-mesh management functionality leverages Service Mesh Interface (SMI). Meshery enables operators to deploy WebAssembly filters to Envoy-based data planes. Meshery facilitates learning about functionality and performance of service meshes and incorporates the collection and display of metrics from applications running on or across service meshes.\n\nMesheryâ€™s Functionality\n\nMeshery features can be categorized by:\n\n\n  Service Mesh Performance Management\n    \n      Workload and service mesh benchmarking\n      Prometheus and Grafana Integration\n    \n  \n  Service Mesh Configuration Management\n    \n      Configuration best practices\n    \n  \n  Service Mesh Lifecycle Management\n    \n      Service mesh provisioning and workload onboarding\n      Meshery Operator and MeshSync\n    \n  \n  Data Plane Intelligence\n    \n      WebAssembly filters for Envoy\n    \n  \n  Service Mesh Interoperability and Federation\n    \n      Manage multiple service meshes concurrently\n      Connect to multiple clusters independently\n    \n  \n\n\nMeshery is for Developers, Operators, and Product Owners\n\nWhether making a Day 0 adoption choice or maintaining a Day 2 deployment, Meshery has useful capabilities in either circumstance. Targeted audience for Meshery project would be any technology operators that leverage service mesh in their ecosystem; this includes developers, devops engineers, decision makers, architects, and organizations that rely on microservices platform.\n\nService mesh management - one or multiple service meshes.**\nMeshery is for performance management: testing and benchmarking\nMeshery helps users weigh the value of their service mesh deployment against the overhead incurred in running a service mesh. Meshery provides statistical analysis of the request latency and throughput seen across various permutations of your workload, infrastructure and service mesh configuration.\nIn addition to request latency and throughput, Meshery also tracks memory and CPU overhead in of the nodes in your cluster. Measure your data plane and control plane against different sets of workloads and infrastructures.\n\nAnytime performance questions are to be answered, they are subjective to the specific workload and infrastructure used for measurement. Given this challenge, the Envoy project, for example, refuses to publish performance data because such tests can be:\n\n  Involved\n  Misinterpreted\n\n\nBeyond the need for performance and overhead data under a permutation of different workloads (applications) and types and sizes of infrastructure resources, the need for cross-project, apple-to-apple comparisons are also desired in order to facilitate a comparison of behavioral differences between service meshes and selection of their use. Individual projects shy from publishing test results of other, competing service meshes. An independent, unbiased, credible analysis is needed.\n\nMeshery is intended to be a vendor and project-neutral utility for uniformly benchmarking the performance of service meshes. Between service mesh and proxy projects (and surprisingly, within a single project), a number of different tools and results exist. Meshery allows you to pick an efficient set of tools for your ecosystem by providing performance evaluation and metrics.\n\n\n  By leveraging Meshery you could achieve apples-to-apples performance comparison of service meshes\n  Track your service mesh performance from release to release.\n  Understand behavioral differences between service meshes.\n  Track your application performance from version to version.\n\n\n\nEstablish a performance benchmark and track performance against this baseline as your environment changes over time.\n\nMeshery is for any service mesh\n\nInfrastructure diversity is a reality for any enterprise. Whether youâ€™re running a single service mesh or multiple types of service meshes, youâ€™ll find that Meshery supports your infrastructure diversity (or lack thereof).\nSupported Service Meshes\n\nStable\n\n\n  \n    \n      Platform      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Status\n    \n  \n  \n    \n       Meshery Adapter for Consul\n      stable\n    \n    \n       Meshery Adapter for Istio\n      stable\n    \n    \n       Meshery Adapter for Linkerd\n      stable\n    \n    \n       Meshery Adapter for Network Service Mesh\n      stable\n    \n    \n       Meshery Adapter for Octarine\n      stable\n    \n    \n       Meshery Adapter for Open Service Mesh\n      stable\n    \n  \n\n\nBeta\n\n\n  \n    \n      Platform      Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Status\n    \n  \n  \n    \n        Meshery Adapter for Citrix Service Mesh\n      beta\n    \n    \n        Meshery Adapter for Kuma\n      beta\n    \n    \n        Meshery Adapter for NGINX Service Mesh\n      beta\n    \n    \n        Meshery Adapter for Traefik Mesh\n      beta\n    \n  \n\n\nAlpha - Service mesh adapters adapters for which we are seeking community-contributed support.\n\n\n  \n    \n      Platform          Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â  Â  Â  Â  Â  Â \n      Status\n    \n  \n  \n    \n        Meshery Adapter for App Mesh\n      alpha\n    \n    \n        Meshery Adapter for Tanzu Service Mesh\n      alpha"
					}
					
				
		
				
					,
					
					"functionality-performance-management": {
						"id": "functionality-performance-management",
						"title": "Performance Management",
						"categories": "",
						"url": " /functionality/performance-management",
						"content": "Key to the efficient operation of any service mesh is the measurement and management of itâ€™s performance.\n\nLoad Generators\n\nMeshery provides users with a choice about the kind of load generator they prefer to use for a given performance test. Users may set their configure based on their own preference of load generator different from that of the default load generator.\n\nMeshery supports the following load generators and is extendible to support others:\n\n\n  fortio\n  wrk2\n  Nighthawk\n\n\nfortio\n\nFortio is a fast, small (3Mb docker image, minimal dependencies),\nreusable, embeddable go library as well as a command line tool and server process,\nthe server includes a simple web UI and graphical representation of the results\n(both a single latency graph and a multiple results comparative min, max, avg, qps and percentiles graphs).\n\nwrk2\n\nIt is a modern HTTP benchmarking tool capable of generating significant load when run on a single multi-core CPU. It combines a multithreaded design with scalable event notification systems such as epoll and kqueue.\n\nNighthawk\n\nNightHawk is an L7 (HTTP/HTTPS/HTTP2) performance characterization tool. It currently offers:\n\n\n  A load testing client which supports HTTP/1.1 and HTTP/2 over HTTP and HTTPS. (HTTPS certificates are not yet validated).\n  A simple test server which is capable of generating dynamic response sizes, as well as inject delays.\n  A binary to transform nighthawk output to well-known formats, allowing integration with other systems and dashboards.\n\n\nConfiguring performance testing settings\n\nMeshery provides a highly configurable set of load profiles with various, tuneable facets, including support for generating TCP, gRPC, and HTTP load with optional configuration of the performance testâ€™s:\n\n\n  Duration\n  Concurrent Threads\n  Concurrent Generators\n  Load Generator Type\n  Custom HTTP Headers\n\n\nSee Service Mesh Performance (SMP) for a full description of the different types of performance tests that Meshery provides.\n\nUsing Performance Test Profiles\n\nAs Meshery user you can customize and save your load test configuration in the form of a Performance Test Profile. Using Performance Test Profiles, you can return to Meshery to run the same set of customized tests again and again, tracking variations in performance overtime.\n\nComparing Test Results and Service Meshes\n\nMeshery users can easily compare the difference in request performance (latency and throughput) between independent performance tests. Statistical analysis is run upon finalization of every performance test and presented in the form of a histogram with latency buckets.\n\nKubernetes Cluster and Service Mesh Metrics\n\nMeshery provides performance test results alongside environment metrics, including service mesh control and data plane metrics as well as cluster node resource metrics, so that operators may easily understand the overhead of their service meshâ€™s control plane and data plane in context of the overhead incurred on nodes within the cluster.\n\nGrafana and Meshery\n\nConnect Meshery to your existing Grafana instance. Meshery will auto-import the boards of your choosing:\n\n\n    \n\n\nConnecting to Grafana\n\nIf you have an API key configured to restrict access to your Grafana boards, you will need to enter the API key when establishing Mesheryâ€™s connection to Grafana. You may also set up a Grafana board and then set up an API key:\n\n\n\n\n  Import Grafana boards\n    \n      Import existing Grafana boards via API\n      Import custom Grafana board via yaml\n    \n  \n  Configure graph panel preferences\n\n\nPrometheus and Meshery\n\nMeshery allows users to connect to one or more Prometheus instances in order to gather telemetric data (in the form of metrics). These metrics may pertain to service meshes, Kubernetes, applications on the mesh or any other metric that Prometheus has collected.\n\nOnce you have connected Meshery to your Prometheus deployment(s), you may perform ad-hoc connectivity tests to verify communication between Meshery and Prometheus.\n\nSuggested Reading\n\n\n  Guide: Interpreting Performance Test Results"
					}
					
				
		
				
					,
					
					"es-functionality-performance-management": {
						"id": "es-functionality-performance-management",
						"title": "Performance Management",
						"categories": "",
						"url": " /es/functionality/performance-management",
						"content": "GestiÃ³n del rendimiento\nLa clave del funcionamiento eficiente de cualquier service mesh es la mediciÃ³n y gestiÃ³n de su rendimiento.\n\nGeneradores de carga\nMeshery proporciona a los usuarios la opciÃ³n de elegir quÃ© generador de carga prefieren usar para una prueba de rendimiento determinada. Los usuarios pueden establecer su configuraciÃ³n basada en su propia preferencia de generador de carga diferente al generador de carga por defecto.\n\nMeshery soporta los siguientes generadores de carga y es extensible para soportar otros:\n\n\n  Fortio\n  wrk2\n  NightHawk\n\n\nFortio\n\nFortio es un rÃ¡pida, pequeÃ±a (imagen de Docker de 3Mb, dependencias mÃ­nimas), reusable, biblioteca de go integrable, asÃ­ como tambiÃ©n una herramienta de lÃ­nea de comandos y un proceso de servidor. El servidor incluye una Interfaz de Usuario web simple y una representaciÃ³n grÃ¡fica de los resultados (un grÃ¡fico de latencia Ãºnico y grÃ¡ficos comparativos de min, max, avg, qps y percentiles grÃ¡ficos).\n\nwrk2\n\nEs una herramienta moderna de evaluaciÃ³n comparativa HTTP capaz de generar una carga significativa cuando se ejecuta en un solo CPU multi-nÃºcleo. Combina un diseÃ±o multiproceso con sistemas de notificaciÃ³n de eventos escalables como lo son epoll y kqueue.\n\nNightHawk\n\nNightHawk es una herramienta de caracterizaciÃ³n L7 (HTTP/HTTPS/HTTP2). Actualmente ofrece:\n\n\n  Un cliente de prueba de carga que soporta HTTP/1.1 y HTTP/2 sobre HTTP y HTTPS (los certificados HTTPS aÃºn no se validan).\n  Un servidor de prueba simple capaz de generar tamaÃ±os de respuestas dinÃ¡micas, asÃ­ como tambiÃ©n inyectar retrasos.\n  Un binario para tranformar la salida de NightHawk a formatos conocidos, permitiendo la integraciÃ³n con otros sistemas y paneles.\n\n\nNode y mÃ©tricas del service mesh\n\nMeshery proporciona los resultados de pruebas de rendimiento junto a las mÃ©tricas del entorno, incluyendo el control del service mesh y las mÃ©tricas del plano de datos. TambiÃ©n incluye las mÃ©tricas de los recursos del nodo del clÃºster, para que los operadores puedan comprender fÃ¡cilmente la sobrecarga del plano de control y el plano de datos de su service mesh en el contexto de la sobrecarga incurrida en los nodos dentro del clÃºster.\n\nGrafana y Meshery\n\nConecte Meshery a su instancia de Grafana existente y Meshery importarÃ¡ los tableros que elija.\n\n\n    \n\n\nConexiÃ³n a Grafana\nSi tiene una clave de API configurada para restringir el acceso a sus tableros de Grafana, deberÃ¡ ingresar la clave de API cuando establezca la conexiÃ³n de Meshery con Grafana.\n\n\n  ImportaciÃ³n de tableros de Grafana\n    \n      ImportaciÃ³n de tablero existente de Grafana a travÃ©s de API\n      ImportaciÃ³n de tablero personalizado de Grafana a travÃ©s de yaml\n    \n  \n  ConfiguraciÃ³n de las preferencias del panel de grÃ¡ficos\n\n\nPrometheus y Meshery\nMeshery permite a los usuarios conectarse a una o mÃ¡s instancias de Prometheus para recopilar datos telemÃ©tricos (en forma de mÃ©tricas). Estas mÃ©tricas pueden pertenecer al service mesh, Kubernetes, aplicaciones en la malla o realmenteâ€¦ cualquier mÃ©trica que Prometheus haya recolectado.\n\nUna vez que haya conectado Meshery a su (s) despliegue (es) de Prometheus, puede realizar pruebas de conectividad ad-hoc para verificar la comunicaciÃ³n entre Meshery y Prometheus.\n\nLectura sugerida\n\n\n  GuÃ­a: InterpretaciÃ³n de los resultados de la prueba de rendimiento"
					}
					
				
		
				
					,
					
					"es-installation-platforms": {
						"id": "es-installation-platforms",
						"title": "Supported Platforms",
						"categories": "",
						"url": " /es/installation/platforms",
						"content": "Empezando a trabajar con otras Plataformas\n\nLa Tabla a continuaciÃ³n provee instrucciones de instalaciÃ³n para cada plataforma con la que Meshery es compatible:\n\n\n  \n    \n      Plataforma\n      VersiÃ³n\n    \n  \n  \n    \n       Docker\n      Â \n    \n    \n      Â Â Â   Docker Engine\n      19.x y superior\n    \n    \n       Kubernetes\n      1.12.x y superior\n    \n    \n      Â Â Â  AKS\n      Â \n    \n    \n      Â Â Â  Docker Desktop\n      2.0.x y superior\n    \n    \n      Â Â Â  EKS\n      1.12.x y superior\n    \n    \n      Â Â Â  GKE\n      1.14.x y superior\n    \n    \n      Â Â Â  Helm\n      Â \n    \n    \n      Â Â Â  KinD\n      v0.7.0\n    \n    \n      Â Â Â  Minikube\n      1.2.x y superior\n    \n    \n      Â Â Â  OpenShift\n      En Desarrollo\n    \n    \n       Mac\n      Â \n    \n    \n      Â Â Â  Mac - Homebrew\n      Â \n    \n    \n      Â Â Â  Scoop\n      Â \n    \n    \n      Â Â Â  Windows\n      Build 18917 y superior\n    \n    \n       Raspberry Pi\n      En Desarrollo"
					}
					
				
		
				
					,
					
					"installation-platforms": {
						"id": "installation-platforms",
						"title": "Supported Platforms",
						"categories": "",
						"url": " /installation/platforms",
						"content": "Supported Platforms\nMeshery deploys as a set of Docker containers, which can be deployed to either a Docker host or Kubernetes cluster. See the complete list of supported platforms in the table below. With service meshes having sprung to life in the context of Kubernetes, so too, can Mesheryâ€™s deployment models be characterized in the context of Kubernetes. A given deployment of Meshery can be described as either an in-cluster or an out-of-cluster deployment. Meshery deploys as a stand-alone, management plane on a Docker host (out-of-cluster) or as a management plane in a Kubernetes cluster (in-cluster).\n\nPlatform Compatibility Matrix\nFind installation instructions for the Supported Platforms in the compatibility table.\n\n\n  \n    \n      Platform\n      Version\n    \n  \n  \n    \n       Docker\n      Â \n    \n    \n      Â Â Â   Docker Engine\n      19.x and above\n    \n    \n       Kubernetes\n      1.12.x and above\n    \n    \n      Â Â Â  AKS\n      Â \n    \n    \n      Â Â Â  Docker Desktop\n      2.0.x and above\n    \n    \n      Â Â Â  EKS\n      1.12.x and above\n    \n    \n      Â Â Â  GKE\n      1.14.x and above\n    \n    \n      Â Â Â  Helm\n      Â \n    \n    \n      Â Â Â  KinD\n      v0.7.0\n    \n    \n      Â Â Â  Minikube\n      1.2.x and above\n    \n    \n      Â Â Â  OpenShift\n      In Progress\n    \n    \n       Mac\n      Â \n    \n    \n      Â Â Â  Mac - Homebrew\n      macOS 10.12 - 10.15, 11\n    \n    \n      Â Â Â  Scoop\n      Â \n    \n    \n      Â Â Â  Windows\n      Build 18917 and above\n    \n    \n       Raspberry Pi\n      In Progress"
					}
					
				
		
				
					,
					
					"extensibility-providers": {
						"id": "extensibility-providers",
						"title": "Extensibility: Providers",
						"categories": "",
						"url": " /extensibility/providers",
						"content": "Meshery offers Providers as a point of extensibility. With a built-in Local Provider (named â€œNoneâ€), Meshery Remote Providers are designed to be pluggable. Remote Providers offer points of extension to users / integrators to deliver enhanced functionality, using Meshery as a platform.\n\n\n  Extensibility points offer clean separation of open vs closed source capabilities.\n    \n      Meshmap is an example of a feature to be delivered via Remote Provider.\n    \n  \n  Remote Providers should be able to offer custom RBAC, custom UI components, and custom backend components\n    \n      Dynamically loadable frameworks need to be identified or created to serve each of these purposes.\n    \n  \n\n\nDesign Principles: Meshery Remote Provider Framework\n\nMesheryâ€™s Remote Provider extensbility framework is designed to enable:\n\n\n  Pluggable UI Functionality:\n    \n      Out-of-tree custom UI components with seamless user experience.\n      A system of remote retrieval of extension packages (ReactJS components and Golang binaries).\n    \n  \n  Pluggable Backend Functionality:\n    \n      Remote Providers have any number of capabilities unbeknownst to Meshery.\n    \n  \n  Pluggable AuthZ\n    \n      Design an extensible role based access control system such that Remote Providers can determine their own set of controls. Remote Providers to return JWTs with custom roles, permission keys and permission keychains.\n    \n  \n\n\n\n\nWhat functionality do Providers perform?\n\nWhat a given Remote Provider offers might vary broadly between providers. Meshery offers extension points that Remote Providers are able to use to inject different functionality - functionality specific to that provider.\n\n\n  Authentication and Authorization\n    \n      Examples: session management, two factor authentication, LDAP integration.\n    \n  \n  Long-Term Persistence\n    \n      Examples: Storage and retrieval of performance test results.\n      Examples: Storage and retrieval of user preferences.\n    \n  \n  Enhanced Visualization\n    \n      Examples: Creation of a visual service mesh topology.\n      Examples: Different charts (metrics), debug (log viewer), distributed trace explorers.\n    \n  \n  Reporting\n    \n      Examples: Using Mesheryâ€™s GraphQL server to compose new dashboards.\n    \n  \n\n\nTypes of providers\n\nTwo types of providers are defined in Meshery: local and remote. The Local provider is built-into Meshery. Remote providers are may be implemented by anyone or organization that wishes to integrate with Meshery. Any number of Remote providers may be available in your Meshery deployment.\n\nRemote Providers\n\nUse of a Remote Provider, puts Meshery into multi-user mode and requires user authentication. Use a Remote provider when your use of Meshery is ongoing or used in a team environment (used by multiple people).\n\nName: â€œMesheryâ€ (default)\n\n\n  Enforces user authentication.\n  Long-term term persistence of test results.\n  Save environment setup.\n  Retrieve performance test results.\n  Retrieve conformance test results.\n  Free to use.\n\n\nLocal Provider\n\nUse of the Local Provider, â€œNoneâ€, puts Meshery into single-user mode and does not require authentication. Use the Local provider when your use of Meshery is intended to be shortlived.\n\nName: â€œNoneâ€\n\n\n  No user authentication.\n  Container-local storage of test results. Ephemeral.\n  Environment setup not saved.\n  No performance test result history.\n  No conformance test result history.\n  Free to use.\n\n\nBuilding a Provider\n\nMeshery interfaces with Providers through a Go interface. The Provider implementations have to be placed in the code and compiled together today. A Provider instance will have to be injected into Meshery when the program starts.\n\nMeshery keeps the implementation of Remote Providers separate so that they are brought in through a separate process and injected into Meshery at runtime (OR) change the way the code works to make the Providers invoke Meshery.\n\nRemote Provider Extension Points\n\nInterwoven into Mesheryâ€™s web-based, user interface are a variety of extension points. Each extension point is carefully carved out to afford a seamless user experience. Each extension point is identified by a name and type. The following Meshery UI extension points are available:\n\n\n  Name: navigator \n Type: Menu Items\nDescription: This is supposed to be a full page extension which will get a dedicated endpoint in the meshery UI. And will be listed in the meshery UIâ€™s navigator/sidebar. Menu items may refer to full page extensions.\n\n\nName: user_prefs \nType: Single Component\nDescription: This is supposed to be remote react components which will get placed in a pre-existing page and will not have a dedicated endpoint. As of now, the only place where this extension can be loaded is the â€œUser Preferenceâ€ section under meshery settings.\n\nName: /extension/\n**Type:** Full Page\nDescription:\n\nThe Provider package is unzipped into Meshery server filesystem under /app/provider-pkg/&lt;package-name&gt;.\n\nRemote Providers must fulfill the following endpoints:\n\n\n  /login - return valid token\n  /logout - invalidating token\n  /capabilities - return capabilities.json\n\n\nUI Extension Points\n\nAll UI extensions will be hosted under the endpoint &lt;mesheryserver:port/provider&gt;\n\nUserPrefs\n\nThe UserPrefs extension point expects and loads a component to be displayed into /userpreferences page.\n\nNavigator\n\nThe Navigator extension point loads a set of menu items to be displayed in the menu bar on the left hand side of the Meshery UI.\n\nCapabilities Endpoint Example\n\nMeshery Seerver will proxy all requests to remote provider endpoints. Endpoints are dynamically determined and identified in the â€œcapabilitiesâ€ section of the /capabilities endpoint. Providers as an object have the following attributes (this must be returned as a response to /capabilities endpoint):\n\n{\n  \"provider_type\": \"remote\",\n  \"package_version\": \"v0.1.0\",\n  \"package_url\": \"https://layer5labs.github.io/meshery-extensions-packages/provider.tar.gz\",\n  \"provider_name\": \"Meshery\",\n  \"provider_description\": [\n    \"Persistent sessions\",\n    \"Save environment setup\",\n    \"Retrieve performance test results\",\n    \"Free use\"\n  ],\n  \"extensions\": {\n    \"navigator\": [\n      {\n        \"title\": \"MeshMap\",\n        \"href\": {\n          \"uri\": \"/meshmap\",\n          \"external\": false\n        },\n        \"component\": \"provider/navigator/meshmap/index.js\",\n        \"icon\": \"provider/navigator/img/meshmap-icon.svg\",\n        \"link:\": true,\n        \"show\": true,\n        \"children\": [\n          {\n            \"title\": \"View: Single Mesh\",\n            \"href\": {\n              \"uri\": \"/meshmap/mesh/all\",\n              \"external\": false\n            },\n            \"component\": \"navigator/meshmap/index.js\",\n            \"icon\": \"navigator/img/singlemesh-icon.svg\",\n            \"link\": false,\n            \"show\": true\n          }\n        ]\n      }\n    ],\n    \"user_prefs\": [\n      {\n        \"component\": \"userprefs/meshmap-preferences.js\"\n      }\n    ]\n  },\n  \"capabilities\": [\n    { \"feature\": \"sync-prefs\", \"endpoint\": \"/user/preferences\" },\n    { \"feature\": \"persist-results\", \"endpoint\": \"/results\" },\n    { \"feature\": \"persist-result\", \"endpoint\": \"/result\" },\n    { \"feature\": \"persist-smi-results\", \"endpoint\": \"/smi/results\" },\n    { \"feature\": \"persist-metrics\", \"endpoint\": \"/result/metrics\" },\n    { \"feature\": \"persist-smp-test-profile\", \"endpoint\": \"/user/test-config\" }\n  ]\n}\n\n\n\nMeshery enables you as a service mesh owner to customize your service mesh deployment.\n\nManaging your Remote Provider Extension Code\n\nRemote Provider extensions are kept out-of-tree from Meshery (server and UI). You might need to build your extensions under the same environment and set of dependencies as Meshery. The Meshery framework of extensibility has been designed such that in-tree extensions can be safely avoided while still providing a robust platform from which to extend Mesheryâ€™s functionality. Often, herein lies the delineation of open vs. closed functionality within Meshery. Remote Providers can bring (plugin) what functionality that they want behind this extensible interface (more about Meshery extensibility), at least that is up to the point that Meshery has provided a way to plug that feature in.\n\nOffering out-of-tree support for Meshery extensions means that:\n\n\n  source code to your Meshery extensions are not required to be open source,\n  liability to Mesheryâ€™s stability is significantly reduced, avoiding potential bugs in extended components.\n\n\nThrough clearly defined extension points, Meshery extensions may be offered as closed source capabilities that plug into open source Meshery code. To facilitate integration of your Meshery extensions, you might automate the building and releasing of your separate, but interdependent code repositories. You will be responsible for sustaining both your ReactJS and Golang-based extensions."
					}
					
				
		
				
					,
					
					"project-releases": {
						"id": "project-releases",
						"title": "Releases",
						"categories": "",
						"url": " /project/releases",
						"content": "Version  Date \n\n\n    \n    \n         v0.4.20 \n         December 11, 2020 \n    \n\n    \n    \n         v0.4.22 \n         November 12, 2020 \n    \n\n    \n    \n         v0.4.21 \n         November 12, 2020 \n    \n\n    \n    \n         v0.4.19 \n         November 10, 2020 \n    \n\n    \n    \n         v0.4.13 \n         November 10, 2020 \n    \n\n    \n    \n         v0.4.18 \n         November 08, 2020 \n    \n\n    \n    \n         v0.4.17 \n         October 29, 2020 \n    \n\n    \n    \n         v0.4.16 \n         October 28, 2020 \n    \n\n    \n    \n         v0.4.15 \n         October 23, 2020 \n    \n\n    \n    \n         v0.4.14 \n         October 20, 2020 \n    \n\n    \n    \n         v0.4.12 \n         October 08, 2020 \n    \n\n    \n    \n         v0.4.11 \n         October 05, 2020 \n    \n\n    \n    \n         v0.4.11 \n         October 03, 2020 \n    \n\n    \n    \n         v0.4.9 \n         September 30, 2020 \n    \n\n    \n    \n         v0.4.8 \n         September 28, 2020 \n    \n\n    \n    \n         v0.4.7 \n         September 25, 2020 \n    \n\n    \n    \n         v0.4.6 \n         September 03, 2020 \n    \n\n    \n    \n         v0.4.5 \n         September 02, 2020 \n    \n\n    \n    \n         v0.4.4 \n         August 27, 2020 \n    \n\n    \n    \n         v0.4.3 \n         August 22, 2020 \n    \n\n    \n    \n         v0.4.2 \n         August 17, 2020 \n    \n\n    \n    \n         v0.04.1 \n         August 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.4 \n         July 09, 2020 \n    \n\n    \n    \n         v0.4.0-beta.3 \n         July 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.2 \n         July 08, 2020 \n    \n\n    \n    \n         v0.4.0-beta.1 \n         July 06, 2020 \n    \n\n    \n    \n         v0.3.19 \n         July 05, 2020 \n    \n\n    \n    \n         v0.3.18 \n         July 04, 2020 \n    \n\n    \n    \n         v0.3.16 \n         June 22, 2020 \n    \n\n    \n    \n         v0.3.15 \n         May 04, 2020 \n    \n\n    \n    \n         v0.3.14 \n         April 24, 2020 \n    \n\n    \n    \n         v0.3.13 \n         April 16, 2020 \n    \n\n    \n    \n         v0.3.12 \n         April 10, 2020 \n    \n\n    \n    \n         v0.3.11 \n         March 11, 2020 \n    \n\n    \n    \n         v0.3.10 \n         March 09, 2020 \n    \n\n    \n    \n         v0.3.9 \n         February 02, 2020 \n    \n\n    \n    \n         v0.3.8 \n         January 17, 2020 \n    \n\n    \n    \n         v0.3.7 \n         January 15, 2020 \n    \n\n    \n    \n         v0.3.6 \n         January 14, 2020 \n    \n\n    \n    \n         v0.3.5 \n         January 13, 2020 \n    \n\n    \n    \n         v0.3.17 \n         January 07, 2020 \n    \n\n    \n    \n         v0.3.4 \n         December 30, 2019 \n    \n\n    \n    \n         v0.3.3 \n         December 21, 2019 \n    \n\n    \n    \n         v0.3.2 \n         November 30, 2019 \n    \n\n    \n    \n         v0.3.1 \n         November 13, 2019 \n    \n\n    \n    \n         v0.2.4 \n         November 07, 2019 \n    \n\n    \n    \n         v0.2.3 \n         November 05, 2019 \n    \n\n    \n    \n         v0.2.2 \n         October 26, 2019 \n    \n\n    \n    \n         v0.2.1 \n         October 24, 2019 \n    \n\n    \n    \n         v0.2.1 \n         October 23, 2019 \n    \n\n    \n    \n         v0.1.6 \n         October 14, 2019 \n    \n\n    \n    \n         v0.1.5 \n         September 20, 2019 \n    \n\n    \n    \n         v0.1.4 \n         July 27, 2019 \n    \n\n    \n    \n         v0.1.3 \n         July 01, 2019 \n    \n\n    \n    \n         v0.1.2 \n         June 20, 2019 \n    \n\n    \n    \n         v0.1.1 \n         June 12, 2019 \n    \n\n    \n    \n         v0.1.0 \n         May 29, 2019 \n    \n\n    \n    \n         v0.0.9 \n         May 15, 2019 \n    \n\n    \n    \n         v0.0.8 \n         May 01, 2019 \n    \n\n    \n    \n         v0.0.7 \n         April 29, 2019 \n    \n\n    \n    \n         v0.0.6 \n         April 20, 2019 \n    \n\n    \n    \n         v0.0.5 \n         April 12, 2019 \n    \n\n    \n    \n         v0.0.4 \n         April 07, 2019 \n    \n\n    \n    \n         v0.0.3 \n         March 30, 2019 \n    \n\n    \n    \n         v0.0.2 \n         March 20, 2019 \n    \n\n    \n    \n         v0.0.1 \n         March 07, 2019"
					}
					
				
		
				
					,
					
					"es-project-releases": {
						"id": "es-project-releases",
						"title": "Lanzamientos",
						"categories": "",
						"url": " /es/project/releases",
						"content": "Lanzamientos de Meshery\n\nv0.4.4\n\nLanzado el 27 de agosto de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    CaracterÃ­sticas\n\n    \n      Timeout agregado en golang-ci lint\n      Movido a Gorilla/mux para el enrutamiento del servidor\n      Migrado a golangci-lint\n      Interfaz del generador de carga nighthawk inicializada\n    \n  \n  \n    Mantenimiento\n\n    \n      Se actualizÃ³ la rama meshmap a la Ãºltima versiÃ³n en la rama master\n      TÃ­tulo de la pÃ¡gina en negrita\n      Se moviÃ³ meshery adapter para osm\n    \n  \n  \n    DocumentaciÃ³n\n\n    \n      Se agregaron notas RVM adicionales para usuarios de Windows\n      Se agregÃ³ captura de pantalla y descripciÃ³n de SMI\n      AÃ±adida la versiÃ³n actual de osm\n    \n  \n  \n    CorrecciÃ³n de bugs\n    \n      DetecciÃ³n automÃ¡tica de la configuraciÃ³n de kube\n      Se corrigiÃ³ la barra social del pie de pÃ¡gina\n    \n  \n\n\nv0.4.3\n\nLanzado el 22 de agosto de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    CaracterÃ­sticas\n\n    \n      Utiliza Open Service Mesh en lugar de osm\n      MenÃº desplegable de uso del campo de duraciÃ³n + texto en la preferencia de rendimiento\n      Se agregaron â€œtooltipsâ€ para los elementos del menÃº de navegaciÃ³n en el estado minimizado\n      BotÃ³n de calendario comunitario agregado\n    \n  \n  \n    DocumentaciÃ³n\n\n    \n      PÃ¡ginas de documentos arregladas\n      README.md actualizado\n      Se agregÃ³ el enlace de la guÃ­a de bienvenida y el enlace para los principiantes\n      Se agregÃ³ â€œOpen Service Meshâ€ al menÃº de navegaciÃ³n en los documentos de Meshery\n    \n  \n  \n    CorrecciÃ³n de bugs\n    \n      smi-conformance: se agregaron dos puntos al principio\n      Se agregÃ³ la fila inferior que faltaba\n    \n  \n\n\nv0.4.2\n\nLanzado el 17 de agosto de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    CaracterÃ­sticas\n\n    \n      Actualizar las operaciones CRUD en la configuraciÃ³n de prueba\n      CorrecciÃ³n de la â€œsnackbarâ€ no deseada en la pestaÃ±a de preferencias perf\n      Agregar validaciÃ³n para el protocolo en URL\n      Inicializar el adaptador OSM para Meshery\n      Agregar un nuevo comando â€œrestartâ€ a mesheryctl\n    \n  \n  \n    Mantenimiento\n\n    \n      Reparar el â€œciâ€ roto para pruebas de interfaz de usuario\n      Optimizar imÃ¡genes\n      Quitar el paso redundante de â€œdocker pushâ€\n    \n  \n  \n    DocumentaciÃ³n\n\n    \n      Quitar enlaces rotos de la tabla de plataformas compatibles\n      Quitar ejemplo de salida de â€œbrew upgrade mesheryctlâ€\n      Crear archivo smi-conformance-capability.md\n      Reparar los enlaces rotos del sitio de documentaciÃ³n\n      Reparar el enlace roto a SMP en release.md\n      Actualizar el adaptador Meshery Kuma a beta\n      Actualizar los documentos del adaptador\n      Agregar logotipos a la carpeta â€œassetsâ€\n      Agregar Open Service Mesh a la lista\n      Corregir error tipogrÃ¡fico en la descripciÃ³n del Adaptador App Mesh\n    \n  \n  \n    CorrecciÃ³n de bugs\n    \n      Crear/Quitar/Leer en perfiles de prueba de usuario\n      CorrecciÃ³n para la pÃ¡gina de resultados\n      Arreglar el archivo de configuraciÃ³n de releaseDrafter\n    \n  \n\n\nv0.4.1\n\nLanzado el 8 de agosto de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  DocumentaciÃ³n\n    \n      Correcciones de â€œtyposâ€ y errores\n    \n  \n\n\nv0.4.0-beta.4\n\nLanzado el 9 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  CorrecciÃ³n de bugs\n    \n      hotfix: No se puede crear la pÃ¡gina de configuraciÃ³n de Meshery\n    \n  \n\n\nv0.4.0-beta.3\n\nLanzado el 8 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  CorrecciÃ³n de bugs\n    \n      Hotfix del error introducido en la versiÃ³n v0.4.0-beta.2\n    \n  \n\n\nv0.4.0-beta.2\n\nLanzado el 8 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Meshery\n    \n      Se agregÃ³ el archivo kubeconfig inicial.\n    \n  \n  Mesheryctl\n    \n      Se quitÃ³ el error fatal debido a que faltaba meshery.yaml.\n    \n  \n  DocumentaciÃ³n\n    \n      Logotipo del adaptador Kuma actualizado en Meshery Docs.\n      Se agregaron puertos de red a la tabla de adaptadores.\n      Captura de pantalla de proveedores agregada.\n      Se agregaron todas las plataformas compatibles a la lista.\n      Se agregÃ³ Nighthawk como generador de carga.\n      Se arreglÃ³ el enlace roto en la pÃ¡gina de EKS.\n    \n  \n\n\nv0.3.19\n\nLanzado el 7 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se corrigiÃ³ un error importante por no inicializar la carpeta de la aplicaciÃ³n (~/meshery) y el archivo de configuraciÃ³n de la aplicaciÃ³n (meshery.yaml).\n    \n  \n\n\nv0.4.0-beta.1\n\nLanzado el 5 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Meshery\n    \n      Etiqueta â€œstable-latestâ€ para el nuevo canal de lanzamiento.\n    \n  \n\n\nv0.3.18\n\nLanzado el 4 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      mesheryctl version ahora obtiene la informaciÃ³n de la versiÃ³n del servidor, incluida la etiqueta de lanzamiento y git sha.\n      meshery perf ahora soporta SPMS como un paquete a travÃ©s del indicador --file.\n    \n  \n  Meshery\n    \n      Mejora de la extensibilidad: ahora se proporciona una interfaz abstracta, Load Generator Interface, para facilitar la extensiÃ³n de Meshery para admitir otros generadores de carga, como Nighthawk.\n    \n  \n  Documentos\n    \n      instrucciones de EKS y GKE mejoradas\n    \n  \n\n\nv0.3.17\n\nLanzado el 1 de julio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Meshery\n    \n      CaracterÃ­stica: Se estableciÃ³ un nuevo canal de lanzamiento â€œstableâ€.\n      CaracterÃ­stica: Experiencia de usuario mejorada para encabezados HTTP de prueba de rendimiento avanzado.\n    \n  \n\n\nv0.3.16\n\nLanzado el 22 de junio de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      CaracterÃ­stica: Se agregÃ³ mesheryctl system como el nuevo comando para la gestiÃ³n del ciclo de vida de Meshery.\n        \n          Todos los comandos de gestiÃ³n del ciclo de vida de Meshery como start, stop, reset, logs, y asÃ­, ahora se encuentran en system.\n        \n      \n      CaracterÃ­stica: Se agregÃ³ mesheryctl system config como un nuevo subcomando para ayudar a configurar Meshery para comunicarse con las instancias levantadas de Kubernetes en GKE, AKS y EKS.\n    \n  \n\n\nv0.3.15\n\nLanzado el 1 de mayo de 2020\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      CaracterÃ­stica: Se agregÃ³ la funcionalidad de mesheryctl perf --file &lt;smp.yaml&gt; para perfiles de prueba de rendimiento con formato SMP.\n      CaracterÃ­stica: Cambio de comportamiento mesheryctl perf para usar tokens y admitir JWT.\n    \n  \n\n\nv0.3.14\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Cambio de comportamiento en mesheryctl start para buscar nuevas imÃ¡genes del servidor Meshery por defecto.\n    \n  \n\n\nv0.3.13\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      â€œPoint releaseâ€ para el soporte ARM inicial de mesheryctl.\n    \n  \n\n\nv0.3.12\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      â€œScoop Bucketâ€ y â€œScoop packageâ€ iniciales para mesheryctl.\n    \n  \n\n\nv0.3.11\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Soluciona problemas menores de la experiencia del usuario en el comando mesheryctl perf. Consulta Comandos CLI de Meshery y DocumentaciÃ³n como referencia.\n    \n  \n\n\nv0.3.10\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Introduce el comando mesheryctl perf. Consulta Comandos CLI de Meshery y DocumentaciÃ³n como referencia.\n    \n  \n\n\nv0.3.9\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se agregÃ³ mesheryctl version para proporcionar el nÃºmero de versiÃ³n del lado del servidor.\n      Mejora de mesheryctl logs | stop | start para proporcionar la gramÃ¡tica adecuada en situaciones en las que Meshery estÃ¡ detenido o Docker no estÃ¡ presente.\n    \n  \n  Servidor Meshery\n    \n      Se quitÃ³ la informaciÃ³n superflua mÃ¡s allÃ¡ de la direcciÃ³n IP y el puerto en los â€œendpointsâ€ de Grafana y Prometheus (#612)\n    \n  \n\n\nv0.3.8\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se quitÃ³ la salida de lÃ­nea de comando extraÃ±a. En esta versiÃ³n se mejora la claridad de la interacciÃ³n CLI con mesheryctl.\n    \n  \n\n\nv0.3.7\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Ahora se admiten pruebas de conectividad ad-hoc para Prometheus. Los usuarios pueden hacer clic en el chip Prometheus y hacer que Meshery verifique su capacidad para conectarse a la instancia de Prometheus configurada.\n    \n  \n\n\nv0.3.6\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Ahora se admiten pruebas de conectividad ad-hoc para Grafana. Los usuarios pueden hacer clic en el chip Grafana y hacer que Meshery verifique su capacidad para conectarse a la instancia de Grafana configurada.\n    \n  \n\n\nv0.3.5\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se quitÃ³ init como comando expuesto a los usuarios. La funcionalidad de este comando se usa internamente para mesheryctl start. Un nuevo comando start --check proporcionarÃ¡ la funcionalidad de verificaciÃ³n previa en el lugar de init.\n    \n  \n\n\nv0.3.4\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      mesheryctl version ahora se ha mejorado con la novedad de mostrar el git commit (sha) de la versiÃ³n mesheryctl.\n    \n  \n\n\nv0.3.3\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Providers: una nueva construcciÃ³n de proyecto que permite a los usuarios seleccionar el proveedor de autenticaciÃ³n, almacenamiento a largo plazo, etc.\n    \n  \n\n\nv0.3.2\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Se agregÃ³ mesheryctl version como un nuevo subcomando.\n    \n  \n\n\nv0.3.1\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Servidor Meshery\n    \n      Soporte para wrk2 como generador de carga alternativo.\n    \n  \n\n\nv0.2.4\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Soporte de Homebrew disponible para mesheryctl.\n    \n  \n  Servidor Meshery\n    \n      Adaptador Meshery para Octarine lanzado como estable.\n    \n  \n  DocumentaciÃ³n\n    \n      GuÃ­a de inicio rÃ¡pido revisada para Mac, Linux y Windows.\n      Soporte WSL2 publicado.\n      El script de generaciÃ³n de kubeconfig GKE cambiÃ³ a --decode.\n    \n  \n\n\nv0.2.3\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Salida mejorada del comando status en Windows.\n    \n  \n  Servidor Meshery\n    \n      Posibilidad de hacer â€œdeployâ€ de Meshery en Istio.\n      â€œAdapter Chipsâ€: Mover el nÃºmero de puerto del adaptador al tooltip.\n    \n  \n\n\nv0.2.2\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      Comando update mejorado, sin sobrescribir en la configuraciÃ³n local mientras se ejecuta el comando start.\n    \n  \n  Meshery UI\n    \n      Una nueva vista modal para organizar y mostrar los resultados de rendimiento en formato tabular.\n    \n  \n\n\nv0.2.1\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Mesheryctl\n    \n      RevisiÃ³n de la configuraciÃ³n de Kubernetes dentro del clÃºster y fuera del clÃºster.\n    \n  \n\n\nv0.2.0\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Adaptadores Meshery\n    \n      Adaptador introducido para Network Service Mesh.\n    \n  \n  Servidor Meshery\n    \n      Capacidad para ejecutar pruebas de rendimiento de forma asincrÃ³nica.\n      Recopila y conserva mÃ©tricas de nodos.\n    \n  \n\n\nv0.1.6\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Registro de cambios\n  \n  Nueva interfaz de usuario para administrar la conexiÃ³n de Meshery al clÃºster de Kubernetes.\n  Nueva compatibilidad de mesheryctl para Windows para abrir el navegador predeterminado al iniciar.\n  Nueva aplicaciÃ³n de muestra agregada al adaptador istio: aplicaciÃ³n Hipster (aplicaciÃ³n de demostraciÃ³n de microservicios de Google).\n\n\nv0.1.5\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Registro de cambios\n  \n    Mejoras de UX\n  \n  mesheryctl start ahora espera a que los contenedores de la aplicaciÃ³n Meshery estÃ©n activos antes de iniciar el navegador del usuario.\n  mesheryctl stop ahora muestra el progreso del comando similar a la experiencia cuando se usa el script bash meshery.\n\n\nv0.1.4\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Registro de cambios\n\n\nv0.1.3\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Migrar desde Configurar Meshery a la pÃ¡gina ConfiguraciÃ³n.\n\n\nv0.1.2\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    SincronizaciÃ³n del almacenamiento local del navegador\n  \n  \n    Almacenamiento de sesiones en memoria de Meshery.\n  \n\n\nv0.1.1\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Parche para el bug Alpine.\n\n\nv0.1.0\n\nWhatâ€™s new\n\n\n  Istio inicial completamente funcional.\n\n\nv0.0.9\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Sitio de documentaciÃ³n segregado\n  \n  \n    contenido presentado.\n  \n\n\nv0.0.8\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Posibilidad de importar json del board de Grafana\n  \n  \n    IntegraciÃ³n con Prometheus directamente para mÃ©tricas.\n  \n\n\nv0.0.7\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Migrado lejos de los grÃ¡ficos de iframe incrustados de grafana\n  \n  Ahora usando Chartjs para grÃ¡ficos.\n  Ahora usando C3 para grÃ¡ficos.\n\n\nv0.0.6\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Adaptador pre-alfa de Consul.\n  \n  Soporte para implementar el adaptador SMI Istio.\n  Asegurar la compatibilidad para aplicar los manifiestos SMI a travÃ©s de Meshery.\n\n\nv0.0.5\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    Adaptador Linkerd pre-alpha.\n  \n  \n    Capacidad para filtrar resultados.\n  \n\n\nv0.0.4\n\nÂ¿QuÃ© hay de nuevo?\n-Posibilidad de ver resultados persistentes.\n\n\n  IntegraciÃ³n y soporte para grÃ¡ficos Grafana.\n  Embedding panels in iframe.\n\n\nv0.0.3\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  \n    VersiÃ³n inicial con soporte de adaptadores Meshery.\n  \n  \n    Lanzamiento de una versiÃ³n pre-alfa del adaptador Istio.\n  \n\n\nv0.0.2\n\nÂ¿QuÃ© hay de nuevo?\n\n\n  Capacidad para admitir la ejecuciÃ³n de yaml personalizado en Kubernetes con Istio.\n\n\nv0.0.1\n\nNew release\n\n\n  VersiÃ³n inicial de Meshery\n    \n      Conectar a Kubernetes.\n      Ejecutar comandos preconfigurados en Kubernetes con Istio."
					}
					
				
		
				
					,
					
					"guides-sample-apps": {
						"id": "guides-sample-apps",
						"title": "Deploying Sample Applications",
						"categories": "",
						"url": " /guides/sample-apps",
						"content": "Sample Applications are used to interact and exemplify the features of your service mesh. They are often a collection of microservices which you can be used by the user as a sandbox playground to experiment and learn about the service mesh and itâ€™s exhaustive set of features.\nBefore deploying a sample app on top of your service mesh, the application needs to be exposed and allowed external access to the available services in a cluster. There are a myriad of ways to do this, specific to the service mesh you are using.\n\nA popular way of exposing your cluster is by using Ingress, an API object that defines rules which allow external access to services in a cluster.\n\n\n  Set up Ingress\n  Set up Ingress on Minikube\n\n\nDeploy a sample app on Meshery\n\n\n  Go to the management page of any service mesh and install any of its stable versions\n\n  Click (+) on Manage Sample Application Lifecycle. You will now be able to see a drop down menu with the available sample applications.\n\n\n\n\n  Click on the sample application you want to deploy. This might take up to a minute. You will be notified when the sample application has been deployed\n\n\n\nBookInfo\n\nOriginally built by Istio, BookInfo is a sample application which on deployment displays information about a book, similar to a single catalog entry of an online book store. Displayed on the page is a description of the book, book details (ISBN, number of pages, and so on), and a few book reviews. The application comprises of four microservices:\n\n\n  productpage: The productpage microservice calls the details and reviews microservices to populate the page.\n  details: The details microservice contains book information.\n  reviews: The reviews microservice contains book reviews. It also calls the ratings microservice.\n  ratings: The ratings microservice contains book ranking information that accompanies a book review.\n\n\nOnce BookInfo is deployed, you can use Meshery to apply custom configurations to control traffic, inject latency, perform context-based routing, and so on.\n\n\n\nEmojivoto\n\nEmojivoto is a microservice application, originally built by Linkerd that allows users to vote for their favorite emoji, and tracks votes received on a leaderboard. The application is composed of three microservices:\n\n\n  emojivoto-web: Web frontend and REST API\n  emojivoto-emoji-svc: gRPC API for finding and listing emoji\n  emojivoto-voting-svc: gRPC API for voting and leaderboard\n\n\n\n\nImageHub\n\nImage Hub is a sample application for exploring WebAssembly modules used as Envoy filters. The application was originally written to run on Consul. However, it doesnâ€™t have any dependency on Consul and can be deployed on any service mesh. These modules can be used to implement multi-tenancy or to implement per user rate limiting in your applicationâ€™s endpoints, without messing with your application infrastructure. \nFollow this tutorial to set up ImageHub with Ingress\n\n\n\nHTTPBin\n\nHttpBin is a simple HTTP request and response service that responds to many kinds of http/https requests including the standaard http request methods (or verbs) used by REST.\n\n\n\nLinkerd Books\n\nLinkerd Books is a sample Ruby based application. It is designed to demonstrate the various value propositions, including debugging, observability, and monitoring of your service mesh. It can be used to scope out your meshâ€™s efficiency and for debugging.\n\n\n\nHipster\n\nHipster is a sample cloud-native application, originally built by Google. It comprises of 10 microservices and can be used to showcase and work with Kubernetes, Istio, gRPC and OpenCensus. On deployment, it runs a web-based e-commerce demo application, an example of which can be seen below:"
					}
					
				
		
				
					,
					
					"assets-css-sass-css": {
						"id": "assets-css-sass-css",
						"title": "",
						"categories": "",
						"url": " /assets/css/sass.css",
						"content": ".l5-dark-yellow { background-color: #ebc017 !important; }\n\n.l5-dark-yellow-text { color: #ebc017 !important; }\n\n.l5-light-yellow { background-color: #e9c46a !important; }\n.l5-light-yellow .l5-light-yellow-text { color: #e9c46a !important; }\n.l5-light-yellow table.adapters { box-shadow: 1px 1px 2px grey; border: 1px; }\n.l5-light-yellow table.adapters td { width: auto; vertical-align: middle; border: 1px solid darkgray; }\n.l5-light-yellow table.adapters td.no-adapters { width: auto; text-align: center; color: #aaa; font-style: italic; }\n.l5-light-yellow table.adapters td.alpha-adapters { width: auto; background-color: lightgray; text-align: center; }\n.l5-light-yellow table.adapters td.beta-adapters { width: auto; background-color: #00D3A9; text-align: center; color: #fff; }\n.l5-light-yellow table.adapters td.stable-adapters { width: auto; background-color: #3C494F; text-align: center; color: #fff; }\n.l5-light-yellow table.adapters tr:hover { background-color: #f5f5f5; }\n.l5-light-yellow table.adapters img.adapter-logo { vertical-align: middle; margin-right: 5px; height: 30px; width: 30px; }\n\npre.codeblock-pre { display: inline-flex; justify-content: left; text-align: left; align-items: left; align-content: left; flex-wrap: nowrap; flex-direction: row; background-color: #111; margin: 0; padding: 10px; border-radius: 0.3rem; width: 100%; }\n\n.codeblock { width: 100%; display: inline-flex; overflow: auto; justify-content: left; color: #ddd; margin: 0px; padding: 0px; }\n\n.clipboardjs { display: inline-flex; align-self: flex-end; justify-content: left; width: 100%; overflow-x: auto; padding: 0px; margin: 0px; }\n\n.btn-copy-wrap { align-content: flex-end; }\n\n.clipbtn { margin: 5px; border: 0px; background-color: transparent; color: #ccc; font-size: 1.2rem; }\n\n.clipbtn:hover { color: #fff; cursor: pointer; }\n\ndiv.prereqs { background-color: #3C494F; color: #ddd; margin: 20px; padding: 15px; border-radius: 0.3rem; }\n\na.meshery-light { color: #00b39f; }\n\ntable.mesherycomponents th { background-color: #3C494F; color: white; }\ntable.mesherycomponents td.childcomponent { color: white; background-color: #477E96; }"
					}
					
				
		
				
					,
					
					"installation-platforms-scoop": {
						"id": "installation-platforms-scoop",
						"title": "Scoop",
						"categories": "",
						"url": " /installation/platforms/scoop",
						"content": "Quick Start with Scoop \n\nPrerequisites\n\n1. Install the Meshery command line client, \n\n    mesheryctl\n.\n\n\nmesheryctl can be installed via Scoop (a package manager for Windows, just like apt for Ubuntu). mesheryctl is also available through Homebrew.\nPrerequisites\n\nYou need to have scoop installed on your Windows system to perform these actions.\n\nInstall\n\nTo install mesheryctl using Scoop, execute the following commands.\n\n\n\nscoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\nscoop install mesheryctl\n\n\n\n\nYouâ€™re ready to run Meshery. To do so, execute the following command.\n\n\n\nmesheryctl system start\n\n\n\nUpgrade\n\nTo upgrade mesheryctl, just execute the following command.\n\n\n\nscoop update mesheryctl"
					}
					
				
		
				
		
				
		
				
					,
					
					"es-project-security-vulnerabilities": {
						"id": "es-project-security-vulnerabilities",
						"title": "Vulnerabilidades de seguridad",
						"categories": "",
						"url": " /es/project/security-vulnerabilities",
						"content": "# Informar una vulnerabilidad\n\nEstamos muy agradecidos con quienes investigan temas de seguridad y quienes informan\nsobre las vulnerabilidades de seguridad de Meshery. Investigamos cada informe a fondo.\n\nPara realizar un informe, envÃ­a un correo electrÃ³nico\na la lista de correo privada [meshery-security-vulns-reports@layer5.io](mailto:meshery-security-vulns-reports@layer5.io) con los detalles de la vulnerabilidad.\nPara los bugs normales del producto que no estÃ¡n relacionados con vulnerabilidades de seguridad latentes, dirÃ­jete al repositorio correspondiente\ny envÃ­a un [nuevo issue](https://github.com/layer5io/meshery/issues/new/choose).\n\n### Â¿CuÃ¡ndo informar una vulnerabilidad de seguridad?\n\nEnvÃ­anos un informe siempre que:\n\n- Creas que Meshery tiene una vulnerabilidad de seguridad potencial.\n- No estÃ¡s seguro de cÃ³mo una vulnerabilidad afecta a Meshery.\n- Creas que una vulnerabilidad estÃ¡ presente en otro proyecto que Meshery\n  depende de (Docker, por ejemplo).\n\n### Â¿CuÃ¡ndo no informar una vulnerabilidad de seguridad?\n\nNo envÃ­es un informe de vulnerabilidad si:\n\n- Necesitas ayuda para ajustar los componentes de Meshery para la seguridad.\n- Necesitas ayuda para aplicar actualizaciones relacionadas con la seguridad.\n- Tu problema no estÃ¡ relacionado con la seguridad.\n\n## EvaluaciÃ³n\n\nEl equipo de Meshery reconoce y analiza cada informe de vulnerabilidad dentro de los 10 dÃ­as hÃ¡biles.\n\nCualquier informaciÃ³n de vulnerabilidad que compartas con el equipo de Meshery permanece\ndentro del proyecto Meshery. No divulgamos la informaciÃ³n a otros\nproyectos. Solo compartimos la informaciÃ³n necesaria para solucionar el problema.\n\nMantenemos al informante actualizado a medida que se aborda el estado del problema de seguridad.\n\n## Arreglando el problema\n\nUna vez que se ha distinguido por completo una vulnerabilidad de seguridad, el equipo de Meshery desarrolla una soluciÃ³n.\nEl desarrollo y la prueba de la soluciÃ³n se realizan en un repositorio privado de GitHub para evitar\ndivulgaciÃ³n prematura de la vulnerabilidad.\n\n## DivulgaciÃ³n temprana\n\nEl proyecto Meshery mantiene una lista de correo para la divulgaciÃ³n temprana privada de vulnerabilidades de seguridad.\nLa lista se utiliza para proporcionar informaciÃ³n procesable para socios cercanos de Meshery. La lista no estÃ¡ destinada\npara que las personas se enteren de los problemas de seguridad.\n\n## DivulgaciÃ³n pÃºblica\n\nEl dÃ­a elegido para la divulgaciÃ³n pÃºblica, se lleva a cabo una secuencia de actividades lo mÃ¡s rÃ¡pido posible:\n\n- Los cambios se combinan, desde el repositorio privado de GitHub que contiene la correcciÃ³n, en el conjunto apropiado de ramas pÃºblicas.\n\n- El equipo de Meshery se asegura de que todos los binarios necesarios se creen y se publiquen rÃ¡pidamente.\n\n- Una vez que los binarios estÃ¡n disponibles, se envÃ­a un anuncio en los siguientes canales:\n\n  - El [Blog de Meshery](https://meshery.io/blog/)\n  - El [Feed del Twitter de Meshery](https://twitter.com/mesheryio)\n  - El canal de #announcements en Slack\n\nEn la medida de lo posible, este anuncio serÃ¡ procesable e incluirÃ¡ cualquier medida de mitigaciÃ³n que los clientes puedan tomar antes de\nactualizar a una versiÃ³n fija."
					}
					
				
		
				
					,
					
					"project-security-vulnerabilities": {
						"id": "project-security-vulnerabilities",
						"title": "Security Vulnerabilities",
						"categories": "",
						"url": " /project/security-vulnerabilities",
						"content": "## Reporting a vulnerability\n\nWe are very grateful to the security researchers and users that report\nback Meshery security vulnerabilities. We investigate every report thoroughly.\n\nTo make a report, send an email to the private\n[meshery-security-vulns-reports@meshery.dev](mailto:meshery-security-vulns-reports@meshery.dev)\nmailing list with the vulnerability details. For normal product bugs\nunrelated to latent security vulnerabilities, please head to\nthe appropriate repository and submit a [new issue](https://github.com/layer5io/meshery/issues/new/choose).\n\n### When to report a security vulnerability?\n\nSend us a report whenever you:\n\n- Think Meshery has a potential security vulnerability.\n- Are unsure whether or how a vulnerability affects Meshery.\n- Think a vulnerability is present in another project that Meshery\ndepends on (Docker for example).\n\n### When not to report a security vulnerability?\n\nDon't send a vulnerability report if:\n\n- You need help tuning Meshery components for security.\n- You need help applying security related updates.\n- Your issue is not security related.\n\nInstead, join the [Layer5 Slack community](http://slack.layer5.io/) and ask questions.\n\n### Evaluation\n\nThe Meshery team acknowledges and analyzes each vulnerability report within 10 working days.\n\nAny vulnerability information you share with the Meshery team stays\nwithin the Meshery project. We don't disseminate the information to other\nprojects. We only share the information as needed to fix the issue.\n\nWe keep the reporter updated as the status of the security issue is addressed.\n\n### Fixing the issue\n\nOnce a security vulnerability has been fully characterized, a fix is developed by the Meshery team.\nThe development and testing for the fix happens in a private GitHub repository in order to prevent\npremature disclosure of the vulnerability.\n\n### Early disclosures\n\nThe Meshery project maintains a mailing list for private early disclosure of security vulnerabilities. \nThe list is used to provide actionable information to close Meshery partners. The list is not intended \nfor individuals to find out about security issues.\n\n### Public disclosures\n\nOn the day chosen for public disclosure, a sequence of activities takes place as quickly as possible:\n\n- Changes are merged from the private GitHub repository holding the fix into the appropriate set of public\nbranches.\n\n- Meshery team ensures all necessary binaries are promptly built and published.\n\n- Once the binaries are available, an announcement is sent out on the following channels:\n  - The [Meshery blog](https://meshery.io/blog/)\n  - The [Meshery Twitter feed](https://twitter.com/mesheryio)\n  - The [#announcements](https://layer5io.slack.com/archives/CSF3PSZT9) channel on [Layer5 Slack](http://slack.layer5.io/)\n\nAs much as possible this announcement will be actionable, and include any mitigating steps customers can take prior to upgrading to a fixed version."
					}
					
				
		
				
					,
					
					"functionality-service-mesh-interface": {
						"id": "functionality-service-mesh-interface",
						"title": "Meshery and Service Mesh Interface (SMI)",
						"categories": "",
						"url": " /functionality/service-mesh-interface",
						"content": "## Conformance\n\nDefining â€œConformanceâ€ - Itâ€™s important to acknowledge that conformance consists of both capabilities and compliance status. We define conformance as a combination of these two concepts.\n\n1. SMI Conformance acknowledges that\n   ...some participating service meshes may conscientiously never fully implement functions (SMI specs)...\n\n2. SMI Conformance identifies\n   ...a difference between full implementation of a specification and compliance with the portions that it implements...\n\n## Capability\n\nGiven that some service mesh implementations, never intend to fully implement the SMI specifications, for each individual test, three possible capability designations exist\n\n- Full - service mesh has this capability.\n\n- Partial - service mesh has a portion of this capability implemented (may or may not have this full capability in the future).\n\n- None - currently service mesh does not have this capability (may or may not have this capability in the future).\n\n## Approach to Conformance Testing\n\nEach Kubernetes version, service mesh version and SMI category will undergo several tests. Each test will be carried out in an automated and concurrent fashion, mostly, by invoking Meshery to execute the conformance tests.\n\n#### Here are the steps\n\n- Setup a specific version of a service mesh\n- [Optional] Setup Prometheus accordingly\n- Deploy a chosen sample app\n- Deploy the needed SMI operator like smi-metrics\n  the test to run, which can involve calling an API endpoint\n- Validation of the response\n\nNot all tests can be validated by just using the response, in those cases we can also connect to a prometheus instance, which is preconfigured to collect all the metrics for the test, and use these metrics to define expectations. We will be working on specific examples.\n\nFinally, the results for the test runs from Meshery are persisted (same GitHub repository) and published on the conformance web page. Eventually, we can build a system which will allow us to run granular tests on demand for a chosen Kubernetes, service mesh and SMI Operator versions.\n\n## Conformance Test Definitions\n\nConformance tests are categorized by SMI specification type. A set of tests are defined for each SMI specification. Within each test set, two types of assertion tests are defined a presence assertion and a capability assertion.\n\n## Validating Conformance\n\nConformance to SMI specifications will be done through automated provisioning of individual service meshes and deployment of a common workload. A simple, instrumented, sample application is used as the workload to test.\n\n## Defining Conformance\n\nConformance with SMI specifications is defined as a series of test assertions. A test assertion is a condition that must be tested to confirm conformance to a requirement. A test assertion is a condition that from the perspective of validation testing, determining conformance will require any number of conditions to be tested. The collection of test assertions categorized by SMI specification collectively define the suite of SMI conformance tests. Meshery is the test harness used to fit SMI conformance tests to different service meshes and different workloads.\n\n## Steps To Executing Performance Tests\n\n### Preconditions\n\n- A given service meshâ€™s ability to adhere to the SMI specification is validated by running a workload on top of the service mesh.\n- Workload deployments are configured specific to the onboarding requirements of the given service mesh.\n- Tests are defined to validate conformance for each type of SMI specification (e.g. metrics, access, trafficâ€¦ ).\n\n### Invocation\n\n- Test assertions are defined in a workload-specific way and deployed with the workloads being tested (test assertions are packaged).\n- A test result is collected with the evaluation of each assertion.\n- Future Test results will be individually streamed to Meshery after each assertion is evaluated.\n- Once all assertions are evaluated, test results are returned for visual presentation in Meshery\n\n## Reporting Conformance\n\n### Provenance of Test Results\n\nEach participating service mesh project will be asked to incorporate the conformance tool, Meshery, into their CI pipelines, or alternatively, to manually run the conformance test suite when a release of the service mesh project is made. The conformance tool will run the test suite and automatically update the conformance dashboard when the test is complete.\nIn order to ensure provenance of test results that represent a given service mesh, each project will be asked to identify one or more github accounts that will be used for publishing the tests. Ideally, this github account is a servicerobot account used within the projectâ€™s CI pipeline.\n\nThis method of providing verification of results is similarly used for those same service mesh projects that also use Meshery to provide their performance test results.\n\nEach service mesh project needs to identify their servicerobot account, by updating this list httpsmeshery.iosmi-conformancesm-service-accounts. Identify a given Meshery Provider user and designate their â€œCI service accountâ€.\n\n## Publishing Test Results\n\nA public-facing report will display the current and historical status of individual service mesh capability with each of the SMI specifications. The report will be visual in nature, but also be available as yaml. Dashboard to be published publicly here httpsmeshery.iosmi-conformance (currently, listed on httpslayer5.iolandscape#smi).\n\n### Historical Conformance\n\nReports will track the history of service mesh versions and SMI spec versions and their compatibility."
					}
					
				
		
				
					,
					
					"sitemap-xml": {
						"id": "sitemap-xml",
						"title": "",
						"categories": "",
						"url": " /sitemap.xml",
						"content": "/\n     {{ \"now\" | date: \"%Y-%m-%d\" }}\n     daily\n    \n{% for section in site.data.toc %}\n     {{ site.baseurl }}{{ section.url }}/\n     {{ \"now\" | date: \"%Y-%m-%d\" }}\n     daily\n    \n{% endfor %}"
					}
					
				
		
				
					,
					
					"es-functionality-smi-conformance": {
						"id": "es-functionality-smi-conformance",
						"title": "SMI Conformance Capability",
						"categories": "",
						"url": " /es/functionality/smi-conformance",
						"content": "# Capacidad de conformidad de SMI\r\n\r\n## Conformidad\r\n\r\nDefiniendo â€œConformidadâ€ - Es importante reconocer que la conformidad consiste en capacidades y estado de conformidad. Nosotros definimos la conformidad como una combinaciÃ³n de estos 2 conceptos.\r\n\r\n1. La conformidad de SMI reconoce que\r\n   ...algunos service mesh participantes nunca implementan completamente funciones a conciencia (especificaciones SMI)...\r\n\r\n2. La conformidad SMI identifica\r\n   ...una diferencia entre la completa implementaciÃ³n de una especificaciÃ³n y el cumplimiento de las partes que implementa...\r\n\r\n## Capacidad\r\n\r\nDado que algunas implementaciones del service mesh nunca tienen la intenciÃ³n de implementar completamente las especificaciones de SMI, por cada prueba individual, existen tres posibles designaciones de capacidad.\r\n\r\n- Completa - los service mesh tienen esta capacidad.\r\n\r\n- Parcial - los service mesh tienen implementada una porciÃ³n de esta capacidad (puede o no tener esta capacidad completamente en el futuro).\r\n\r\n- Ninguna - actualmente los service mesh no tienen esta capacidad (puede o no tener esta capacidad en el futuro).\r\n\r\n## Enfoque de las pruebas de conformidad\r\n\r\nCada versiÃ³n de Kubernetes, versiÃ³n de service mesh y categorÃ­a de SMI serÃ¡n sometidas a varias pruebas. Cada prueba se llevarÃ¡ a cabo de forma automatizada y concurrente, principalmente invocando a Meshery para ejecutar las pruebas de conformidad.\r\n\r\n#### Estos son los pasos\r\n\r\n- Configurar una versiÃ³n especÃ­fica de un service mesh\r\n- [Opcional] Configurar Prometheus\r\n- Desplegar una aplicaciÃ³n de muestra elegida\r\n- Desplegar el operador SMI necesario, como smi-metrics\r\n  la prueba se ejecutarÃ¡, lo que puede implicar la llamada a un punto final de API\r\n- Validar la respuesta\r\n\r\nNo todas las pruebas pueden ser validadas simplemente usuando la respuesta, en estos casos podemos tambiÃ©n conectarnos a una instancia de Prometheus, el cual estÃ¡ preconfigurado para recolectar todas las mÃ©tricas para la prueba, y usar estas mÃ©tricas para definir expectativas. Trabajaremos en ejemplos especÃ­ficos.\r\n\r\nFinalmente, los resultados de las ejecuciones de pruebas de Meshery son persistentes (como repositorios de GitHub) y publicados en la pÃ¡gina web de conformidad. Eventualmente, podemos construir un sistema el cual nos permitirÃ¡ ejecutar de forma granular pruebas en demanda para una versiÃ³n elegida de Kubernetes, service mesh y operador de SMI.\r\n\r\n## Definiciones de las pruebas de conformidad\r\n\r\nLas pruebas de conformidad son clasificadas por tipo de especificaciÃ³n SMI. Un conjunto de pruebas son definidas para cada especificaciÃ³n SMI. Dentro de cada conjunto de pruebas, se definen dos tipos de pruebas de aserciÃ³n: aserciÃ³n de presencia y aserciÃ³n de capacidad.\r\n\r\n## ValidaciÃ³n de conformidad\r\n\r\nLa conformidad con las especificaciones de SMI se realizarÃ¡n a travÃ©s del aprovisionamiento automatizado de service mesh individuales y el despliegue de una carga de trabajo en comÃºn. Se utiliza una aplicaciÃ³n de muestra sencilla e instrumentada como carga de trabajo para probar.\r\n\r\n## DefiniciÃ³n de conformidad\r\n\r\nLa conformidad con las especificaciones de SMI es definida como una serie de pruebas de aserciÃ³n. Una prueba de aserciÃ³n es una condiciÃ³n que debe probarse para confirmar la conformidad con un requisito. Una prueba de aserciÃ³n es una condiciÃ³n que desde la perspectiva de las pruebas de validaciÃ³n, determinan la conformidad requerida para que se prueben varias condiciones. La colecciÃ³n de pruebas de aserciÃ³n clasificadas por la especificaciÃ³n de SMI define colectivamente el conjunto de pruebas de conformidad de SMI. Meshery es el mejor arnÃ©s de prueba utilizado para ajustar las pruebas de conformidad de SMI para diferentes service mesh y diferentes cargas de trabajo.\r\n\r\n## Pasos para ejecutar pruebas de rendimiento\r\n\r\n### Precondiciones\r\n\r\n- La capacidad de un determinado service mesh para adherirse a una especificaciÃ³n de SMI es validada ejecutando una carga de trabajo sobre el service mesh.\r\n- Los depliegues de cargas de trabajo son configurados de forma especÃ­fica para los requisitos de incorporaciÃ³n del service mesh dado.\r\n- Las pruebas son definidas para validar la conformidad para cada tipo de especificaciÃ³n de SMI (por ejemplo, mÃ©tricas, acceso, trÃ¡fico...).\r\n\r\n### InvocaciÃ³n\r\n\r\n- Las pruebas de aserciÃ³n son definidas de acuerdo a una carga de trabajo especÃ­fica y son desplegadas con las cargas de trabajo que se estÃ¡n probando (las pruebas de aserciÃ³n estÃ¡n empaquetadas).\r\n- Un resultado de prueba es recolectado con la evaluaciÃ³n de cada aserciÃ³n.\r\n- Los resultados de futuras pruebas se transmitirÃ¡n individualmente a Meshery despuÃ©s de que se evalÃºe cada aserciÃ³n.\r\n- Una vez que todas las aserciones son evaluadas, los resultados de las pruebas son retornadas a Meshery para su representaciÃ³n visual.\r\n\r\n## Informe de conformidad\r\n\r\n### Procedencia de los resultados de pruebas\r\n\r\nA cada proyecto de service mesh participante se le pedirÃ¡ que incorpore la herramienta de conformidad, Meshery, en sus pipelines de CI o, alternativamente, que ejecute manualmente el conjunto de pruebas de conformidad cuando se realice un despliegue del proyecto de service mesh. La herramienta de conformidad ejecutarÃ¡ el conjunto de pruebas y automÃ¡ticamente actualizarÃ¡ el panel de conformidad cuando la prueba sea completada.\r\nPara garantizar la procedencia de los resultados de las pruebas que representan un service mesh determinado, se pedirÃ¡ a cada proyecto que identifique uno o mÃ¡s cuentas de GitHub que se utilizarÃ¡n para publicar las pruebas. Idealmente, esta cuenta de GitHub es una cuenta servicerobot que se usa dentro del pipeline de CI del proyecto.\r\n\r\nEste mÃ©todo de proporcionar la verification de resultados es usado de manera similar para esos mismos proyectos de service mesh que tambiÃ©n usan Meshery, para proporcionar sus resultados de pruebas de rendimiento.\r\n\r\nCada proyecto de service mesh necesita identificar su cuenta de servicerobot, actualizando esta lista httpsmeshery.iosmi-conformancesm-service-accounts. Identifique un usuario proveedor de Meshery determinado y designe su \"cuenta de servicio de CI\".\r\n\r\n## PublicaciÃ³n de resultados de pruebas\r\n\r\nUn informe de cara al pÃºblico mostrarÃ¡ el estado actual e histÃ³rico de la capacidad del service mesh individual con cada una de las especificaciones de SMI. El informe serÃ¡ de natuaraleza visual, pero tambiÃ©n estÃ¡ disponible como yaml. El panel se publicarÃ¡ pÃºblicamente aquÃ­ httpsmeshery.iosmi-conformance (actualmente, listado en httpslayer5.iolandscape#smi).\r\n\r\n### Conformidad histÃ³rica\r\n\r\nLos informes rastrearÃ¡n el historial de las versiones del service mesh, las versiones de las especificaciones SMI y su compatibilidad."
					}
					
				
		
				
		
				
					,
					
					"guides-upgrade": {
						"id": "guides-upgrade",
						"title": "Upgrade `mesheryctl` and Meshery",
						"categories": "",
						"url": " /guides/upgrade",
						"content": "# Upgrade Guide\n\n## Upgrading Meshery Server, Adapters, and UI\n\nVarious components of Meshery will need to be upgraded as new releases become available. Meshery is comprised of a number of components including a server, adapters, UI, and CLI. As an application, Meshery is a composition of different functional components.\n\n\n    \nFigure: Meshery components\n\n\nSome of the components must be upgraded simultaneously, while others may be upgraded independently. The following table depicts components, their versions, and deployment units (deployment groups).\n\n\n\n### Versioning of Meshery components\n\n\n    \n        Components\n        Sub-component\n        Considering or Updating\n    \n    \n        Meshery Adapters\n        Any and All Adapters\n        Docker Deployment: Watchtower updates this component in accordance with the userâ€™s release channel subscription.\n    \n    \n        Meshery Server\n        Meshery UI\n        Manages lifecycle of Meshery Operator; Adapters, UI, Load Generators, Database.\nDocker Deployment: Watchtower updates this component in accordance with the userâ€™s release channel subscription.\n    \n    \n        Load Generators\n    \n    \n        Database\n    \n    \n        Meshery Operator\n        MeshSync\n        Meshery Operator manages the lifecycle of this component and its sub-components.\n    \n    \n        Meshery Broker\n        Meshery Operator manages the lifecycle of this event bus component.\n    \n    \n        `mesheryctl`\n        \n        mesheryctl manages the lifecycle of Meshery Server. \n         \n            system start calls system update by default, which updates server and existing adapters, but doesnâ€™t update meshery.yaml.\n            system reset retrieving docker-compose.yaml from GitHub (use git tag to reset to the right Meshery version).\n            system context manages config.yaml, which manages meshery.yaml. \n            mesheryctl should generally be checking for latest release and informing user.\n        \n        \n    \n    \n        Remote Providers\n        Meshery Cloud\n        Process Extension: Integrators manage the lifecycle of their Remote Providers. Process is unique per provider.\n    \n    \n        Meshery Cloud\n         Static Extension: Integrators manage the lifecycle of their Meshery Extensions. Process is unique per provider.\n    \n\n\n\nSub-components deploy as a unit, however, they do not share the same version number.\n\n### Meshery Docker Deployments\n\nIn order to upgrade Meshery Server, Adapters, and UI, execute the following command:\n\n \n \n mesheryctl system update\n \n \n\n### Meshery Kubernetes Deployments\n\nUse `kubectl apply` or `helm` to upgrade the Meshery application manifests in your Kubernetes cluster.\n\n## Upgrading Meshery CLI\n\nThe Meshery command line client, `mesheryctl`, is available in different package managers. Use the instructions relevant to your environment.\n\n### Upgrading `mesheryctl` using Homebrew\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n brew upgrade mesheryctl\n \n \n\n### Upgrading `mesheryctl` using Bash\n\nUpgrade `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n### Upgrading `mesheryctl` using Scoop\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n scoop update mesheryctl"
					}
					
				
		
				
					,
					
					"es-installation-platforms-windows": {
						"id": "es-installation-platforms-windows",
						"title": "Windows",
						"categories": "",
						"url": " /es/installation/platforms/windows",
						"content": "# **Inicio rÃ¡pido con Windows**\n\nPara configurar y ejecutar Meshery en Windows:\n\n1. Configurar Windows y habilitar Docker \n2. Instalar un cluster Kubernetes\n3. Instalar Meshery\n\n### **Compatibilidad**\n\nLas siguientes versiones mÃ­nimas de CompilaciÃ³n de Windows son requeridas:\n\n\n  \n    Nombre\n    VersiÃ³n\n  \n  \n    WSL1\n    x64 - Windows 7 \n  \n  \n    WSL2\n    x64 - Version 1903, CompilaciÃ³n 18362; ARM 64 - Version 2004, CompilaciÃ³n 19041\n  \n  \n    Kernel Personalizado\n    CompilaciÃ³n 18945\n  \n  \n    Kernel con mÃ³dulos requeridos K8s\n    CompilaciÃ³n 19013\n  \n\n\n**Nota**\nEjecute el siguiente comando en Powershell para comprobar la compilaciÃ³n y la versiÃ³n de Windows:\n\n```powershell\n[System.Environment]::OSVersion.Version\n```\n\n### **Pasos**\n\nRealice los siguientes pasos en orden:\n\n#### 1. Instalar el subsistema de Windows para Linux (WSL)\n\nAbra la Powershell en modo administrador y ejecute:\n\n```powershell\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\nRestart-Computer\n```\n\n##### **Elegir tu versiÃ³n WSL:**\n\nWSL2 (Recomendado)\nElija la versiÃ³n por defecto a `WSL2`, la cual serÃ¡ heredada por cualquier distro que desee usar.\n\n**Habilite la caracterÃ­stica VM (Virtual Machine)**:\n\n```powershell\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n**Colocar WSL2 como la versiÃ³n default**:\n\n```bash\nwsl --set-default-version 2\n```\n\n WSL1 \n\nAdvertencia:\nSe recomienda actualizar a WSL2 ya que WSL1 no soporta la aplicaciÃ³n Docker Desktop para Windows. En su lugar, solo soporta la versiÃ³n obsoleta, [Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/).\n\nSi aun desea continuar, siga las instrucciones para WSL1\n\n\n\n1. La versiÃ³n por defecto de WSL estÃ¡ establecida en WSL1 por defecto. Puedes ir al siguiente link para instalar la distro de tu elecciÃ³n. \n\n2. Docker Toolbox \n\nAdvertencia: Docker Toolbox es una versiÃ³n obsoleta. Se recomienda actualizar el sistema e instalar la aplicaciÃ³n Docker Desktop con WSL2. \n\nDocker Toolbox utiliza caracterÃ­sticas especÃ­ficas del kernel de Linux, y no puede funcionar de forma nativa en Windows. En su lugar, crea y utiliza una pequeÃ±a VM de Linux en tu mÃ¡quina junto con docker-machine , y utiliza VirtualBox para ejecutar Docker. \n\n DirÃ­jase a Toolbox Releases y descargue la Ãºltima versiÃ³n del archivo .exe\n Siga estas instrucciones para configurar con Ã©xito la aplicaciÃ³n Docker Toolbox. \n\n\n\n\n\n#### 2. [Instalar la nueva distro](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice)\n\nEn este tutorial, [Ubuntu 18.04](https://www.microsoft.com/en-us/p/ubuntu-1804-lts/9n9tngvndl3q?activetab=pivot:overviewtab) serÃ¡ la distro utilizada. SiÃ©ntase libre de usar cualquier distro a su elecciÃ³n.\n\n#### 3. habilitar Docker\n\nLa aplicaciÃ³n Docker Desktop para Windows incluye un completo conjunto de herramientas, incluyendo Docker Engine, el cliente Docker CLI, Docker Compose, Notary, Kubernetes, y un Credential Helper.\n\n\n  \n    VersiÃ³n Windows 10\n    Docker Desktop\n  \n  \n    Pro/Education/Enterprise\n    Docker Desktop para Windows Pro\n  \n  \n    Home\n    Docker Desktop para Windows Home\n  \n\n\n#### 4.  Instalar un cluster Kubernetes\n\nUna vez que Docker estÃ© instalado, el siguiente paso serÃ¡ instalar un cluster Kubernetes. En esta guÃ­a, se usarÃ¡ [K3d](https://github.com/rancher/k3d) ya que sÃ³lo depende de Docker.\n\n```bash\ncurl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash\nk3d cluster create\nexport KUBECONFIG=\"$(k3d kubeconfig get 'k3s-default')\"\n```\n\n#### 5. Instalar Meshery\n\nSiga los [pasos de instalaciÃ³n]({{ site.baseurl }}/es/installation/windows.md) para instalar el CLI mesheryctl. Luego, ejecute:\n\n```bash\n./mesheryctl system start\n```"
					}
					
				
		
				
					,
					
					"installation-platforms-windows": {
						"id": "installation-platforms-windows",
						"title": "Windows",
						"categories": "",
						"url": " /installation/platforms/windows",
						"content": "{% include installation_prerequisites.html %}\n\n# Overview\nTo set up and run Meshery on Windows \n\n1. Configure Windows and enable Docker \n2. Install a Kubernetes cluster on top \n3. Run Meshery\n\n### Compatibility\n\nThe following minimum Windows build versions are required:\n\n  \n    Name\n    Version \n  \n  \n    WSL1\n    x64 - Windows 7 \n  \n  \n    WSL2\n    x64 - Version 1903, Build 18362; ARM 64 - Version 2004, Build 19041\n  \n  \n    Custom Kernel\n    Build 18945\n  \n  \n    Kernel with K8s required modules\n    Build 19013\n  \n\n\nNote\nRun the following command on Powershell to check your Windows build and version:\n \n \n[System.Environment]::OSVersion.Version\n \n \n### Steps\nPerform the following steps in order:\n\n### 1. Install Windows Subsystem for Linux (WSL) \n\nOpen Powershell in administrator mode and run:\n\n \n \n dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n Restart-Computer\n \n \n\n##### Choosing your WSL version:\n\nWSL2 (Recommended)\nSet the default version to *WSL2*, which will be inherited by any distro you wish to use.\n\nEnable VM (Virtual Machine) feature:\n\n \n \n dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n \n \n\nSet WSL2 as the default version:\n\n \n \n wsl --set-default-version 2\n \n \n\n WSL1 \n\nWarning:\nIt is recommended to update to WSL2 as WSL1 doesn't support the Docker Desktop application for Windows. Instead, it only supports the deprecated version, [Docker Toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/). \n\nIf you still wish to continue, follow the instructions for WSL1\n\n\n\n1. The default version of WSL is set to WSL1 by default. You can move forward to install the distro of your choice. \n\n2. Docker Toolbox \n\nWarning: Docker Toolbox is a deprecated version. It is recommended to update your system and install the Docker Desktop application with WSL2. \n\nDocker Toolbox uses Linux-specific kernel features, and canâ€™t run natively on Windows. Instead, it creates and uses a small Linux VM on your machine along with docker-machine, and uses VirtualBox to run Docker. \n    \n         Go to Toolbox Releases and download the latest release .exe file \n        Follow these instructions to successfully set up the Docker Toolbox application. \n    \n\n\n\n\n\n### 2. [Install a new distro](https://docs.microsoft.com/en-us/windows/wsl/install-win10#install-your-linux-distribution-of-choice)\nIn this tutorial, [Ubuntu 18.04](https://www.microsoft.com/en-us/p/ubuntu-1804-lts/9n9tngvndl3q?activetab=pivot:overviewtab) will be the distro used. Feel free to use any distro of your choice.\n\n\n### 3. Enable Docker\n\nThe Docker Desktop application for Windows includes a comprehensive set of tools, including Docker Engine, Docker CLI client, Docker Compose, Notary, Kubernetes, and a Credential Helper.\n\n\n  \n    Windows 10 Version\n    Docker Desktop \n  \n  \n    Pro/Education/Enterprise\n    Docker Desktop for Windows Pro\n  \n  \n    Home\n    Docker Desktop for Windows Home\n  \n\n\n### 4.  Install a Kubernetes cluster\n\nOnce Docker is installed, the next step will be to install a Kubernetes cluster.\nIn this how-to, [K3d](https://github.com/rancher/k3d) will be used as it relies only on Docker.\n\n  \n  \n  curl -s https://raw.githubusercontent.com/rancher/k3d/main/install.sh | bash\n  k3d cluster create\n  export KUBECONFIG=\"$(k3d kubeconfig get 'k3s-default')\"\n  \n  \n\n\n### 5. Set up Meshery\n\nFollow the [installation steps]({{ site.baseurl }}/installation#windows) to install the mesheryctl CLI. Then, execute:\n  \n  \n  ./mesheryctl system start"
					}
					
				
		
				
					,
					
					"guides-mesheryctl": {
						"id": "guides-mesheryctl",
						"title": "Using mesheryctl",
						"categories": "",
						"url": " /guides/mesheryctl",
						"content": "`mesheryctl` is the command line interface to manage Meshery and interface with its functionality using a terminal. `mesheryctl` commands are categorized into three main areas:\n\n- Lifecycle management of Meshery (control Meshery's lifecycle with commands like `system start`, `stop`, `status`, `reset`. )\n- Lifecycle management of Service Meshes\n- Performance management of Service Meshes and Workloads\n\n\n\n## Related Guides\n\n- For an exhaustive list of commands and syntax, refer to the **[`mesheryctl` Command Reference]({{ site.baseurl }}/guides/mesheryctl-commands)**.\n- To upgrade `mesheryctl`, refer to the **[Upgrade Guide]({{ site.baseurl }}/guides/upgrade)**.\n\n## Installing `mesheryctl`\n\n### Mac or Linux\n\nUse your choice of homebrew or bash to install `mesheryctl`. You only need to use one.\n### Homebrew\n\nInstall `mesheryctl` and run Meshery on Mac with Homebrew.\n\n#### Installing with Homebrew\n\nTo install `mesheryctl`, execute the following commands:\n\n \n \n brew tap layer5io/tap\n brew install mesheryctl\n mesheryctl system start\n \n \n\n**Upgrading with Homebrew**\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n brew upgrade mesheryctl\n \n \n\n#### Bash\n\n**Installing with Bash**\n\nInstall `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n**Upgrading with Bash**\n\nUpgrade `mesheryctl` and run Meshery on Mac or Linux with this script:\n\n \n \n curl -L https://git.io/meshery | bash -\n \n \n\n## Windows\n\n### Installing the `mesheryctl` binary\n\nDownload and unzip `mesheryctl` from the [Meshery releases](https://github.com/layer5io/meshery/releases/latest) page. Add `mesheryctl` to your PATH for ease of use. Then, execute:\n\n \n \n ./mesheryctl system start\n \n \n\n### Scoop\n\nUse [Scoop](https://scoop.sh) to install Meshery on your Windows machine.\n\n**Installing with Scoop**\n\nAdd the Meshery Scoop Bucket and install:\n\n \n \n scoop bucket add mesheryctl https://github.com/layer5io/scoop-bucket.git\n scoop install mesheryctl\n \n \n\n**Upgrading with Scoop**\n\nTo upgrade `mesheryctl`, execute the following command:\n\n \n \n scoop update mesheryctl\n \n \n\n## Advanced Installation\n\nUsers can control the specific container image and tag (version) of Meshery that they would like to run by editing their local *~/.meshery/meshery.yaml* (a docker compose file).\nAligned with the Meshery container image, instead of leaving the implicit :stable-latest tag behind image: layer5/meshery, users will instead identify a specific image tag like so:\n\n```\nbash\nversion: '3'\nservices:\n  meshery:\n    image: layer5/meshery:v0.5.0\n    labels:\n      - \"com.centurylinklabs.watchtower.enable=true\"\n```\n\n# Configuring Autocompletion for `mesheryctl`\n\nIf you would like to have `mesheryctl` commands automatically completed for use as you use `mesheryctl`, then use the following instructions to configure automatic completion within your environment.\n\n## Autocompletion for Bash\n\n### bash \n \n source /dev/stdin \n \n\n### bash >= 4.0\n\n \n \n source \n \n\n### bash \n \n brew install bash-completion # ensure you have bash-completion 1.3+\n mesheryctl system completion bash > $(brew --prefix)/etc/bash_completion.d/mesheryctl\n \n \n\n### bash >= 4.0 on MacOS\n\n \n \n brew install bash-completion@2\n mesheryctl system completion bash > $(brew --prefix)/etc/bash_completion.d/mesheryctl\n \n \n\n## Autocompletion for zsh\n\n \n \n source \n \n\nIf shell completion is not already enabled in your environment you will need to enable it.  You can execute the following once:\n\n \n \n ~/.zshrc > echo \"autoload -U compinit; compinit\" \n \n \n_Note_ : You might need to restart your shell for this setup to take effect.\n\n#### zsh on MacOS and Oh My zsh\n\n \n \n mesheryctl system completion zsh > \"${fpath[1]}/_mesheryctl\"\n \n \n\n### Autocompletion for fish\n\n \n \n mesheryctl system completion fish | source\n \n \n\nTo load fish shell completions for each session, execute once:\n \n \n mesheryctl system completion fish > ~/.config/fish/completions/mesheryctl.fish\n \n \n\n# Suggested Reading\n\n- For an exhaustive list of commands and syntax, refer to the **[`mesheryctl` Command Reference]({{ site.baseurl }}/guides/mesheryctl-commands)**.\n- To upgrade `mesheryctl`, refer to the **[Upgrade Guide]({{ site.baseurl }}/guides/upgrade)**."
					}
					
				
		
				
					,
					
					"assets-css-style-css": {
						"id": "assets-css-style-css",
						"title": "",
						"categories": "",
						"url": " /assets/css/style.css",
						"content": "@import \"jekyll-theme-primer\";"
					}
					
				
		
				
					,
					
					"architecture-adapters": {
						"id": "architecture-adapters",
						"title": "",
						"categories": "",
						"url": " /architecture/adapters",
						"content": ""
					}
					
				
		
				
					,
					
					"architecture": {
						"id": "architecture",
						"title": "",
						"categories": "",
						"url": " /architecture",
						"content": ""
					}
					
				
		
				
					,
					
					"architecture-broker": {
						"id": "architecture-broker",
						"title": "",
						"categories": "",
						"url": " /architecture/broker",
						"content": ""
					}
					
				
		
				
					,
					
					"architecture-database": {
						"id": "architecture-database",
						"title": "",
						"categories": "",
						"url": " /architecture/database",
						"content": ""
					}
					
				
		
				
					,
					
					"reference-extensibility": {
						"id": "reference-extensibility",
						"title": "",
						"categories": "",
						"url": " /reference/extensibility",
						"content": ""
					}
					
				
		
				
					,
					
					"project": {
						"id": "project",
						"title": "",
						"categories": "",
						"url": " /project/",
						"content": ""
					}
					
				
		
				
					,
					
					"installation": {
						"id": "installation",
						"title": "",
						"categories": "",
						"url": " /installation/",
						"content": ""
					}
					
				
		
				
					,
					
					"guides-mesheryctl": {
						"id": "guides-mesheryctl",
						"title": "",
						"categories": "",
						"url": " /guides/mesheryctl",
						"content": ""
					}
					
				
		
				
					,
					
					"guides-mesheryctl-commands": {
						"id": "guides-mesheryctl-commands",
						"title": "",
						"categories": "",
						"url": " /guides/mesheryctl-commands",
						"content": ""
					}
					
				
		
				
					,
					
					"architecture-meshsync": {
						"id": "architecture-meshsync",
						"title": "",
						"categories": "",
						"url": " /architecture/meshsync",
						"content": ""
					}
					
				
		
				
					,
					
					"architecture-operator": {
						"id": "architecture-operator",
						"title": "",
						"categories": "",
						"url": " /architecture/operator",
						"content": ""
					}
					
				
		
				
					,
					
					"redirects-json": {
						"id": "redirects-json",
						"title": "",
						"categories": "",
						"url": " /redirects.json",
						"content": "{\"/architecture/adapters\":\"http://localhost:4000/concepts/architecture/adapters\",\"/architecture\":\"http://localhost:4000/concepts/architecture\",\"/architecture/broker\":\"http://localhost:4000/concepts/architecture/broker\",\"/architecture/database\":\"http://localhost:4000/concepts/architecture/database\",\"/reference/extensibility\":\"http://localhost:4000/extensibility\",\"/project/\":\"http://localhost:4000/project\",\"/installation/\":\"http://localhost:4000/installation/quick-start\",\"/guides/mesheryctl\":\"http://localhost:4000/reference/mesheryctl\",\"/guides/mesheryctl-commands\":\"http://localhost:4000/reference/mesheryctl\",\"/architecture/meshsync\":\"http://localhost:4000/concepts/architecture/meshsync\",\"/architecture/operator\":\"http://localhost:4000/concepts/architecture/operator\"}"
					}
					
				
		
				
					,
					
					"pages-project-contributing-gitflow": {
						"id": "pages-project-contributing-gitflow",
						"title": "Working by Forking",
						"categories": "",
						"url": " /pages/project/CONTRIBUTING-gitflow/",
						"content": "# Working by Forking\nJust head over to the GitHub page and click the \"Fork\" button. It's just that simple. Once you've done that, you can use your favorite git client to clone your repo or just head straight to the command line:\n\n## Clone your fork to your local machine\n```\ngit clone git@github.com:USERNAME/FORKED-PROJECT.git\n```\nKeeping Your Fork Up to Date\nWhile this isn't a necessary step, if you plan on doing anything more than just a tiny quick fix, you'll want to make sure you keep your fork up to date by tracking the original \"upstream\" repo that you forked. To do this, you'll need to add a remote:\n\n## Add 'upstream' repo to list of remotes\n```\ngit remote add upstream https://github.com/layer5io/meshery.git\n``` \n(\"meshery\" is used as the example repo. Be sure to reference the _actual_ repo you're contributing to e.g. \"meshery-linkerd\").\n\n## Verify the new remote named 'upstream'\n```\ngit remote -v\n```\nWhenever you want to update your fork with the latest upstream changes, you'll need to first fetch the upstream repo's branches and latest commits to bring them into your repository:\n\n## Fetch from upstream remote\n```\ngit fetch upstream\n```\n\n## View all branches, including those from upstream\n```\ngit branch -va\n```\nNow, check out your master branch and merge the upstream repo's master branch:\n\n## Checkout your master branch and merge upstream\n```\ngit checkout master\ngit merge upstream/master\n```\nIf there are no unique commits on the local master branch, git will simply perform a fast-forward. However, if you have been making changes on master (in the vast majority of cases you probably shouldn't be - see the next section, you may have to deal with conflicts. When doing so, be careful to respect the changes made upstream.\n\nNow, your local master branch is up-to-date with everything modified upstream.\n\n**Create a Branch** (doing your work)\nWhenever you begin work on a new feature or bugfix, it's important that you create a new branch. Not only is it proper git workflow, but it also keeps your changes organized and separated from the master branch so that you can easily submit and manage multiple pull requests for every task you complete.\n\nTo create a new branch and start working on it, perform the following flow.\n\n## Check out the master branch - you want your new branch to come from the master\n```\ngit checkout master\n```\n\n## Create a new branch (give your branch its own simple informative name)\nFor enhancements use `feature/your_username/issue#` or `feature/your_username/name_of_feature`\n\nFor bugs use `bug/your_username/issue#` or `bug/your_username/name_of_bug`\n\n```\ngit branch feature/jdoe/567\n```\n\n## Switch to your new branch\n```\ngit checkout feature/jdoe/567\n```\nNow, go to town hacking away and making whatever changes you want to.\n\n## Submitting your changes (a Pull Request)\nBefore submitting your pull request, you might want to do a few things to clean up your branch and make it as simple as possible for the original repo's maintainer to test, accept, and merge your work.\n\nIn the time that you've been working on your changes, if any commits have been made to the upstream master branch, you will need to rebase your development branch so that merging it will be a simple fast-forward that won't require any conflict resolution work.\n\n## Fetch upstream master and merge with your repo's master branch\n```\ngit fetch upstream\ngit checkout master\ngit merge upstream/master\n```\n\n## If there were any new commits, rebase your development branch\n```\ngit checkout feature/jdoe/567\ngit rebase master\n```\nNow, it may be desirable to squash some of your smaller commits down into a small number of larger more cohesive commits. You can do this with an interactive rebase:\n\n## Rebase all commits on your development branch\n```\ngit checkout\ngit rebase -i master\n```\nThis will open up a text editor where you can specify which commits to squash.\n\n## Submitting\nOnce you've committed and pushed all of your changes to GitHub, go to the page for your fork on GitHub, select your development branch, and click the pull request button. If you need to make any adjustments to your pull request, just push the updates to GitHub. Your pull request will automatically track the changes in your development branch and update it."
					}
					
				
		
	};
</script>
<script src="/v0.4/assets/js/lunr.min.js"></script>
<script src="/v0.4/assets/js/search.js"></script>


<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

<script>
$(document).ready(function() {

    var toc = $('#TOC');

    // Select each header
    sections = $('.td-content h1');
        $.each(sections, function(idx, v) {
            section = $(v);
            var div_id = $(section).attr('id');
            if(!section.hasClass('noTOC')){
               var div_text = section.text().split('Â¶')[0];
              var parent = $("#" + div_id)
              var content = '<li id="link_' + div_id + '" class="md-nav__item"><a class="md-nav__link" href="#' + div_id + '" title="' + div_text +'">' + div_text +'</a></li>';
              $(toc).append(content);
            }

            // Add section code to subnavigation
            var children = $('<nav class="md-nav"><ul class="md-nav__list"></nav></ul>')
            var contenders = $("#" + div_id).nextUntil("h1");
            $.each(contenders, function(idx, contender){
               if( !$(contender).hasClass("noTOC") && ($(contender).is('h2') || $(contender).is('h3')) ) {
                   var contender_id = $(contender).attr('id');
                   var contender_text = $(contender).text().split('Â¶')[0];
                   var content = '<li class="md-nav__item"><a class="md-nav__link" href="#' + contender_id + '" title="' + contender_text +'">' + contender_text +'</a></li>';
                   children.append(content);
                }
             })
             $("#link_" + div_id).append(children);
        });
    });
</script>	
              
              <br/>


           </div>
          </main>
        </div>
      </div>
      <footer class="bg-dark py-3 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
<!-- meshery-custom-begin"
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">

<ul class="list-inline mb-0">
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="" aria-label="Twitter" data-original-title="Twitter">
    <a class="text-white" target="_blank" href="https://twitter.com/layer5">
      <i class="fab fa-twitter"></i>
    </a>
  </li>
</ul>
</div>
<div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
<ul class="list-inline mb-0">
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="" aria-label="GitHub" data-original-title="GitHub">
    <a class="text-white" target="_blank" href="https://github.com/layer5io/meshery">
      <i class="fab fa-github"></i>
    </a>
  </li>
</ul>
meshery-custom-end -->

<div class="col-12 col-sm-4 text-center py-2 order-sm-2">
  <small class="text-white">Â© 2020 Layer5 All Rights Reserved</small>
  

  <!-- meshery-custom-begin -->

  <p class="mt-2">

  <div class="footer-icons-list">

    <div class="footer-icons">
      <a class="social__link social__link--mail" href="mailto:community@layer5.io">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px" >
          <path fill="currentColor" d="M326.7,166.2c2-1.6,5-0.1,5,2.4v106c0,13.7-11.1,24.9-24.9,24.9H91.2c-13.7,0-24.9-11.1-24.9-24.9v-106
            c0-2.6,3-4,5-2.4c11.6,9,27,20.5,79.9,58.9c10.9,8,29.4,24.8,47.8,24.7c18.5,0.2,37.3-17,47.8-24.7
            C299.7,186.7,315.1,175.2,326.7,166.2z M199,233.2c12,0.2,29.3-15.1,38.1-21.5c68.8-49.9,74-54.3,89.9-66.7c3-2.3,4.8-6,4.8-9.8
            v-9.8c0-13.7-11.1-24.9-24.9-24.9H91.2c-13.7,0-24.9,11.1-24.9,24.9v9.8c0,3.8,1.8,7.4,4.8,9.8c15.9,12.4,21.1,16.8,89.9,66.7
            C169.7,218,187,233.4,199,233.2L199,233.2z"/>
        </svg>

      <span class="footer-icons-text">Get connected with the Layer5 community</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--slack" href="http://slack.layer5.io/" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px" >
          <path fill="currentColor" stroke="currentColor" stroke-width="3" stroke-miterlimit="10" d="M214.6,76.3c-2.7-0.3-5.7,0.3-8.1,1.2c-10.5,3.6-16.2,15-12.6,25.5l8.4,24.9l-48,16.2l-7.8-24
            c-3.6-10.5-15-16.2-25.5-12.6c-10.5,3.6-16.5,15-12.9,25.5l7.8,23.7L91,165.1c-10.5,3.6-16.2,15.3-12.6,25.8s15,16.2,25.5,12.6
            l24.9-8.1l16.2,47.7l-24,7.8c-10.5,3.6-16.2,15-12.6,25.5c3.6,10.5,15,16.5,25.5,12.9l23.7-7.8l8.4,24.6
            c3.6,10.5,15.3,16.2,25.8,12.6s16.2-15,12.6-25.5l-8.4-24.9l47.7-16.2l7.8,24c3.6,10.5,15,16.2,25.5,12.6
            c10.5-3.6,16.5-15,12.9-25.5l-7.8-23.7l24.9-8.4c10.5-3.6,16.2-15.3,12.6-25.8c-3.6-10.5-15-16.2-25.5-12.6l-24.9,8.4L253,153.4
            l24-7.8c10.5-3.6,16.2-15,12.6-25.5c-3.6-10.5-15-16.5-25.5-12.9l-23.7,7.8L232,90.1C229.3,82,222.4,76.9,214.6,76.3z M214.9,166.3
            l16.2,47.7l-47.7,16.2l-16.2-47.7L214.9,166.3z"/>
        </svg>

      <span class="footer-icons-text">Join the Layer5 Slack</span></a>
    </div>

	<div class="footer-icons">
      <a class="social__link social__link--calender" href="https://bit.ly/2SbrRhe" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="-200 -60 820 740" width="50px" height="50px">
          <path fill="currentColor" stroke="currentColor" stroke-width="3" stroke-miterlimit="10" d="M336 292v24c0 6.6-5.4 12-12 12h-76v76c0
		  6.6-5.4 12-12 12h-24c-6.6 0-12-5.4-12-12v-76h-76c-6.6 0-12-5.4-12-12v-24c0-6.6 5.4-12 12-12h76v-76c0-6.6 5.4-12 12-12h24c6.6 0 12
		  5.4 12 12v76h76c6.6 0 12 5.4 12 12zm112-180v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h48V12c0-6.6
		  5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h128V12c0-6.6 5.4-12 12-12h40c6.6 0 12 5.4 12 12v52h48c26.5 0 48 21.5 48 48zm-48 346V160H48v298c0
		  3.3 2.7 6 6 6h340c3.3 0 6-2.7 6-6z"/>
        </svg>

        <span class="footer-icons-text">Subscribe to the community calender</span></a>
    </div>

   <div class="footer-icons">
      <a class="social__link social__link--twitter" href="https://twitter.com/layer5" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" d="M153.6,301.6c94.3,0,145.9-78.2,145.9-145.9c0-2.2,0-4.4-0.1-6.6c10-7.2,18.7-16.3,25.6-26.6
          c-9.2,4.1-19.1,6.8-29.5,8.1c10.6-6.3,18.7-16.4,22.6-28.4c-9.9,5.9-20.9,10.1-32.6,12.4c-9.4-10-22.7-16.2-37.4-16.2
          c-28.3,0-51.3,23-51.3,51.3c0,4,0.5,7.9,1.3,11.7c-42.6-2.1-80.4-22.6-105.7-53.6c-4.4,7.6-6.9,16.4-6.9,25.8
          c0,17.8,9.1,33.5,22.8,42.7c-8.4-0.3-16.3-2.6-23.2-6.4c0,0.2,0,0.4,0,0.7c0,24.8,17.7,45.6,41.1,50.3c-4.3,1.2-8.8,1.8-13.5,1.8
          c-3.3,0-6.5-0.3-9.6-0.9c6.5,20.4,25.5,35.2,47.9,35.6c-17.6,13.8-39.7,22-63.7,22c-4.1,0-8.2-0.2-12.2-0.7
          C97.7,293.1,124.7,301.6,153.6,301.6"/>
        </svg>

      <span class="footer-icons-text">Follow Layer5 on Twitter</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--github" href="https://github.com/layer5io" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M203.9,60c-75.6,0-137,61.3-137,137c0,60.5,39.2,111.9,93.7,130c6.8,1.3,9.3-3,9.3-6.6c0-3.3-0.1-11.9-0.2-23.3
         c-38.1,8.3-46.1-18.4-46.1-18.4c-6.2-15.8-15.2-20-15.2-20c-12.4-8.5,0.9-8.3,0.9-8.3c13.7,1,21,14.1,21,14.1
         c12.2,20.9,32.1,14.9,39.9,11.4c1.2-8.9,4.8-14.9,8.7-18.3c-30.4-3.5-62.4-15.2-62.4-67.7c0-15,5.3-27.2,14.1-36.8
         c-1.4-3.5-6.1-17.4,1.3-36.3c0,0,11.5-3.7,37.7,14c10.9-3,22.6-4.6,34.3-4.6c11.6,0.1,23.4,1.6,34.3,4.6c26.2-17.7,37.6-14,37.6-14
         c7.5,18.9,2.8,32.8,1.4,36.3c8.8,9.6,14.1,21.8,14.1,36.8c0,52.6-32,64.2-62.5,67.6c4.9,4.2,9.3,12.6,9.3,25.4
         c0,18.3-0.2,33.1-0.2,37.6c0,3.7,2.5,7.9,9.4,6.6c54.4-18.2,93.6-69.5,93.6-130C340.9,121.3,279.5,60,203.9,60z"/>
        </svg>

      <span class="footer-icons-text">Contribute to Layer5 projects</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--youtube" href="https://www.youtube.com/playlist?list=PL3A-A6hPO2IMPPqVjuzgqNU5xwnFFn3n0" >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" d="M358.3,119.9c-3.8-14.3-15-25.6-29.2-29.4C303.3,83.6,200,83.6,200,83.6s-103.3,0-129.1,6.9
           c-14.2,3.8-25.4,15.1-29.2,29.4c-6.9,25.9-6.9,80.1-6.9,80.1s0,54.1,6.9,80.1c3.8,14.3,15,25.6,29.2,29.4c25.8,7,129.1,7,129.1,7
           s103.3,0,129.1-7c14.2-3.8,25.4-15.1,29.2-29.4c6.9-25.9,6.9-80.1,6.9-80.1S365.2,145.9,358.3,119.9z"/>
           <polygon fill="#3C494F" points="166.2,249.1 252.6,200 166.2,150.9 "/>
        </svg>
      <span class="footer-icons-text">Watch community meeting recordings</span></a>
    </div>

    <div class="footer-icons">
      <a class="social__link social__link--docker" href="https://hub.docker.com/u/layer5/">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 400 400" width="50px" height="50px">
          <path fill="currentColor" stroke="#FFFFFF" stroke-miterlimit="10" d="M369.8,159.9c-11.4-6.7-26.6-7.5-39.4-3.7c-1.6-13.8-10.6-25.8-21.3-34.3l-4.3-3.5l-3.7,4.3
           c-7.2,8.3-9.3,22.1-8.3,32.7c0.8,7.7,3.2,15.7,8,22.1c-3.7,2.1-7.7,5.1-11.4,6.4c-7.5,2.7-15.7,5.3-23.7,5.3h-17.8v-37.5h-34.6
           V85.1h-39.9v31.9h-66.5v34.6H72.2v37.3H42.4l-0.5,4c-1.3,17,0.8,33.5,8,49.2l2.9,5.9l0.3,0.5c21,35.7,57.8,50.6,97.9,50.6
           c77.7,0,141.9-34.9,171.1-108.1c19.7,1.1,39.9-4.8,49.5-23.7l2.4-4.8L369.8,159.9L369.8,159.9z M112.1,125h26.6v29.3h-26.6V125z
            M147,242.7c0,4.5-3.7,8.3-8.3,8.3s-8.3-3.7-8.3-8.3c0-4.5,3.7-8.3,8.3-8.3C143.3,234.7,147,238.2,147,242.7z M112.1,159.6h26.6
           v29.3h-26.6C112.1,188.9,112.1,159.6,112.1,159.6z M77.5,159.6h29.3v29.3H77.5V159.6z M151.3,293.3c-42.1-0.3-64.7-14.4-83.3-33
           c5.6,0.3,10.9,0.5,15.7,0.5c4.3,0,8.5,0,12.5-0.3c10.4-0.5,19.4-1.9,26.9-4c6.1,14.1,17.3,27.1,37.3,36.7H151.3z M173.4,188.9
           h-29.3v-29.3h29.3V188.9z M173.4,154.3h-29.3V125h29.3V154.3z M208,188.9h-29.3v-29.3H208V188.9z M208,154.3h-29.3V125H208V154.3z
            M208,119.7h-29.3V90.4H208V119.7z M242.6,188.9h-29.3v-29.3h29.3V188.9z M140.9,237.4c-0.5-0.3-1.3-0.5-2.1-0.5
           c-3.2,0-5.9,2.7-5.9,5.9c0,3.2,2.7,5.9,5.9,5.9c3.2,0,5.9-2.7,5.9-5.9c0-0.8-0.3-1.6-0.5-2.1c-0.5,0.8-1.1,1.3-2.1,1.3
           c-1.3,0-2.4-1.1-2.4-2.4C139.8,238.4,140.4,237.6,140.9,237.4z"/>
        </svg>
      <span class="footer-icons-text">Access Docker images for Layer5 projects</span></a>
    </div>
  </div>
    </p>
  <!-- meshery-custom-end -->
      </div>
    </div>
  </div>
</footer>

<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@1/dist/clipboard.min.js"></script>

<script type="text/javascript" src="/v0.4/assets/js/lightbox.js"></script>
<link rel="stylesheet" href="/v0.4/assets/css/lightbox.css">

    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
<script src="/v0.4/assets/js/main.js"></script>

    <script async src='https://www.google-analytics.com/analytics.js'></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-00000000-0', 'auto');
	ga('send', 'pageview');
}
</script>

  </body>
</html>
<script
  src="https://code.jquery.com/jquery-3.3.1.min.js"
  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
  crossorigin="anonymous"></script>

<script>
$(document).ready(function() {

    var toc = $('#TOC');

    // Select each header
    sections = $('.td-content h1');
        $.each(sections, function(idx, v) {
            section = $(v);
            var div_id = $(section).attr('id');
            if(!section.hasClass('noTOC')){
               var div_text = section.text().split('Â¶')[0];
              var parent = $("#" + div_id)
              var content = '<li id="link_' + div_id + '" class="md-nav__item"><a class="md-nav__link" href="#' + div_id + '" title="' + div_text +'">' + div_text +'</a></li>';
              $(toc).append(content);
            }

            // Add section code to subnavigation
            var children = $('<nav class="md-nav"><ul class="md-nav__list"></nav></ul>')
            var contenders = $("#" + div_id).nextUntil("h1");
            $.each(contenders, function(idx, contender){
               if( !$(contender).hasClass("noTOC") && ($(contender).is('h2') || $(contender).is('h3')) ) {
                   var contender_id = $(contender).attr('id');
                   var contender_text = $(contender).text().split('Â¶')[0];
                   var content = '<li class="md-nav__item"><a class="md-nav__link" href="#' + contender_id + '" title="' + contender_text +'">' + contender_text +'</a></li>';
                   children.append(content);
                }
             })
             $("#link_" + div_id).append(children);
        });
    });
</script>