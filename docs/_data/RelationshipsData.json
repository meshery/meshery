[
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Mount",
        "metadataDescription": "A relationship that represents volume mounts between components",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "edge_binding_relationships",
        "selectorsDenyFrom": "{\"kind\": \"Pod\",\n\"model\": \"kubernetes\"}",
        "selectorsDenyTo": "{\"kind\": \"Pod\",\n\"model\": \"kubernetes\"}",
        "selectorsAllwowFrom": "{\"kind\": \"Pod\",\n \"model\": \"kubernetes\",\n   \"match\": {\n     \"self\": [\n       [ \"settings\", \"spec\", \"volumes\", \"_\",           \n         \"persistentVolumeClaim\", \"claimName\" ]],\n      \"PersistentVolumeClaim\": [[\"name\"]]}}",
        "selectorsAllowTo": "{\"kind\": \"PersistentVolume\",\n\"model\": \"kubernetes\",\n  \"match\": {\n    \"self\": [[\"name\"],[\"labels\"]],\n    \"PersistentVolumeClaim\": [\n      [\"settings\", \"spec\", \"volumeName\"],\n      [\"settings\", \"spec\", \"selector\", \"matchLabels\"]]}}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that represents volume mounts between components\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Mount\",\r\"rego_query\": \"edge_binding_relationships\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Pod\",\r \"model\": \"kubernetes\",\r   \"match\": {\r     \"self\": [\r       [ \"settings\", \"spec\", \"volumes\", \"_\",           \r         \"persistentVolumeClaim\", \"claimName\" ]],\r      \"PersistentVolumeClaim\": [[\"name\"]]}}],\r    \"to\": [{\"kind\": \"PersistentVolume\",\r\"model\": \"kubernetes\",\r  \"match\": {\r    \"self\": [[\"name\"],[\"labels\"]],\r    \"PersistentVolumeClaim\": [\r      [\"settings\", \"spec\", \"volumeName\"],\r      [\"settings\", \"spec\", \"selector\", \"matchLabels\"]]}}]\r    },\r  \"deny\": {\r    \"from\": [{\"kind\": \"Pod\",\r\"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"Pod\",\r\"model\": \"kubernetes\"}]\r    }\r  }\r}",
        "VisualizationExample": "gif"
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Network",
        "metadataDescription": "A relationship that defines network edges between components",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "edge_network_relationship",
        "selectorsDenyFrom": "{\"kind\": \"Service\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Ingress\",\n\"model\": \"kubernetes\"}",
        "selectorsDenyTo": "{\"kind\": \"Endpoints\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Pod\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Deployment\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Service\",\n\"model\": \"kubernetes\"}",
        "selectorsAllwowFrom": "{\"kind\": \"Ingress\",\n \"model\": \"kubernetes\"}",
        "selectorsAllowTo": "{\"kind\": \"Endpoints\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Pod\",\n\"model\": \"kubernetes\"},\n{\"kind\": \"Deployment\",\n\"model\": \"kubernetes\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that defines network edges between components\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Network\",\r\"rego_query\": \"edge_network_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Ingress\",\r \"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"Endpoints\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Pod\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Deployment\",\r\"model\": \"kubernetes\"}]\r    },\r  \"deny\": {\r    \"from\": [{\"kind\": \"Service\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Ingress\",\r\"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"Endpoints\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Pod\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Deployment\",\r\"model\": \"kubernetes\"},\r{\"kind\": \"Service\",\r\"model\": \"kubernetes\"}]\r    }\r  }\r}",
        "VisualizationExample": "animated gif"
    },
    {
        "Model": "meshery-shapes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Annotation",
        "metadataDescription": "A relationship that defines annotation edges between components",
        "docs": "",
        "metadataStyles": "\"styles\": {\n  \"lineStyle\": \"solid\",\n  \"lineColor\": \"#00B39F\",\n  \"targetArrowShape\": \"triangle\"\n}",
        "evalPolicy": "",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"*\",\n  \"model\": \"meshery-shapes\"},\n{\"kind\": \"*\",\n  \"model\": \"aws\"},\n{\"kind\": \"*\",\n  \"model\": \"gcp\"},\n{\"kind\": \"*\",\n  \"model\": \"meshery-flowcharts\"}",
        "selectorsAllowTo": "{\"kind\": \"*\",\n  \"model\": \"meshery-shapes\"},\n{ \"kind\": \"*\",\n  \"model\": \"aws\"},\n{\"kind\": \"*\",\n  \"model\": \"gcp\"},\n{\"kind\": \"*\",\n  \"model\": \"meshery-flowcharts\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that defines annotation edges between components\",\r  \"styles\": { \"\"styles\": {\r  \"lineStyle\": \"solid\",\r  \"lineColor\": \"#00B39F\",\r  \"targetArrowShape\": \"triangle\"\r}\",}\r  },\r  \"model\": {\r    \"name\": \"meshery-shapes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Annotation\",\r\"rego_query\": \"\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"*\",\r  \"model\": \"meshery-shapes\"},\r{\"kind\": \"*\",\r  \"model\": \"aws\"},\r{\"kind\": \"*\",\r  \"model\": \"gcp\"},\r{\"kind\": \"*\",\r  \"model\": \"meshery-flowcharts\"}],\r    \"to\": [{\"kind\": \"*\",\r  \"model\": \"meshery-shapes\"},\r{ \"kind\": \"*\",\r  \"model\": \"aws\"},\r{\"kind\": \"*\",\r  \"model\": \"gcp\"},\r{\"kind\": \"*\",\r  \"model\": \"meshery-flowcharts\"}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Permission",
        "metadataDescription": "A relationship that represents a set of permissions",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "edge_binding_relationship",
        "selectorsDenyFrom": "{\"kind\": \"ClusterRole\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"Role\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"ClusterRoleBinding\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"RoleBinding\",\n  \"model\": \"kubernetes\"}",
        "selectorsDenyTo": "{\"kind\": \"ClusterRole\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"Role\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"ClusterRoleBinding\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"RoleBinding\",\n  \"model\": \"kubernetes\"}",
        "selectorsAllwowFrom": "{\"kind\": \"ClusterRole\",\n  \"model\": \"kubernetes\",\n  \"match\": {\n    \"self\": [[\"type\"],\n      [\"name\"]\n    ],\n    \"ClusterRoleBinding\": [\n      [\n        \"settings\",\n        \"roleRef\",\n        \"kind\"\n      ],\n      [\n        \"settings\",\n        \"roleRef\",\n        \"name\"\n      ]\n    ]\n  }\n},\n{\n  \"kind\": \"Role\",\n  \"model\": \"kubernetes\",\n  \"match\": {\n    \"self\": [\n      [\"type\"],\n      [\"name\"]\n    ],\n    \"RoleBinding\": [\n      [\n        \"settings\",\n        \"roleRef\",\n        \"kind\"\n      ],\n      [\n        \"settings\",\n        \"roleRef\",\n        \"name\"\n      ]\n    ]\n  }\n}",
        "selectorsAllowTo": " {\"kind\": \"ServiceAccount\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [\n              [\n                \"name\"\n              ]\n            ],\n            \"ClusterRoleBinding\": [[\n              \"settings\",\n              \"subjects\",\n              \"_\",\n              \"name\"\n            ]]\n          }\n        },\n        {\n          \"kind\": \"ServiceAccount\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [\n              [\n                \"name\"\n              ]\n            ],\n            \"RoleBinding\": [\n              [\n                \"settings\",\n                \"subjects\",\n                \"_\",\n                \"name\"\n              ]\n            ]\n          }}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that represents a set of permissions\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Permission\",\r\"rego_query\": \"edge_binding_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"ClusterRole\",\r  \"model\": \"kubernetes\",\r  \"match\": {\r    \"self\": [[\"type\"],\r      [\"name\"]\r    ],\r    \"ClusterRoleBinding\": [\r      [\r        \"settings\",\r        \"roleRef\",\r        \"kind\"\r      ],\r      [\r        \"settings\",\r        \"roleRef\",\r        \"name\"\r      ]\r    ]\r  }\r},\r{\r  \"kind\": \"Role\",\r  \"model\": \"kubernetes\",\r  \"match\": {\r    \"self\": [\r      [\"type\"],\r      [\"name\"]\r    ],\r    \"RoleBinding\": [\r      [\r        \"settings\",\r        \"roleRef\",\r        \"kind\"\r      ],\r      [\r        \"settings\",\r        \"roleRef\",\r        \"name\"\r      ]\r    ]\r  }\r}],\r    \"to\": [ {\"kind\": \"ServiceAccount\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [\r              [\r                \"name\"\r              ]\r            ],\r            \"ClusterRoleBinding\": [[\r              \"settings\",\r              \"subjects\",\r              \"_\",\r              \"name\"\r            ]]\r          }\r        },\r        {\r          \"kind\": \"ServiceAccount\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [\r              [\r                \"name\"\r              ]\r            ],\r            \"RoleBinding\": [\r              [\r                \"settings\",\r                \"subjects\",\r                \"_\",\r                \"name\"\r              ]\r            ]\r          }}]\r    },\r  \"deny\": {\r    \"from\": [{\"kind\": \"ClusterRole\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"Role\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"ClusterRoleBinding\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"RoleBinding\",\r  \"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"ClusterRole\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"Role\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"ClusterRoleBinding\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"RoleBinding\",\r  \"model\": \"kubernetes\"}]\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Firewall",
        "metadataDescription": "A relationship that represents a set of permissions",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "edge_binding_relationship",
        "selectorsDenyFrom": "{\"kind\": \"ClusterRole\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"Role\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"ClusterRoleBinding\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"RoleBinding\",\n  \"model\": \"kubernetes\"}",
        "selectorsDenyTo": "{\"kind\": \"ClusterRole\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"Role\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"ClusterRoleBinding\",\n  \"model\": \"kubernetes\"},\n{\"kind\": \"RoleBinding\",\n  \"model\": \"kubernetes\"}",
        "selectorsAllwowFrom": "{\"kind\": \"Pod\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [],\n            \"NetworkPolicy\": []\n          }\n        }",
        "selectorsAllowTo": "{\"kind\": \"Pod\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [],\n            \"NetworkPolicy\": []\n          }\n        }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that represents a set of permissions\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Firewall\",\r\"rego_query\": \"edge_binding_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Pod\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [],\r            \"NetworkPolicy\": []\r          }\r        }],\r    \"to\": [{\"kind\": \"Pod\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [],\r            \"NetworkPolicy\": []\r          }\r        }]\r    },\r  \"deny\": {\r    \"from\": [{\"kind\": \"ClusterRole\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"Role\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"ClusterRoleBinding\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"RoleBinding\",\r  \"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"ClusterRole\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"Role\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"ClusterRoleBinding\",\r  \"model\": \"kubernetes\"},\r{\"kind\": \"RoleBinding\",\r  \"model\": \"kubernetes\"}]\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A relationship that provides the ability to assign one or more Envoy WASM Filters to an Istio Proxy along with the filter's specific configuration.",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"WASMFilter\",\n                    \"model\": \"istio-base\",\n                    \"patch\": {\n                        \"patchStrategy\": \"replace\",\n                        \"mutatorRef\": [\n                            [\n                                \"settings\",\n                                \"config\"\n                            ],\n                            [\n                                \"settings\",\n                                \"wasmFilter\"\n                            ]\n                        ],\n                        \"description\": \"WASM filter configuration to be applied to Envoy Filter.\"\n                    }\n                }",
        "selectorsAllowTo": "{\"kind\": \"EnvoyFilter\",\n                    \"model\": \"istio-base\",\n                    \"patch\": {\n                        \"patchStrategy\": \"replace\",\n                        \"mutatedRef\": [\n                            [\n                                \"settings\",\n                                \"spec\",\n                                \"configPatches\",\n                                \"_\",\n                                \"patch\",\n                                \"value\"\n                            ]\n                        ],\n                        \"description\": \"Receive the WASM filter configuration.\"\n                    }\n                },\n                {\n                    \"kind\": \"WasmPlugin\",\n                    \"model\": \"istio-base\",\n                    \"patch\": {\n                        \"patchStrategy\": \"replace\",\n                        \"mutatedRef\": [\n                            [\n                                \"settings\",\n                                \"spec\",\n                                \"pluginConfig\"\n                            ],\n                            [\n                                \"settings\",\n                                \"spec\",\n                                \"url\"\n                            ]\n                        ],\n                        \"description\": \"Receive the WASM filter configuration.\"\n                    }\n                }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A relationship that provides the ability to assign one or more Envoy WASM Filters to an Istio Proxy along with the filter's specific configuration.\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"WASMFilter\",\r                    \"model\": \"istio-base\",\r                    \"patch\": {\r                        \"patchStrategy\": \"replace\",\r                        \"mutatorRef\": [\r                            [\r                                \"settings\",\r                                \"config\"\r                            ],\r                            [\r                                \"settings\",\r                                \"wasmFilter\"\r                            ]\r                        ],\r                        \"description\": \"WASM filter configuration to be applied to Envoy Filter.\"\r                    }\r                }],\r    \"to\": [{\"kind\": \"EnvoyFilter\",\r                    \"model\": \"istio-base\",\r                    \"patch\": {\r                        \"patchStrategy\": \"replace\",\r                        \"mutatedRef\": [\r                            [\r                                \"settings\",\r                                \"spec\",\r                                \"configPatches\",\r                                \"_\",\r                                \"patch\",\r                                \"value\"\r                            ]\r                        ],\r                        \"description\": \"Receive the WASM filter configuration.\"\r                    }\r                },\r                {\r                    \"kind\": \"WasmPlugin\",\r                    \"model\": \"istio-base\",\r                    \"patch\": {\r                        \"patchStrategy\": \"replace\",\r                        \"mutatedRef\": [\r                            [\r                                \"settings\",\r                                \"spec\",\r                                \"pluginConfig\"\r                            ],\r                            [\r                                \"settings\",\r                                \"spec\",\r                                \"url\"\r                            ]\r                        ],\r                        \"description\": \"Receive the WASM filter configuration.\"\r                    }\r                }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Parent",
        "metadataDescription": "A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively\n",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "heirarcal_parent_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Namespace\",\n \"model\": \"kubernetes\"},\n{\"kind\": \"Node\",\n \"model\": \"kubernetes\"}",
        "selectorsAllowTo": "{\"model\": \"*\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively\r\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Parent\",\r\"rego_query\": \"heirarcal_parent_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Namespace\",\r \"model\": \"kubernetes\"},\r{\"kind\": \"Node\",\r \"model\": \"kubernetes\"}],\r    \"to\": [{\"model\": \"*\"}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "meshery-shapes",
        "Version": "v1.0.0",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Parent",
        "metadataDescription": "A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "???",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Section\",\n          \"model\": \"meshery-shapes\"}",
        "selectorsAllowTo": "{\"model\": \"*\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"meshery-shapes\",\r    \"version\": \"v1.0.0\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Parent\",\r\"rego_query\": \"???\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Section\",\r          \"model\": \"meshery-shapes\"}],\r    \"to\": [{\"model\": \"*\"}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Parent",
        "metadataDescription": "A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively\n",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "???",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Environment\",\n \"model\": \"meshery-core\"}",
        "selectorsAllowTo": "{\"model\": \"*\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A relationship that defines whether a component can be a parent of other components. It is read like: `from` can be a parent of `to`, where from and to are any components that match the from and to selectors respectively\r\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Parent\",\r\"rego_query\": \"???\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Environment\",\r \"model\": \"meshery-core\"}],\r    \"to\": [{\"model\": \"*\"}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Sibling",
        "type": "",
        "subType": "MatchLabels",
        "metadataDescription": "A relationship between two objects that are siblings.",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "sibling_matchlabels_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Service\",\n \"model\": \"kubernetes\"}",
        "selectorsAllowTo": "{\"kind\": \"Pod\",\n \"model\": \"kubernetes\"}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Sibling\",\r\"metadata\": {\r  \"description\": \"A relationship between two objects that are siblings.\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"MatchLabels\",\r\"rego_query\": \"sibling_matchlabels_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Service\",\r \"model\": \"kubernetes\"}],\r    \"to\": [{\"kind\": \"Pod\",\r \"model\": \"kubernetes\"}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"ConfigMap\",\n  \"model\": \"kubernetes\",\n  \"patch\": {\n    \"patchStrategy\": \"replace\",\n    \"mutatorRef\": [\n      [\n        \"name\"\n      ]\n    ],\n    \"description\": \"A relationship that assigns configuration data for applications deployed in a cluster.\"\n  }\n}",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\n  \"model\": \"kubernetes\",\n  \"patch\": {\n    \"patchStrategy\": \"replace\",\n    \"mutatedRef\": [\n      [\n        \"spec\",\n        \"spec\",\n        \"containers[0]\",\n        \"envFrom\",\n        \"configMapRef\",\n        \"name\"\n      ]\n    ],\n    \"description\": \"A relationship that assigns configuration data for applications deployed in a cluster.\"\n  }\n}",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"ConfigMap\",\r  \"model\": \"kubernetes\",\r  \"patch\": {\r    \"patchStrategy\": \"replace\",\r    \"mutatorRef\": [\r      [\r        \"name\"\r      ]\r    ],\r    \"description\": \"A relationship that assigns configuration data for applications deployed in a cluster.\"\r  }\r}],\r    \"to\": [{\"kind\": \"Deployment\",\r  \"model\": \"kubernetes\",\r  \"patch\": {\r    \"patchStrategy\": \"replace\",\r    \"mutatedRef\": [\r      [\r        \"spec\",\r        \"spec\",\r        \"containers[0]\",\r        \"envFrom\",\r        \"configMapRef\",\r        \"name\"\r      ]\r    ],\r    \"description\": \"A relationship that assigns configuration data for applications deployed in a cluster.\"\r  }\r}]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Secret\",\n                  \"model\": \"kubernetes\",\n                  \"patch\": {\n                      \"patchStrategy\": \"replace\",\n                      \"mutatorRef\": [\n                          [\n                              \"name\"\n                          ]\n                      ],\n                      \"description\": \"In Kubernetes, Secrets are versatile resources that can be referenced by various other resources to provide configuration data to applications or other Kubernetes resources.\\n\\nBy referencing Secrets in these various contexts, you can centralize and manage configuration data more efficiently, allowing for easier updates, versioning, and maintenance of configurations in a Kubernetes environment.\"\n                  }\n              }",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\n                  \"model\": \"kubernetes\",\n                  \"patch\": {\n                      \"patchStrategy\": \"replace\",\n                      \"mutatedRef\": [\n                          [\n                              \"spec\",\n                              \"containers\",\n                              \"_\",\n                              \"envFrom\",\n                              \"secretRef\",\n                              \"name\"\n                          ]\n                      ],\n                      \"description\": \"Deployments can reference Secrets to inject confidential configuration data into the Pods they manage. This is useful for maintaining consistent configuration across replica sets.\\n\\nThe keys from the Secret will be exposed as environment variables to the containers within the pods managed by the Deployment.\"\n                  }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Secret\",\r                  \"model\": \"kubernetes\",\r                  \"patch\": {\r                      \"patchStrategy\": \"replace\",\r                      \"mutatorRef\": [\r                          [\r                              \"name\"\r                          ]\r                      ],\r                      \"description\": \"In Kubernetes, Secrets are versatile resources that can be referenced by various other resources to provide configuration data to applications or other Kubernetes resources.\\n\\nBy referencing Secrets in these various contexts, you can centralize and manage configuration data more efficiently, allowing for easier updates, versioning, and maintenance of configurations in a Kubernetes environment.\"\r                  }\r              }],\r    \"to\": [{\"kind\": \"Deployment\",\r                  \"model\": \"kubernetes\",\r                  \"patch\": {\r                      \"patchStrategy\": \"replace\",\r                      \"mutatedRef\": [\r                          [\r                              \"spec\",\r                              \"containers\",\r                              \"_\",\r                              \"envFrom\",\r                              \"secretRef\",\r                              \"name\"\r                          ]\r                      ],\r                      \"description\": \"Deployments can reference Secrets to inject confidential configuration data into the Pods they manage. This is useful for maintaining consistent configuration across replica sets.\\n\\nThe keys from the Secret will be exposed as environment variables to the containers within the pods managed by the Deployment.\"\r                  }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Pod\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A Pod \"\n            }\n          },\n          {\n            \"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A Deployment \"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A StatefulSet \"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A ReplicaSet \"\n            }\n          },\n          {\n            \"kind\": \"Service\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A Service \"\n            }\n          },\n          {\n            \"kind\": \"ConfigMap\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A ConfigMap \"\n            }\n          },\n          {\n            \"kind\": \"Secret\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"],\n                [\"namespace\"],\n                [\"kind\"],\n                [\"apiVersion\"]\n              ],\n              \"description\": \"A Secret \"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Event\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"metadata\", \"name\"],\n                [\"settings\", \"metadata\", \"namespace\"],\n                [\"settings\", \"metadata\", \"kind\"],\n                [\"settings\", \"metadata\", \"apiVersion\"]\n              ],\n              \"description\": \"An Event \"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Pod\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A Pod \"\r            }\r          },\r          {\r            \"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A Deployment \"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A StatefulSet \"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A ReplicaSet \"\r            }\r          },\r          {\r            \"kind\": \"Service\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A Service \"\r            }\r          },\r          {\r            \"kind\": \"ConfigMap\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A ConfigMap \"\r            }\r          },\r          {\r            \"kind\": \"Secret\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"],\r                [\"namespace\"],\r                [\"kind\"],\r                [\"apiVersion\"]\r              ],\r              \"description\": \"A Secret \"\r            }\r          }],\r    \"to\": [{\"kind\": \"Event\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"metadata\", \"name\"],\r                [\"settings\", \"metadata\", \"namespace\"],\r                [\"settings\", \"metadata\", \"kind\"],\r                [\"settings\", \"metadata\", \"apiVersion\"]\r              ],\r              \"description\": \"An Event \"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": " {\"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"apiVersion\"], \n                [\"name\"], \n                [\"type\"]\n              ],\n              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for Deployments.\"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"apiVersion\"], \n                [\"name\"], \n                [\"type\"]\n              ],\n              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for StatefulSet.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"apiVersion\"], \n                [\"name\"], \n                [\"type\"]\n              ],\n              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for ReplicaSet.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"HorizontalPodAutoscaler\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\", \"scaleTargetRef\", \"apiVersion\"], \n                [\"settings\", \"spec\", \"scaleTargetRef\", \"name\"], \n                [\"settings\", \"spec\", \"scaleTargetRef\", \"kind\"]\n              ],\n              \"description\": \"Horizontal Pod Autoscaler automatically scales the number of pods in a replication controller, deployment, replica set or stateful set based on observed CPU utilization (or, with custom metrics support, on some other application-provided metrics). Horizontal Pod Autoscaling does not apply to objects that can't be scaled, for example, DaemonSets.\"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [ {\"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"apiVersion\"], \r                [\"name\"], \r                [\"type\"]\r              ],\r              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for Deployments.\"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"apiVersion\"], \r                [\"name\"], \r                [\"type\"]\r              ],\r              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for StatefulSet.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"apiVersion\"], \r                [\"name\"], \r                [\"type\"]\r              ],\r              \"description\": \"Allow Horizontal Pod Autoscaler to scale based on observed metrics for ReplicaSet.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"HorizontalPodAutoscaler\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\", \"scaleTargetRef\", \"apiVersion\"], \r                [\"settings\", \"spec\", \"scaleTargetRef\", \"name\"], \r                [\"settings\", \"spec\", \"scaleTargetRef\", \"kind\"]\r              ],\r              \"description\": \"Horizontal Pod Autoscaler automatically scales the number of pods in a replication controller, deployment, replica set or stateful set based on observed CPU utilization (or, with custom metrics support, on some other application-provided metrics). Horizontal Pod Autoscaling does not apply to objects that can't be scaled, for example, DaemonSets.\"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"LimitRange\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"spec\", \"limits\", \"_\", \"default\", \"memory\"],\n                [\"spec\", \"limits\", \"_\", \"default\", \"cpu\"],\n                [\"spec\", \"limits\", \"defaultRequest\", \"memory\"],\n                [\"spec\", \"limits\", \"defaultRequest\", \"cpu\"]\n              ],\n              \"description\": \"Define default memory and CPU limits (including defaultRequest) in LimitRange.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Pod\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"containers\", \"resources\", \"resources\", \"limits\", \"memory\"],\n                [\"settings\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n                [\"settings\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n                [\"settings\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Pod containers.\"\n            }\n          },\n          {\n            \"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Deployment containers.\"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to StatefulSet containers.\"\n            }\n          },\n          {\n            \"kind\": \"DaemonSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to DaemonSet containers.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to ReplicaSet containers.\"\n            }\n          },\n          {\n            \"kind\": \"Job\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Job containers.\"\n            }\n          },\n          {\n            \"kind\": \"CronJob\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\n              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\n              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to CronJob containers.\"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"LimitRange\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"spec\", \"limits\", \"_\", \"default\", \"memory\"],\r                [\"spec\", \"limits\", \"_\", \"default\", \"cpu\"],\r                [\"spec\", \"limits\", \"defaultRequest\", \"memory\"],\r                [\"spec\", \"limits\", \"defaultRequest\", \"cpu\"]\r              ],\r              \"description\": \"Define default memory and CPU limits (including defaultRequest) in LimitRange.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Pod\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"containers\", \"resources\", \"resources\", \"limits\", \"memory\"],\r                [\"settings\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r                [\"settings\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r                [\"settings\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Pod containers.\"\r            }\r          },\r          {\r            \"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r                [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Deployment containers.\"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to StatefulSet containers.\"\r            }\r          },\r          {\r            \"kind\": \"DaemonSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to DaemonSet containers.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to ReplicaSet containers.\"\r            }\r          },\r          {\r            \"kind\": \"Job\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to Job containers.\"\r            }\r          },\r          {\r            \"kind\": \"CronJob\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [[\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"limits\", \"cpu\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"memory\"],\r              [\"settings\", \"spec\", \"template\", \"spec\", \"containers\", \"resources\", \"requests\", \"cpu\"]],\r              \"description\": \"Apply the default and defaultRequest memory and CPU limits from LimitRange to CronJob containers.\"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"CSIDriver\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are responsible for the actual operations of a CSI volume. They are responsible for communicating with the external storage provider and exposing the volume to the kubelet.\\n\\nCSI drivers are installed on the cluster as a CustomResourceDefinition (CRD) and a DaemonSet. The CRD is used to create a CSIDriver object, which is used to configure the CSI driver. The DaemonSet is used to deploy the CSI driver to each node in the cluster.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Pod\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\":\"Deployment\",\n            \"model\":\"kubernetes\",\n            \"patch\":{\n              \"patchStrategy\":\"replace\",\n              \"mutatedRef\":[\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\":\"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\": \"DaemonSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\", \n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\":\"CronJob\",\n            \"model\":\"kubernetes\",\n            \"patch\":{\n              \"patchStrategy\":\"replace\",\n              \"mutatedRef\":[\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"jobTemplate\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\":\"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          },\n          {\n            \"kind\": \"Job\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"template\",\n                  \"spec\",\n                  \"volumes\",\n                  \"_\",\n                  \"csi\",\n                  \"driver\",\n                  \"name\"\n                ]\n              ],\n              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"CSIDriver\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are responsible for the actual operations of a CSI volume. They are responsible for communicating with the external storage provider and exposing the volume to the kubelet.\\n\\nCSI drivers are installed on the cluster as a CustomResourceDefinition (CRD) and a DaemonSet. The CRD is used to create a CSIDriver object, which is used to configure the CSI driver. The DaemonSet is used to deploy the CSI driver to each node in the cluster.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Pod\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\":\"Deployment\",\r            \"model\":\"kubernetes\",\r            \"patch\":{\r              \"patchStrategy\":\"replace\",\r              \"mutatedRef\":[\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\":\"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\": \"DaemonSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\", \r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\":\"CronJob\",\r            \"model\":\"kubernetes\",\r            \"patch\":{\r              \"patchStrategy\":\"replace\",\r              \"mutatedRef\":[\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"jobTemplate\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\":\"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          },\r          {\r            \"kind\": \"Job\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"template\",\r                  \"spec\",\r                  \"volumes\",\r                  \"_\",\r                  \"csi\",\r                  \"driver\",\r                  \"name\"\r                ]\r              ],\r              \"description\": \"CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\\n\\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation.\"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Deployment\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"],\r\n                [\"kind\"],\r\n                [\"apiVersion\"]\r\n              ],\r\n              \"description\": \"A Deployment \"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"StatefulSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"],\r\n                [\"kind\"],\r\n                [\"apiVersion\"]\r\n              ],\r\n              \"description\": \"A StatefulSet \"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"DaemonSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"],\r\n                [\"kind\"],\r\n                [\"apiVersion\"]\r\n              ],\r\n              \"description\": \"A DaemonSet \"\r\n            }\r\n          }",
        "selectorsAllowTo": "{\"kind\": \"lease\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"metadata\", \"ownerReferences\", \"-\", \"name\"],\n                [\"metadata\", \"ownerReferences\", \"-\", \"kind\"],\n                [\"metadata\", \"ownerReferences\", \"-\", \"apiVersion\"]\n              ],\n              \"description\": \"A Lease is a mechanism used for coordinating activities between multiple instances of a controller, ensuring that only one instance is actively performing certain tasks at any given time.\"\n            }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Deployment\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"],\r\r                [\"kind\"],\r\r                [\"apiVersion\"]\r\r              ],\r\r              \"description\": \"A Deployment \"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"StatefulSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"],\r\r                [\"kind\"],\r\r                [\"apiVersion\"]\r\r              ],\r\r              \"description\": \"A StatefulSet \"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"DaemonSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"],\r\r                [\"kind\"],\r\r                [\"apiVersion\"]\r\r              ],\r\r              \"description\": \"A DaemonSet \"\r\r            }\r\r          }],\r    \"to\": [{\"kind\": \"lease\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"metadata\", \"ownerReferences\", \"-\", \"name\"],\r                [\"metadata\", \"ownerReferences\", \"-\", \"kind\"],\r                [\"metadata\", \"ownerReferences\", \"-\", \"apiVersion\"]\r              ],\r              \"description\": \"A Lease is a mechanism used for coordinating activities between multiple instances of a controller, ensuring that only one instance is actively performing certain tasks at any given time.\"\r            }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Edge",
        "type": "",
        "subType": "Mount",
        "metadataDescription": "A relationship that represents volume mounts between components",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "edge_binding_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Pod\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [\n              [\n                \"settings\",\n                \"spec\",\n                \"volumes\",\n                \"_\",\n                \"persistentVolumeClaim\",\n                \"claimName\"\n              ]\n            ],\n            \"PersistentVolumeClaim\": [\n              [\n                \"name\"\n              ]\n            ]\n          }\n        }",
        "selectorsAllowTo": "{\"kind\": \"PersistentVolume\",\n          \"model\": \"kubernetes\",\n          \"match\": {\n            \"self\": [\n              [\n                \"name\"\n              ],\n              [\n                \"labels\"\n              ]\n            ],\n            \"PersistentVolumeClaim\": [\n              [\n                \"settings\",\n                \"spec\",\n                \"volumeName\"\n              ],\n              [\n                \"settings\",\n                \"spec\",\n                \"selector\",\n                \"matchLabels\"\n              ]\n            ]\n          }\n        }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Edge\",\r\"metadata\": {\r  \"description\": \"A relationship that represents volume mounts between components\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Mount\",\r\"rego_query\": \"edge_binding_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Pod\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [\r              [\r                \"settings\",\r                \"spec\",\r                \"volumes\",\r                \"_\",\r                \"persistentVolumeClaim\",\r                \"claimName\"\r              ]\r            ],\r            \"PersistentVolumeClaim\": [\r              [\r                \"name\"\r              ]\r            ]\r          }\r        }],\r    \"to\": [{\"kind\": \"PersistentVolume\",\r          \"model\": \"kubernetes\",\r          \"match\": {\r            \"self\": [\r              [\r                \"name\"\r              ],\r              [\r                \"labels\"\r              ]\r            ],\r            \"PersistentVolumeClaim\": [\r              [\r                \"settings\",\r                \"spec\",\r                \"volumeName\"\r              ],\r              [\r                \"settings\",\r                \"spec\",\r                \"selector\",\r                \"matchLabels\"\r              ]\r            ]\r          }\r        }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"PodTemplate\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"template\"]\n              ],\n              \"description\": \"A Pod template is a blueprint defining the configuration for creating Kubernetes pods, encapsulating specifications for containers, volumes, and other settings\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\"]\r\n              ],\r\n              \"description\": \"A Deployment \"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"StatefulSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\"]\r\n              ],\r\n              \"description\": \"A StatefulSet \"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"DaemonSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\"]\r\n              ],\r\n              \"description\": \"A DaemonSet \"\r\n            }\r\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"PodTemplate\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"template\"]\r              ],\r              \"description\": \"A Pod template is a blueprint defining the configuration for creating Kubernetes pods, encapsulating specifications for containers, volumes, and other settings\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Deployment\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\"]\r\r              ],\r\r              \"description\": \"A Deployment \"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"StatefulSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\"]\r\r              ],\r\r              \"description\": \"A StatefulSet \"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"DaemonSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\"]\r\r              ],\r\r              \"description\": \"A DaemonSet \"\r\r            }\r\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\n              ], \n              \"description\": \" Deployments manage ReplicaSets and provide features such as rolling updates and rollback functionality. PDBs can be associated with Deployments to maintain availability during updates and ensure a minimum number of pods are available during the transition.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\n              ],\n              \"description\": \"ReplicaSets ensure a specified number of pod replicas are running at any given time. PDBs can be applied to ReplicaSets to enforce constraints on how many pods can be disrupted at once during scaling operations or node maintenance.\"\n            }\n          }, \n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\n              ],\n              \"description\": \"StatefulSets are used for stateful applications that require stable, unique network identifiers and persistent storage. PDBs can be used with StatefulSets to control pod disruptions and ensure data integrity during maintenance or scaling.\"\n            }\n          }, \n          {\n            \"kind\": \"DaemonSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\n              ],\n              \"description\": \"DaemonSets ensure that a copy of a pod runs on each node in the cluster. PDBs can be used to prevent too many pods from being disrupted simultaneously during node maintenance or upgrades, ensuring that essential services provided by DaemonSets remain available.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"PodDisruptionBudget\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\n              ]\n            },\n            \"description\": \"In Kubernetes, Pod Distribution Budgets (PDBs) are used to ensure that a certain number or percentage of pods are running on particular nodes or within particular zones.\"\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\r              ], \r              \"description\": \" Deployments manage ReplicaSets and provide features such as rolling updates and rollback functionality. PDBs can be associated with Deployments to maintain availability during updates and ensure a minimum number of pods are available during the transition.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\r              ],\r              \"description\": \"ReplicaSets ensure a specified number of pod replicas are running at any given time. PDBs can be applied to ReplicaSets to enforce constraints on how many pods can be disrupted at once during scaling operations or node maintenance.\"\r            }\r          }, \r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\r              ],\r              \"description\": \"StatefulSets are used for stateful applications that require stable, unique network identifiers and persistent storage. PDBs can be used with StatefulSets to control pod disruptions and ensure data integrity during maintenance or scaling.\"\r            }\r          }, \r          {\r            \"kind\": \"DaemonSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\r              ],\r              \"description\": \"DaemonSets ensure that a copy of a pod runs on each node in the cluster. PDBs can be used to prevent too many pods from being disrupted simultaneously during node maintenance or upgrades, ensuring that essential services provided by DaemonSets remain available.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"PodDisruptionBudget\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\", \"selector\", \"matchLabels\"]\r              ]\r            },\r            \"description\": \"In Kubernetes, Pod Distribution Budgets (PDBs) are used to ensure that a certain number or percentage of pods are running on particular nodes or within particular zones.\"\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"ReplicationController\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"settings\", \"spec\"]\n              ],\n              \"description\": \"In Kubernetes, Replication Controllers  are used to ensure that a specified number of pod replicas are running at any given time.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\"]\n              ],\n              \"description\": \"A Deployment manages a set of identical Pods, often referred to as a ReplicaSet. Replication Controller provides declarative updates to applications, managing the deployment and scaling of Pods.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\"]\n              ],\n              \"description\": \"ReplicaSet use Replication Controllers internally to manage the desired number of replicas. Replication Controllers ensure that if a Pod fails or is deleted, a new Pod is created to maintain the desired number of replicas. \"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\"]\n              ],\n              \"description\": \"A StatefulSet manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. StatefulSets are used for stateful applications, such as databases.\"\n            }\n          },\n          {\n            \"kind\": \"DaemonSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\"]\n              ],\n              \"description\": \"A DaemonSet ensures that all (or some) nodes run a copy of a Pod. It's typically used for running system daemons or agents on every node in a Kubernetes cluster.\"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"ReplicationController\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"settings\", \"spec\"]\r              ],\r              \"description\": \"In Kubernetes, Replication Controllers  are used to ensure that a specified number of pod replicas are running at any given time.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\"]\r              ],\r              \"description\": \"A Deployment manages a set of identical Pods, often referred to as a ReplicaSet. Replication Controller provides declarative updates to applications, managing the deployment and scaling of Pods.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\"]\r              ],\r              \"description\": \"ReplicaSet use Replication Controllers internally to manage the desired number of replicas. Replication Controllers ensure that if a Pod fails or is deleted, a new Pod is created to maintain the desired number of replicas. \"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\"]\r              ],\r              \"description\": \"A StatefulSet manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. StatefulSets are used for stateful applications, such as databases.\"\r            }\r          },\r          {\r            \"kind\": \"DaemonSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\"]\r              ],\r              \"description\": \"A DaemonSet ensures that all (or some) nodes run a copy of a Pod. It's typically used for running system daemons or agents on every node in a Kubernetes cluster.\"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"ControllerRevision\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\n                  \"settings\", \"revision\"\n                ]\n              ],\n              \"description\": \"ControllerRevisions are used to store the historical state of a ReplicaSet, Deployment, StatefulSet or Pod. They are used to rollback to a previous version of the resource.\\n\\nControllerRevisions are created when a ReplicaSet, Deployment, or StatefulSet is updated. They store the historical state of the resource, including the Pod template and the revision number.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"revisionHistoryLimit\"\n                ]\n              ],\n              \"description\": \"Deployments can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Deployment.\\n\\nThe revisionHistoryLimit field in the Deployment specification is used to configure the number of ControllerRevisions to store.\"\n            }\n          },\n          {\n            \"kind\": \"StatefulSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"revisionHistoryLimit\"\n                ]\n              ],\n              \"description\": \"StatefulSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the StatefulSet.\\n\\nThe revisionHistoryLimit field in the StatefulSet specification is used to configure the number of ControllerRevisions to store.\"\n            }\n          },\n          {\n            \"kind\": \"ReplicaSet\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"spec\",\n                  \"revisionHistoryLimit\"\n                ]\n              ],\n              \"description\": \"ReplicaSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the ReplicaSet.\\n\\nThe revisionHistoryLimit field in the ReplicaSet specification is used to configure the number of ControllerRevisions to store.\"\n            }\n          },\n          {\n            \"kind\": \"Pod\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\n                  \"settings\",\n                  \"metadata\",\n                  \"ownerReferences\",\n                  \"_\",\n                  \"controller\",\n                  \"revisionHistoryLimit\"\n                ]\n              ],\n              \"description\": \"Pods can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Pod.\\n\\nThe revisionHistoryLimit field in the Pod specification is used to configure the number of ControllerRevisions to store.\"\n            }\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"ControllerRevision\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\r                  \"settings\", \"revision\"\r                ]\r              ],\r              \"description\": \"ControllerRevisions are used to store the historical state of a ReplicaSet, Deployment, StatefulSet or Pod. They are used to rollback to a previous version of the resource.\\n\\nControllerRevisions are created when a ReplicaSet, Deployment, or StatefulSet is updated. They store the historical state of the resource, including the Pod template and the revision number.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Deployment\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"revisionHistoryLimit\"\r                ]\r              ],\r              \"description\": \"Deployments can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Deployment.\\n\\nThe revisionHistoryLimit field in the Deployment specification is used to configure the number of ControllerRevisions to store.\"\r            }\r          },\r          {\r            \"kind\": \"StatefulSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"revisionHistoryLimit\"\r                ]\r              ],\r              \"description\": \"StatefulSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the StatefulSet.\\n\\nThe revisionHistoryLimit field in the StatefulSet specification is used to configure the number of ControllerRevisions to store.\"\r            }\r          },\r          {\r            \"kind\": \"ReplicaSet\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"spec\",\r                  \"revisionHistoryLimit\"\r                ]\r              ],\r              \"description\": \"ReplicaSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the ReplicaSet.\\n\\nThe revisionHistoryLimit field in the ReplicaSet specification is used to configure the number of ControllerRevisions to store.\"\r            }\r          },\r          {\r            \"kind\": \"Pod\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\r                  \"settings\",\r                  \"metadata\",\r                  \"ownerReferences\",\r                  \"_\",\r                  \"controller\",\r                  \"revisionHistoryLimit\"\r                ]\r              ],\r              \"description\": \"Pods can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Pod.\\n\\nThe revisionHistoryLimit field in the Pod specification is used to configure the number of ControllerRevisions to store.\"\r            }\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"Pod\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\":[\r\n                [\"settings\", \"spec\"]\r\n              ],\r\n              \"description\": \"A Pod is the basic execution unit of a Kubernetes application, representing a single instance of a running process in a cluster.\"\r\n            }\r\n          }",
        "selectorsAllowTo": "{\"kind\": \"Deployment\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\"]\r\n              ],\r\n              \"description\": \"Deployments use pods to define the desired state of applications. Whenever a Pod is dragged near to the deployment, the pod spcifecation becomes part of the deployment.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"StatefulSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\"]\r\n              ],\r\n              \"description\": \"StatefulSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the StatefulSet, the pod spcifecation becomes part of the StatefulSet.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"DaemonSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\"]\r\n              ],\r\n              \"description\": \"DaemonSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the DaemonSet, the pod spcifecation becomes part of the DaemonSet.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"ReplicaSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\"]\r\n              ],\r\n              \"description\": \"ReplicaSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the ReplicaSet, the pod spcifecation becomes part of the ReplicaSet.\"\r\n            }\r\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"Pod\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\":[\r\r                [\"settings\", \"spec\"]\r\r              ],\r\r              \"description\": \"A Pod is the basic execution unit of a Kubernetes application, representing a single instance of a running process in a cluster.\"\r\r            }\r\r          }],\r    \"to\": [{\"kind\": \"Deployment\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\"]\r\r              ],\r\r              \"description\": \"Deployments use pods to define the desired state of applications. Whenever a Pod is dragged near to the deployment, the pod spcifecation becomes part of the deployment.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"StatefulSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\"]\r\r              ],\r\r              \"description\": \"StatefulSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the StatefulSet, the pod spcifecation becomes part of the StatefulSet.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"DaemonSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\"]\r\r              ],\r\r              \"description\": \"DaemonSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the DaemonSet, the pod spcifecation becomes part of the DaemonSet.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"ReplicaSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\"]\r\r              ],\r\r              \"description\": \"ReplicaSets use pods to define the desired state of applications. Whenever a Pod is dragged near to the ReplicaSet, the pod spcifecation becomes part of the ReplicaSet.\"\r\r            }\r\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"IngressClass\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatorRef\": [\n                [\"name\"]\n              ],\n              \"description\": \"IngressClass is a resource to provide default class for Ingress. It is used to configure the class of the Ingress controller.\"\n            }\n          }",
        "selectorsAllowTo": "{\"kind\": \"Ingress\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"ingressClassName\"]\r\n              ],\r\n              \"description\": \"Ingress is a collection of rules that allow inbound connections to reach the services. It is used to configure the class of the Ingress controller.\"\r\n            }\r\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"IngressClass\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatorRef\": [\r                [\"name\"]\r              ],\r              \"description\": \"IngressClass is a resource to provide default class for Ingress. It is used to configure the class of the Ingress controller.\"\r            }\r          }],\r    \"to\": [{\"kind\": \"Ingress\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"ingressClassName\"]\r\r              ],\r\r              \"description\": \"Ingress is a collection of rules that allow inbound connections to reach the services. It is used to configure the class of the Ingress controller.\"\r\r            }\r\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"StorageClass\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"]\r\n              ],\r\n              \"description\": \"A StorageClass in Kubernetes defines the type and properties of storage that can be dynamically provisioned for persistent volumes.\"\r\n            }\r\n          }",
        "selectorsAllowTo": "{\"kind\": \"PersistentVolumeClaim\",\n            \"model\": \"kubernetes\",\n            \"patch\": {\n              \"patchStrategy\": \"replace\",\n              \"mutatedRef\": [\n                [\"settings\", \"spec\", \"storageClassName\"]\n              ],\n              \"description\": \"A PersistentVolumeClaim in Kubernetes requests storage from a StorageClass, defining the requirements for dynamically provisioned volumes.\"\n            }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"StorageClass\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"]\r\r              ],\r\r              \"description\": \"A StorageClass in Kubernetes defines the type and properties of storage that can be dynamically provisioned for persistent volumes.\"\r\r            }\r\r          }],\r    \"to\": [{\"kind\": \"PersistentVolumeClaim\",\r            \"model\": \"kubernetes\",\r            \"patch\": {\r              \"patchStrategy\": \"replace\",\r              \"mutatedRef\": [\r                [\"settings\", \"spec\", \"storageClassName\"]\r              ],\r              \"description\": \"A PersistentVolumeClaim in Kubernetes requests storage from a StorageClass, defining the requirements for dynamically provisioned volumes.\"\r            }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"PersistentVolume\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"]\r\n              ],\r\n              \"description\": \"PersistentVolume in Kubernetes provides durable storage for Pods, ensuring data persistence across Pod restarts and rescheduling.\"\r\n            }\r\n          }",
        "selectorsAllowTo": "{\"kind\": \"VolumeAttachment\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"source\", \"persistentVolumeName\"]\r\n              ],\r\n              \"description\": \"VolumeAttachment in Kubernetes facilitates the attachment of a PersistentVolume to a node, enabling its utilization by Pods on that node.\"\r\n            }\r\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"PersistentVolume\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"]\r\r              ],\r\r              \"description\": \"PersistentVolume in Kubernetes provides durable storage for Pods, ensuring data persistence across Pod restarts and rescheduling.\"\r\r            }\r\r          }],\r    \"to\": [{\"kind\": \"VolumeAttachment\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"source\", \"persistentVolumeName\"]\r\r              ],\r\r              \"description\": \"VolumeAttachment in Kubernetes facilitates the attachment of a PersistentVolume to a node, enabling its utilization by Pods on that node.\"\r\r            }\r\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    },
    {
        "Model": "kubernetes",
        "Version": "v1.25.2",
        "kind": "Hierarchical",
        "type": "",
        "subType": "Inventory",
        "metadataDescription": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"",
        "docs": "",
        "metadataStyles": "",
        "evalPolicy": "hierarchical_inventory_relationship",
        "selectorsDenyFrom": "",
        "selectorsDenyTo": "",
        "selectorsAllwowFrom": "{\"kind\": \"RuntimeClass\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatorRef\": [\r\n                [\"name\"]\r\n              ],\r\n              \"description\": \"RuntimeClass in Kubernetes is used to specify the runtime that should be used to run a Pod. RuntimeClass is used to select the container runtime and configure the runtime behavior of the Pod.\"\r\n            }\r\n          }",
        "selectorsAllowTo": "{\"kind\": \"Pod\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"Pods in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pod.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"PodTemplate\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"PodTemplates in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created from the PodTemplate.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"Deployment\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"Deployments in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the Deployment.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"StatefulSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"StatefulSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the StatefulSet.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"DaemonSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"DaemonSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the DaemonSet.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"ReplicaSet\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"ReplicaSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the ReplicaSet.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"Job\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"Jobs in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the Job.\"\r\n            }\r\n          },\r\n          {\r\n            \"kind\": \"CronJob\",\r\n            \"model\": \"kubernetes\",\r\n            \"patch\": {\r\n              \"patchStrategy\": \"replace\",\r\n              \"mutatedRef\": [\r\n                [\"settings\", \"spec\", \"jobTemplate\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\n              ],\r\n              \"description\": \"CronJobs in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the CronJob.\"\r\n            }\r\n          }",
        "CompleteDefinition": "{\"apiVersion\": \"core.meshery.io/v1alpha1\",\r\"kind\":\"Hierarchical\",\r\"metadata\": {\r  \"description\": \"A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component.\"\",\r  \"styles\": { \"\",}\r  },\r  \"model\": {\r    \"name\": \"kubernetes\",\r    \"version\": \"v1.25.2\",\r    \"category\": {\r      \"name\": \"Orchestration \\u0026 Management\",\r      \"metadata\": null\r    },\r    \"metadata\": {}\r},\r\"subType\": \"Inventory\",\r\"rego_query\": \"hierarchical_inventory_relationship\",\r\"selectors\": {\r  \"allow\": {\r    \"from\": [{\"kind\": \"RuntimeClass\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatorRef\": [\r\r                [\"name\"]\r\r              ],\r\r              \"description\": \"RuntimeClass in Kubernetes is used to specify the runtime that should be used to run a Pod. RuntimeClass is used to select the container runtime and configure the runtime behavior of the Pod.\"\r\r            }\r\r          }],\r    \"to\": [{\"kind\": \"Pod\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"Pods in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pod.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"PodTemplate\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"PodTemplates in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created from the PodTemplate.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"Deployment\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"Deployments in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the Deployment.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"StatefulSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"StatefulSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the StatefulSet.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"DaemonSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"DaemonSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the DaemonSet.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"ReplicaSet\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"ReplicaSets in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the ReplicaSet.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"Job\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"Jobs in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the Job.\"\r\r            }\r\r          },\r\r          {\r\r            \"kind\": \"CronJob\",\r\r            \"model\": \"kubernetes\",\r\r            \"patch\": {\r\r              \"patchStrategy\": \"replace\",\r\r              \"mutatedRef\": [\r\r                [\"settings\", \"spec\", \"jobTemplate\", \"spec\", \"template\", \"spec\", \"runtimeClassName\"]\r\r              ],\r\r              \"description\": \"CronJobs in Kubernetes can specify the RuntimeClass to select the container runtime and configure the runtime behavior of the Pods created by the CronJob.\"\r\r            }\r\r          }]\r    },\r  \"deny\": {\r    \"from\": [],\r    \"to\": []\r    }\r  }\r}",
        "VisualizationExample": ""
    }
]