{
  "id": "00000000-0000-0000-0000-000000000000",
  "schemaVersion": "components.meshery.io/v1beta1",
  "version": "v1.0.0",
  "displayName": "Virtual Server Route",
  "description": "",
  "format": "JSON",
  "model": {
    "id": "00000000-0000-0000-0000-000000000000",
    "schemaVersion": "models.meshery.io/v1beta1",
    "version": "v1.0.0",
    "name": "nginx-ingress",
    "displayName": "NGINX Ingress Controller",
    "status": "enabled",
    "registrant": {
      "id": "00000000-0000-0000-0000-000000000000",
      "name": "Artifact Hub",
      "type": "registry",
      "sub_type": "",
      "kind": "artifacthub",
      "status": "discovered",
      "created_at": "0001-01-01T00:00:00Z",
      "updated_at": "0001-01-01T00:00:00Z",
      "deleted_at": null,
      "schemaVersion": ""
    },
    "connection_id": "00000000-0000-0000-0000-000000000000",
    "category": {
      "id": "00000000-0000-0000-0000-000000000000",
      "name": "Cloud Native Network"
    },
    "subCategory": "Service Proxy",
    "metadata": {
      "isAnnotation": false,
      "primaryColor": "#009639",
      "secondaryColor": "#42C473",
      "shape": "circle",
      "source_uri": "https://helm.nginx.com/stable/nginx-ingress-2.3.0.tgz",
      "styleOverrides": "",
      "svgColor": "\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 333334 71436\" shape-rendering=\"geometricPrecision\" text-rendering=\"geometricPrecision\" image-rendering=\"optimizeQuality\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M62460 69726c-1883 0-3736-733-5122-2120L14483 24747v37738c0 4001-3242 7242-7242 7242-3998 0-7242-3242-7242-7242V7263c0-2931 1767-5570 4472-6691C5349 207 6292 19 7244 19c1920 0 3762 765 5118 2123l42855 42859V7263c0-4001 3242-7242 7242-7242 4001 0 7242 3242 7242 7242v55222c-2 3998-3244 7240-7242 7242M95994 91l-1990 3714-15390 27970-1990 3532 1990 3528 15391 27067 2079 3710h40284l1990-4072 11496-23174 5159-10500h-11676l-29419 90c-3826-52-7346 3415-7346 7242 0 3826 3520 7296 7346 7242l17742-90-4344 8780h-22812L93186 35215l11407-20639h24265l5657 11609h14576l-9187-22017-1993-4076H95994m73363-90c-3795 46-7201 3540-7152 7332v18872h14483V7334c46-3854-3482-7381-7332-7332m23214 69865c-3997-2-7239-3245-7239-7242V7403c0-4000 3242-7241 7242-7241 4001 0 7242 3241 7242 7242v37737l42856-42859c2704 1122 4469 3763 4469 6691v55224c0 3999-3242 7241-7242 7241-4001 0-7242-3242-7242-7242V24888l-42856 42859c-1356 1357-3197 2120-5116 2120h-5m123995-34908l22528-22445c2833-2821 2841-7407 17-10243-2821-2833-7404-2839-10239-18l-22562 22484-22562-22484c-2836-2824-7419-2815-10239 18-2824 2835-2816 7422 15 10243l22527 22446-22461 22382c-2836 2825-2842 7407-18 10240 1352 1364 3195 2132 5117 2132h13c1848 0 3696-704 5109-2114l22499-22417 22496 22417c1352 1353 3190 2114 5104 2114h9c1859 0 3714-709 5130-2132 2821-2833 2815-7415-18-10239l-22463-22383M169359 69662c-3795-46-7201-3539-7152-7331V32017h14483v30314c46 3850-3482 7377-7332 7331z\" fill=\"#090\"\u003e\u003c/path\u003e\u003c/svg\u003e",
      "svgComplete": "",
      "svgWhite": "\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 333334 71436\" shape-rendering=\"geometricPrecision\" text-rendering=\"geometricPrecision\" image-rendering=\"optimizeQuality\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M62460 69726c-1883 0-3736-733-5122-2120L14483 24747v37738c0 4001-3242 7242-7242 7242-3998 0-7242-3242-7242-7242V7263c0-2931 1767-5570 4472-6691C5349 207 6292 19 7244 19c1920 0 3762 765 5118 2123l42855 42859V7263c0-4001 3242-7242 7242-7242 4001 0 7242 3242 7242 7242v55222c-2 3998-3244 7240-7242 7242M95994 91l-1990 3714-15390 27970-1990 3532 1990 3528 15391 27067 2079 3710h40284l1990-4072 11496-23174 5159-10500h-11676l-29419 90c-3826-52-7346 3415-7346 7242 0 3826 3520 7296 7346 7242l17742-90-4344 8780h-22812L93186 35215l11407-20639h24265l5657 11609h14576l-9187-22017-1993-4076H95994m73363-90c-3795 46-7201 3540-7152 7332v18872h14483V7334c46-3854-3482-7381-7332-7332m23214 69865c-3997-2-7239-3245-7239-7242V7403c0-4000 3242-7241 7242-7241 4001 0 7242 3241 7242 7242v37737l42856-42859c2704 1122 4469 3763 4469 6691v55224c0 3999-3242 7241-7242 7241-4001 0-7242-3242-7242-7242V24888l-42856 42859c-1356 1357-3197 2120-5116 2120h-5m123995-34908l22528-22445c2833-2821 2841-7407 17-10243-2821-2833-7404-2839-10239-18l-22562 22484-22562-22484c-2836-2824-7419-2815-10239 18-2824 2835-2816 7422 15 10243l22527 22446-22461 22382c-2836 2825-2842 7407-18 10240 1352 1364 3195 2132 5117 2132h13c1848 0 3696-704 5109-2114l22499-22417 22496 22417c1352 1353 3190 2114 5104 2114h9c1859 0 3714-709 5130-2132 2821-2833 2815-7415-18-10239l-22463-22383M169359 69662c-3795-46-7201-3539-7152-7331V32017h14483v30314c46 3850-3482 7377-7332 7331z\" fill=\"#FFF\"\u003e\u003c/path\u003e\u003c/svg\u003e"
    },
    "model": {
      "version": "2.3.0"
    },
    "components_count": 0,
    "relationships_count": 0,
    "components": null,
    "relationships": null
  },
  "styles": {
    "primaryColor": "#009639",
    "secondaryColor": "#42C473",
    "shape": "circle",
    "svgColor": "\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 333334 71436\" shape-rendering=\"geometricPrecision\" text-rendering=\"geometricPrecision\" image-rendering=\"optimizeQuality\" fill-rule=\"evenodd\" clip-rule=\"evenodd\"\u003e\u003cpath d=\"M62460 69726c-1883 0-3736-733-5122-2120L14483 24747v37738c0 4001-3242 7242-7242 7242-3998 0-7242-3242-7242-7242V7263c0-2931 1767-5570 4472-6691C5349 207 6292 19 7244 19c1920 0 3762 765 5118 2123l42855 42859V7263c0-4001 3242-7242 7242-7242 4001 0 7242 3242 7242 7242v55222c-2 3998-3244 7240-7242 7242M95994 91l-1990 3714-15390 27970-1990 3532 1990 3528 15391 27067 2079 3710h40284l1990-4072 11496-23174 5159-10500h-11676l-29419 90c-3826-52-7346 3415-7346 7242 0 3826 3520 7296 7346 7242l17742-90-4344 8780h-22812L93186 35215l11407-20639h24265l5657 11609h14576l-9187-22017-1993-4076H95994m73363-90c-3795 46-7201 3540-7152 7332v18872h14483V7334c46-3854-3482-7381-7332-7332m23214 69865c-3997-2-7239-3245-7239-7242V7403c0-4000 3242-7241 7242-7241 4001 0 7242 3241 7242 7242v37737l42856-42859c2704 1122 4469 3763 4469 6691v55224c0 3999-3242 7241-7242 7241-4001 0-7242-3242-7242-7242V24888l-42856 42859c-1356 1357-3197 2120-5116 2120h-5m123995-34908l22528-22445c2833-2821 2841-7407 17-10243-2821-2833-7404-2839-10239-18l-22562 22484-22562-22484c-2836-2824-7419-2815-10239 18-2824 2835-2816 7422 15 10243l22527 22446-22461 22382c-2836 2825-2842 7407-18 10240 1352 1364 3195 2132 5117 2132h13c1848 0 3696-704 5109-2114l22499-22417 22496 22417c1352 1353 3190 2114 5104 2114h9c1859 0 3714-709 5130-2132 2821-2833 2815-7415-18-10239l-22463-22383M169359 69662c-3795-46-7201-3539-7152-7331V32017h14483v30314c46 3850-3482 7377-7332 7331z\" fill=\"#090\"/\u003e\u003c/svg\u003e",
    "svgComplete": "",
    "svgWhite": "\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 333334 71436\" shape-rendering=\"geometricPrecision\" text-rendering=\"geometricPrecision\" image-rendering=\"optimizeQuality\" fill-rule=\"evenodd\" clip-rule=\"evenodd\" width='333334' height='71436'\u003e\u003cpath d=\"M62460 69726c-1883 0-3736-733-5122-2120L14483 24747v37738c0 4001-3242 7242-7242 7242-3998 0-7242-3242-7242-7242V7263c0-2931 1767-5570 4472-6691C5349 207 6292 19 7244 19c1920 0 3762 765 5118 2123l42855 42859V7263c0-4001 3242-7242 7242-7242 4001 0 7242 3242 7242 7242v55222c-2 3998-3244 7240-7242 7242M95994 91l-1990 3714-15390 27970-1990 3532 1990 3528 15391 27067 2079 3710h40284l1990-4072 11496-23174 5159-10500h-11676l-29419 90c-3826-52-7346 3415-7346 7242 0 3826 3520 7296 7346 7242l17742-90-4344 8780h-22812L93186 35215l11407-20639h24265l5657 11609h14576l-9187-22017-1993-4076H95994m73363-90c-3795 46-7201 3540-7152 7332v18872h14483V7334c46-3854-3482-7381-7332-7332m23214 69865c-3997-2-7239-3245-7239-7242V7403c0-4000 3242-7241 7242-7241 4001 0 7242 3241 7242 7242v37737l42856-42859c2704 1122 4469 3763 4469 6691v55224c0 3999-3242 7241-7242 7241-4001 0-7242-3242-7242-7242V24888l-42856 42859c-1356 1357-3197 2120-5116 2120h-5m123995-34908l22528-22445c2833-2821 2841-7407 17-10243-2821-2833-7404-2839-10239-18l-22562 22484-22562-22484c-2836-2824-7419-2815-10239 18-2824 2835-2816 7422 15 10243l22527 22446-22461 22382c-2836 2825-2842 7407-18 10240 1352 1364 3195 2132 5117 2132h13c1848 0 3696-704 5109-2114l22499-22417 22496 22417c1352 1353 3190 2114 5104 2114h9c1859 0 3714-709 5130-2132 2821-2833 2815-7415-18-10239l-22463-22383M169359 69662c-3795-46-7201-3539-7152-7331V32017h14483v30314c46 3850-3482 7377-7332 7331z\" fill=\"#FFF\"/\u003e\u003c/svg\u003e"
  },
  "capabilities": [
    {
      "description": "Initiate a performance test. Meshery will execute the load generation, collect metrics, and present the results.",
      "displayName": "Performance Test",
      "entityState": [
        "instance"
      ],
      "key": "",
      "kind": "action",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "perf-test",
      "type": "operator",
      "version": "0.7.0"
    },
    {
      "description": "Configure the workload specific setting of a component",
      "displayName": "Workload Configuration",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "config",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "Configure Labels And Annotations for  the component ",
      "displayName": "Labels and Annotations Configuration",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "labels-and-annotations",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "View relationships for the component",
      "displayName": "Relationships",
      "entityState": [
        "declaration",
        "instance"
      ],
      "key": "",
      "kind": "view",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "relationship",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "View Component Definition ",
      "displayName": "Json Schema",
      "entityState": [
        "declaration",
        "instance"
      ],
      "key": "",
      "kind": "view",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "definition",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "Configure the visual styles for the component",
      "displayName": "Styling",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "",
      "type": "style",
      "version": "0.7.0"
    },
    {
      "description": "Change the shape of the component",
      "displayName": "Change Shape",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "shape",
      "type": "style",
      "version": "0.7.0"
    },
    {
      "description": "Drag and Drop a component into a parent component in graph view",
      "displayName": "Compound Drag And Drop",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "interaction",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "compoundDnd",
      "type": "graph",
      "version": "0.7.0"
    }
  ],
  "status": "enabled",
  "metadata": {
    "configurationUISchema": "",
    "genealogy": "",
    "instanceDetails": null,
    "isAnnotation": false,
    "isNamespaced": true,
    "published": false,
    "source_uri": "https://helm.nginx.com/stable/nginx-ingress-2.3.0.tgz"
  },
  "configuration": null,
  "component": {
    "version": "k8s.nginx.org/v1",
    "kind": "VirtualServerRoute",
    "schema": "{\n \"description\": \"VirtualServerRoute defines the VirtualServerRoute resource.\",\n \"properties\": {\n  \"spec\": {\n   \"description\": \"VirtualServerRouteSpec is the spec of the VirtualServerRoute resource.\",\n   \"properties\": {\n    \"host\": {\n     \"description\": \"The host (domain name) of the server. Must be a valid subdomain as defined in RFC 1123, such as my-app or hello.example.com. When using a wildcard domain like *.example.com the domain must be contained in double quotes. Must be the same as the host of the VirtualServer that references this resource.\",\n     \"type\": \"string\"\n    },\n    \"ingressClassName\": {\n     \"description\": \"Specifies which Ingress Controller must handle the VirtualServerRoute resource. Must be the same as the ingressClassName of the VirtualServer that references this resource.\",\n     \"type\": \"string\"\n    },\n    \"subroutes\": {\n     \"description\": \"A list of subroutes.\",\n     \"items\": {\n      \"description\": \"Route defines a route.\",\n      \"properties\": {\n       \"action\": {\n        \"description\": \"The default action to perform for a request.\",\n        \"properties\": {\n         \"pass\": {\n          \"description\": \"Passes requests to an upstream. The upstream with that name must be defined in the resource.\",\n          \"type\": \"string\"\n         },\n         \"proxy\": {\n          \"description\": \"Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).\",\n          \"properties\": {\n           \"requestHeaders\": {\n            \"description\": \"The request headers modifications.\",\n            \"properties\": {\n             \"pass\": {\n              \"description\": \"Passes the original request headers to the proxied upstream server.  Default is true.\",\n              \"type\": \"boolean\"\n             },\n             \"set\": {\n              \"description\": \"Allows redefining or appending fields to present request headers passed to the proxied upstream servers.\",\n              \"items\": {\n               \"description\": \"Header defines an HTTP Header.\",\n               \"properties\": {\n                \"name\": {\n                 \"description\": \"The name of the header.\",\n                 \"type\": \"string\"\n                },\n                \"value\": {\n                 \"description\": \"The value of the header.\",\n                 \"type\": \"string\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"responseHeaders\": {\n            \"description\": \"The response headers modifications.\",\n            \"properties\": {\n             \"add\": {\n              \"description\": \"Adds headers to the response to the client.\",\n              \"items\": {\n               \"description\": \"AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.\",\n               \"properties\": {\n                \"always\": {\n                 \"description\": \"If set to true, add the header regardless of the response status code**. Default is false.\",\n                 \"type\": \"boolean\"\n                },\n                \"name\": {\n                 \"description\": \"The name of the header.\",\n                 \"type\": \"string\"\n                },\n                \"value\": {\n                 \"description\": \"The value of the header.\",\n                 \"type\": \"string\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"hide\": {\n              \"description\": \"The headers that will not be passed* in the response to the client from a proxied upstream server.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             },\n             \"ignore\": {\n              \"description\": \"Disables processing of certain headers** to the client from a proxied upstream server.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             },\n             \"pass\": {\n              \"description\": \"Allows passing the hidden header fields* to the client from a proxied upstream server.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"rewritePath\": {\n            \"description\": \"The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.\",\n            \"type\": \"string\"\n           },\n           \"upstream\": {\n            \"description\": \"The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"redirect\": {\n          \"description\": \"Redirects requests to a provided URL.\",\n          \"properties\": {\n           \"code\": {\n            \"description\": \"The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.\",\n            \"type\": \"integer\"\n           },\n           \"url\": {\n            \"description\": \"The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"return\": {\n          \"description\": \"Returns a preconfigured response.\",\n          \"properties\": {\n           \"body\": {\n            \"description\": \"The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\\\\n.\",\n            \"type\": \"string\"\n           },\n           \"code\": {\n            \"description\": \"The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.\",\n            \"type\": \"integer\"\n           },\n           \"headers\": {\n            \"description\": \"The custom headers of the response.\",\n            \"items\": {\n             \"description\": \"Header defines an HTTP Header.\",\n             \"properties\": {\n              \"name\": {\n               \"description\": \"The name of the header.\",\n               \"type\": \"string\"\n              },\n              \"value\": {\n               \"description\": \"The value of the header.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"type\": {\n            \"description\": \"The MIME type of the response. The default is text/plain.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"dos\": {\n        \"description\": \"A reference to a DosProtectedResource, setting this enables DOS protection of the VirtualServer route.\",\n        \"type\": \"string\"\n       },\n       \"errorPages\": {\n        \"description\": \"The custom responses for error codes. NGINX will use those responses instead of returning the error responses from the upstream servers or the default responses generated by NGINX. A custom response can be a redirect or a canned response. For example, a redirect to another URL if an upstream server responded with a 404 status code.\",\n        \"items\": {\n         \"description\": \"ErrorPage defines an ErrorPage in a Route.\",\n         \"properties\": {\n          \"codes\": {\n           \"description\": \"A list of error status codes.\",\n           \"items\": {\n            \"type\": \"integer\"\n           },\n           \"type\": \"array\"\n          },\n          \"redirect\": {\n           \"description\": \"The canned response action for the given status codes.\",\n           \"properties\": {\n            \"code\": {\n             \"description\": \"The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.\",\n             \"type\": \"integer\"\n            },\n            \"url\": {\n             \"description\": \"The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"return\": {\n           \"description\": \"The redirect action for the given status codes.\",\n           \"properties\": {\n            \"body\": {\n             \"description\": \"The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\\\\n.\",\n             \"type\": \"string\"\n            },\n            \"code\": {\n             \"description\": \"The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.\",\n             \"type\": \"integer\"\n            },\n            \"headers\": {\n             \"description\": \"The custom headers of the response.\",\n             \"items\": {\n              \"description\": \"Header defines an HTTP Header.\",\n              \"properties\": {\n               \"name\": {\n                \"description\": \"The name of the header.\",\n                \"type\": \"string\"\n               },\n               \"value\": {\n                \"description\": \"The value of the header.\",\n                \"type\": \"string\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"type\": \"array\"\n            },\n            \"type\": {\n             \"description\": \"The MIME type of the response. The default is text/plain.\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       },\n       \"location-snippets\": {\n        \"description\": \"Sets a custom snippet in the location context. Overrides the location-snippets ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"matches\": {\n        \"description\": \"The matching rules for advanced content-based routing. Requires the default Action or Splits. Unmatched requests will be handled by the default Action or Splits.\",\n        \"items\": {\n         \"description\": \"Match defines a match.\",\n         \"properties\": {\n          \"action\": {\n           \"description\": \"The action to perform for a request.\",\n           \"properties\": {\n            \"pass\": {\n             \"description\": \"Passes requests to an upstream. The upstream with that name must be defined in the resource.\",\n             \"type\": \"string\"\n            },\n            \"proxy\": {\n             \"description\": \"Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).\",\n             \"properties\": {\n              \"requestHeaders\": {\n               \"description\": \"The request headers modifications.\",\n               \"properties\": {\n                \"pass\": {\n                 \"description\": \"Passes the original request headers to the proxied upstream server.  Default is true.\",\n                 \"type\": \"boolean\"\n                },\n                \"set\": {\n                 \"description\": \"Allows redefining or appending fields to present request headers passed to the proxied upstream servers.\",\n                 \"items\": {\n                  \"description\": \"Header defines an HTTP Header.\",\n                  \"properties\": {\n                   \"name\": {\n                    \"description\": \"The name of the header.\",\n                    \"type\": \"string\"\n                   },\n                   \"value\": {\n                    \"description\": \"The value of the header.\",\n                    \"type\": \"string\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"responseHeaders\": {\n               \"description\": \"The response headers modifications.\",\n               \"properties\": {\n                \"add\": {\n                 \"description\": \"Adds headers to the response to the client.\",\n                 \"items\": {\n                  \"description\": \"AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.\",\n                  \"properties\": {\n                   \"always\": {\n                    \"description\": \"If set to true, add the header regardless of the response status code**. Default is false.\",\n                    \"type\": \"boolean\"\n                   },\n                   \"name\": {\n                    \"description\": \"The name of the header.\",\n                    \"type\": \"string\"\n                   },\n                   \"value\": {\n                    \"description\": \"The value of the header.\",\n                    \"type\": \"string\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"hide\": {\n                 \"description\": \"The headers that will not be passed* in the response to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"ignore\": {\n                 \"description\": \"Disables processing of certain headers** to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"pass\": {\n                 \"description\": \"Allows passing the hidden header fields* to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"rewritePath\": {\n               \"description\": \"The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.\",\n               \"type\": \"string\"\n              },\n              \"upstream\": {\n               \"description\": \"The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"redirect\": {\n             \"description\": \"Redirects requests to a provided URL.\",\n             \"properties\": {\n              \"code\": {\n               \"description\": \"The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.\",\n               \"type\": \"integer\"\n              },\n              \"url\": {\n               \"description\": \"The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"return\": {\n             \"description\": \"Returns a preconfigured response.\",\n             \"properties\": {\n              \"body\": {\n               \"description\": \"The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\\\\n.\",\n               \"type\": \"string\"\n              },\n              \"code\": {\n               \"description\": \"The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.\",\n               \"type\": \"integer\"\n              },\n              \"headers\": {\n               \"description\": \"The custom headers of the response.\",\n               \"items\": {\n                \"description\": \"Header defines an HTTP Header.\",\n                \"properties\": {\n                 \"name\": {\n                  \"description\": \"The name of the header.\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"description\": \"The value of the header.\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"type\": \"object\"\n               },\n               \"type\": \"array\"\n              },\n              \"type\": {\n               \"description\": \"The MIME type of the response. The default is text/plain.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"conditions\": {\n           \"description\": \"A list of conditions. Must include at least 1 condition.\",\n           \"items\": {\n            \"description\": \"Condition defines a condition in a MatchRule.\",\n            \"properties\": {\n             \"argument\": {\n              \"description\": \"The name of an argument. Must consist of alphanumeric characters or _.\",\n              \"type\": \"string\"\n             },\n             \"cookie\": {\n              \"description\": \"The name of a cookie. Must consist of alphanumeric characters or _.\",\n              \"type\": \"string\"\n             },\n             \"header\": {\n              \"description\": \"The name of a header. Must consist of alphanumeric characters or -.\",\n              \"type\": \"string\"\n             },\n             \"value\": {\n              \"description\": \"The value to match the condition against.\",\n              \"type\": \"string\"\n             },\n             \"variable\": {\n              \"description\": \"The name of an NGINX variable. Must start with $.\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          },\n          \"splits\": {\n           \"description\": \"The splits configuration for traffic splitting. Must include at least 2 splits.\",\n           \"items\": {\n            \"description\": \"Split defines a split.\",\n            \"properties\": {\n             \"action\": {\n              \"description\": \"The action to perform for a request.\",\n              \"properties\": {\n               \"pass\": {\n                \"description\": \"Passes requests to an upstream. The upstream with that name must be defined in the resource.\",\n                \"type\": \"string\"\n               },\n               \"proxy\": {\n                \"description\": \"Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).\",\n                \"properties\": {\n                 \"requestHeaders\": {\n                  \"description\": \"The request headers modifications.\",\n                  \"properties\": {\n                   \"pass\": {\n                    \"description\": \"Passes the original request headers to the proxied upstream server.  Default is true.\",\n                    \"type\": \"boolean\"\n                   },\n                   \"set\": {\n                    \"description\": \"Allows redefining or appending fields to present request headers passed to the proxied upstream servers.\",\n                    \"items\": {\n                     \"description\": \"Header defines an HTTP Header.\",\n                     \"properties\": {\n                      \"name\": {\n                       \"description\": \"The name of the header.\",\n                       \"type\": \"string\"\n                      },\n                      \"value\": {\n                       \"description\": \"The value of the header.\",\n                       \"type\": \"string\"\n                      }\n                     },\n                     \"type\": \"object\"\n                    },\n                    \"type\": \"array\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"responseHeaders\": {\n                  \"description\": \"The response headers modifications.\",\n                  \"properties\": {\n                   \"add\": {\n                    \"description\": \"Adds headers to the response to the client.\",\n                    \"items\": {\n                     \"description\": \"AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.\",\n                     \"properties\": {\n                      \"always\": {\n                       \"description\": \"If set to true, add the header regardless of the response status code**. Default is false.\",\n                       \"type\": \"boolean\"\n                      },\n                      \"name\": {\n                       \"description\": \"The name of the header.\",\n                       \"type\": \"string\"\n                      },\n                      \"value\": {\n                       \"description\": \"The value of the header.\",\n                       \"type\": \"string\"\n                      }\n                     },\n                     \"type\": \"object\"\n                    },\n                    \"type\": \"array\"\n                   },\n                   \"hide\": {\n                    \"description\": \"The headers that will not be passed* in the response to the client from a proxied upstream server.\",\n                    \"items\": {\n                     \"type\": \"string\"\n                    },\n                    \"type\": \"array\"\n                   },\n                   \"ignore\": {\n                    \"description\": \"Disables processing of certain headers** to the client from a proxied upstream server.\",\n                    \"items\": {\n                     \"type\": \"string\"\n                    },\n                    \"type\": \"array\"\n                   },\n                   \"pass\": {\n                    \"description\": \"Allows passing the hidden header fields* to the client from a proxied upstream server.\",\n                    \"items\": {\n                     \"type\": \"string\"\n                    },\n                    \"type\": \"array\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"rewritePath\": {\n                  \"description\": \"The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.\",\n                  \"type\": \"string\"\n                 },\n                 \"upstream\": {\n                  \"description\": \"The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"type\": \"object\"\n               },\n               \"redirect\": {\n                \"description\": \"Redirects requests to a provided URL.\",\n                \"properties\": {\n                 \"code\": {\n                  \"description\": \"The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.\",\n                  \"type\": \"integer\"\n                 },\n                 \"url\": {\n                  \"description\": \"The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"type\": \"object\"\n               },\n               \"return\": {\n                \"description\": \"Returns a preconfigured response.\",\n                \"properties\": {\n                 \"body\": {\n                  \"description\": \"The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\\\\n.\",\n                  \"type\": \"string\"\n                 },\n                 \"code\": {\n                  \"description\": \"The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.\",\n                  \"type\": \"integer\"\n                 },\n                 \"headers\": {\n                  \"description\": \"The custom headers of the response.\",\n                  \"items\": {\n                   \"description\": \"Header defines an HTTP Header.\",\n                   \"properties\": {\n                    \"name\": {\n                     \"description\": \"The name of the header.\",\n                     \"type\": \"string\"\n                    },\n                    \"value\": {\n                     \"description\": \"The value of the header.\",\n                     \"type\": \"string\"\n                    }\n                   },\n                   \"type\": \"object\"\n                  },\n                  \"type\": \"array\"\n                 },\n                 \"type\": {\n                  \"description\": \"The MIME type of the response. The default is text/plain.\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"weight\": {\n              \"description\": \"The weight of an action. Must fall into the range 0..100. The sum of the weights of all splits must be equal to 100.\",\n              \"type\": \"integer\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       },\n       \"path\": {\n        \"description\": \"The path of the route. NGINX will match it against the URI of a request. Possible values are: a prefix ( / , /path ), an exact match ( =/exact/match ), a case insensitive regular expression ( ~*^/Bar.*\\\\.jpg ) or a case sensitive regular expression ( ~^/foo.*\\\\.jpg ). In the case of a prefix (must start with / ) or an exact match (must start with = ), the path must not include any whitespace characters, { , } or ;. In the case of the regex matches, all double quotes \\\" must be escaped and the match can’t end in an unescaped backslash \\\\. The path must be unique among the paths of all routes of the VirtualServer. Check the location directive for more information.\",\n        \"type\": \"string\"\n       },\n       \"policies\": {\n        \"description\": \"A list of policies. The policies override the policies of the same type defined in the spec of the VirtualServer.\",\n        \"items\": {\n         \"description\": \"PolicyReference references a policy by name and an optional namespace.\",\n         \"properties\": {\n          \"name\": {\n           \"description\": \"The name of a policy. If the policy doesn’t exist or invalid, NGINX will respond with an error response with the 500 status code.\",\n           \"type\": \"string\"\n          },\n          \"namespace\": {\n           \"description\": \"The namespace of a policy. If not specified, the namespace of the VirtualServer resource is used.\",\n           \"type\": \"string\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       },\n       \"route\": {\n        \"description\": \"The name of a VirtualServerRoute resource that defines this route. If the VirtualServerRoute belongs to a different namespace than the VirtualServer, you need to include the namespace. For example, tea-namespace/tea.\",\n        \"type\": \"string\"\n       },\n       \"splits\": {\n        \"description\": \"The default splits configuration for traffic splitting. Must include at least 2 splits.\",\n        \"items\": {\n         \"description\": \"Split defines a split.\",\n         \"properties\": {\n          \"action\": {\n           \"description\": \"The action to perform for a request.\",\n           \"properties\": {\n            \"pass\": {\n             \"description\": \"Passes requests to an upstream. The upstream with that name must be defined in the resource.\",\n             \"type\": \"string\"\n            },\n            \"proxy\": {\n             \"description\": \"Passes requests to an upstream with the ability to modify the request/response (for example, rewrite the URI or modify the headers).\",\n             \"properties\": {\n              \"requestHeaders\": {\n               \"description\": \"The request headers modifications.\",\n               \"properties\": {\n                \"pass\": {\n                 \"description\": \"Passes the original request headers to the proxied upstream server.  Default is true.\",\n                 \"type\": \"boolean\"\n                },\n                \"set\": {\n                 \"description\": \"Allows redefining or appending fields to present request headers passed to the proxied upstream servers.\",\n                 \"items\": {\n                  \"description\": \"Header defines an HTTP Header.\",\n                  \"properties\": {\n                   \"name\": {\n                    \"description\": \"The name of the header.\",\n                    \"type\": \"string\"\n                   },\n                   \"value\": {\n                    \"description\": \"The value of the header.\",\n                    \"type\": \"string\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"responseHeaders\": {\n               \"description\": \"The response headers modifications.\",\n               \"properties\": {\n                \"add\": {\n                 \"description\": \"Adds headers to the response to the client.\",\n                 \"items\": {\n                  \"description\": \"AddHeader defines an HTTP Header with an optional Always field to use with the add_header NGINX directive.\",\n                  \"properties\": {\n                   \"always\": {\n                    \"description\": \"If set to true, add the header regardless of the response status code**. Default is false.\",\n                    \"type\": \"boolean\"\n                   },\n                   \"name\": {\n                    \"description\": \"The name of the header.\",\n                    \"type\": \"string\"\n                   },\n                   \"value\": {\n                    \"description\": \"The value of the header.\",\n                    \"type\": \"string\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"hide\": {\n                 \"description\": \"The headers that will not be passed* in the response to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"ignore\": {\n                 \"description\": \"Disables processing of certain headers** to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"pass\": {\n                 \"description\": \"Allows passing the hidden header fields* to the client from a proxied upstream server.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"rewritePath\": {\n               \"description\": \"The rewritten URI. If the route path is a regular expression – starts with ~ – the rewritePath can include capture groups with $1-9. For example $1 for the first group, and so on. For more information, check the rewrite example.\",\n               \"type\": \"string\"\n              },\n              \"upstream\": {\n               \"description\": \"The name of the upstream which the requests will be proxied to. The upstream with that name must be defined in the resource.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"redirect\": {\n             \"description\": \"Redirects requests to a provided URL.\",\n             \"properties\": {\n              \"code\": {\n               \"description\": \"The status code of a redirect. The allowed values are: 301, 302, 307 or 308. The default is 301.\",\n               \"type\": \"integer\"\n              },\n              \"url\": {\n               \"description\": \"The URL to redirect the request to. Supported NGINX variables: $scheme, $http_x_forwarded_proto, $request_uri or $host. Variables must be enclosed in curly braces. For example: ${host}${request_uri}.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"return\": {\n             \"description\": \"Returns a preconfigured response.\",\n             \"properties\": {\n              \"body\": {\n               \"description\": \"The body of the response. Supports NGINX variables*. Variables must be enclosed in curly brackets. For example: Request is ${request_uri}\\\\n.\",\n               \"type\": \"string\"\n              },\n              \"code\": {\n               \"description\": \"The status code of the response. The allowed values are: 2XX, 4XX or 5XX. The default is 200.\",\n               \"type\": \"integer\"\n              },\n              \"headers\": {\n               \"description\": \"The custom headers of the response.\",\n               \"items\": {\n                \"description\": \"Header defines an HTTP Header.\",\n                \"properties\": {\n                 \"name\": {\n                  \"description\": \"The name of the header.\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"description\": \"The value of the header.\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"type\": \"object\"\n               },\n               \"type\": \"array\"\n              },\n              \"type\": {\n               \"description\": \"The MIME type of the response. The default is text/plain.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"weight\": {\n           \"description\": \"The weight of an action. Must fall into the range 0..100. The sum of the weights of all splits must be equal to 100.\",\n           \"type\": \"integer\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"upstreams\": {\n     \"description\": \"A list of upstreams.\",\n     \"items\": {\n      \"description\": \"Upstream defines an upstream.\",\n      \"properties\": {\n       \"backup\": {\n        \"description\": \"The name of the backup service of type ExternalName. This will be used when the primary servers are unavailable. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods.\",\n        \"type\": \"string\"\n       },\n       \"backupPort\": {\n        \"description\": \"The port of the backup service. The backup port is required if the backup service name is provided. The port must fall into the range 1..65535.\",\n        \"type\": \"integer\"\n       },\n       \"buffer-size\": {\n        \"description\": \"Sets the size of the buffer used for reading the first part of a response received from the upstream server. The default is set in the proxy-buffer-size ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"buffering\": {\n        \"description\": \"Enables buffering of responses from the upstream server.  The default is set in the proxy-buffering ConfigMap key.\",\n        \"type\": \"boolean\"\n       },\n       \"buffers\": {\n        \"description\": \"Configures the buffers used for reading a response from the upstream server for a single connection.\",\n        \"properties\": {\n         \"number\": {\n          \"description\": \"Configures the number of buffers. The default is set in the proxy-buffers ConfigMap key.\",\n          \"type\": \"integer\"\n         },\n         \"size\": {\n          \"description\": \"Configures the size of a buffer. The default is set in the proxy-buffers ConfigMap key.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"busy-buffers-size\": {\n        \"description\": \"Sets the size of the buffers used for reading a response from the upstream server when the proxy_buffering is enabled. The default is set in the proxy-busy-buffers-size ConfigMap key.'\",\n        \"type\": \"string\"\n       },\n       \"client-max-body-size\": {\n        \"description\": \"Sets the maximum allowed size of the client request body. The default is set in the client-max-body-size ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"connect-timeout\": {\n        \"description\": \"The timeout for establishing a connection with an upstream server. The default is specified in the proxy-connect-timeout ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"fail-timeout\": {\n        \"description\": \"The time during which the specified number of unsuccessful attempts to communicate with an upstream server should happen to consider the server unavailable. The default is set in the fail-timeout ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"healthCheck\": {\n        \"description\": \"The health check configuration for the Upstream. Note: this feature is supported only in NGINX Plus.\",\n        \"properties\": {\n         \"connect-timeout\": {\n          \"description\": \"The timeout for establishing a connection with an upstream server. By default, the connect-timeout of the upstream is used.\",\n          \"type\": \"string\"\n         },\n         \"enable\": {\n          \"description\": \"Enables a health check for an upstream server. The default is false.\",\n          \"type\": \"boolean\"\n         },\n         \"fails\": {\n          \"description\": \"The number of consecutive failed health checks of a particular upstream server after which this server will be considered unhealthy. The default is 1.\",\n          \"type\": \"integer\"\n         },\n         \"grpcService\": {\n          \"description\": \"The gRPC service to be monitored on the upstream server. Only valid on gRPC type upstreams.\",\n          \"type\": \"string\"\n         },\n         \"grpcStatus\": {\n          \"description\": \"The expected gRPC status code of the upstream server response to the Check method. Configure this field only if your gRPC services do not implement the gRPC health checking protocol. For example, configure 12 if the upstream server responds with 12 (UNIMPLEMENTED) status code. Only valid on gRPC type upstreams.\",\n          \"type\": \"integer\"\n         },\n         \"headers\": {\n          \"description\": \"The request headers used for health check requests. NGINX Plus always sets the Host, User-Agent and Connection headers for health check requests.\",\n          \"items\": {\n           \"description\": \"Header defines an HTTP Header.\",\n           \"properties\": {\n            \"name\": {\n             \"description\": \"The name of the header.\",\n             \"type\": \"string\"\n            },\n            \"value\": {\n             \"description\": \"The value of the header.\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"type\": \"array\"\n         },\n         \"interval\": {\n          \"description\": \"The interval between two consecutive health checks. The default is 5s.\",\n          \"type\": \"string\"\n         },\n         \"jitter\": {\n          \"description\": \"The time within which each health check will be randomly delayed. By default, there is no delay.\",\n          \"type\": \"string\"\n         },\n         \"keepalive-time\": {\n          \"description\": \"Enables keepalive connections for health checks and specifies the time during which requests can be processed through one keepalive connection. The default is 60s.\",\n          \"type\": \"string\"\n         },\n         \"mandatory\": {\n          \"description\": \"Require every newly added server to pass all configured health checks before NGINX Plus sends traffic to it. If this is not specified, or is set to false, the server will be initially considered healthy. When combined with slow-start, it gives a new server more time to connect to databases and “warm up” before being asked to handle their full share of traffic.\",\n          \"type\": \"boolean\"\n         },\n         \"passes\": {\n          \"description\": \"The number of consecutive passed health checks of a particular upstream server after which the server will be considered healthy. The default is 1.\",\n          \"type\": \"integer\"\n         },\n         \"path\": {\n          \"description\": \"The path used for health check requests. The default is /. This is not configurable for gRPC type upstreams.\",\n          \"type\": \"string\"\n         },\n         \"persistent\": {\n          \"description\": \"Set the initial “up” state for a server after reload if the server was considered healthy before reload. Enabling persistent requires that the mandatory parameter is also set to true.\",\n          \"type\": \"boolean\"\n         },\n         \"port\": {\n          \"description\": \"The port used for health check requests. By default, the server port is used. Note: in contrast with the port of the upstream, this port is not a service port, but a port of a pod.\",\n          \"type\": \"integer\"\n         },\n         \"read-timeout\": {\n          \"description\": \"The timeout for reading a response from an upstream server. By default, the read-timeout of the upstream is used.\",\n          \"type\": \"string\"\n         },\n         \"send-timeout\": {\n          \"description\": \"The timeout for transmitting a request to an upstream server. By default, the send-timeout of the upstream is used.\",\n          \"type\": \"string\"\n         },\n         \"statusMatch\": {\n          \"description\": \"The expected response status codes of a health check. By default, the response should have status code 2xx or 3xx. Examples: \\\"200\\\", \\\"! 500\\\", \\\"301-303 307\\\". This not supported for gRPC type upstreams.\",\n          \"type\": \"string\"\n         },\n         \"tls\": {\n          \"description\": \"The TLS configuration used for health check requests. By default, the tls field of the upstream is used.\",\n          \"properties\": {\n           \"enable\": {\n            \"description\": \"Enables HTTPS for requests to upstream servers. The default is False , meaning that HTTP will be used. Note: by default, NGINX will not verify the upstream server certificate. To enable the verification, configure an EgressMTLS Policy.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"keepalive\": {\n        \"description\": \"Configures the cache for connections to upstream servers. The value 0 disables the cache. The default is set in the keepalive ConfigMap key.\",\n        \"type\": \"integer\"\n       },\n       \"lb-method\": {\n        \"description\": \"The load balancing method. To use the round-robin method, specify round_robin. The default is specified in the lb-method ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"max-conns\": {\n        \"description\": \"The maximum number of simultaneous active connections to an upstream server. By default there is no limit. Note: if keepalive connections are enabled, the total number of active and idle keepalive connections to an upstream server may exceed the max_conns value.\",\n        \"type\": \"integer\"\n       },\n       \"max-fails\": {\n        \"description\": \"The number of unsuccessful attempts to communicate with an upstream server that should happen in the duration set by the fail-timeout to consider the server unavailable. The default is set in the max-fails ConfigMap key.\",\n        \"type\": \"integer\"\n       },\n       \"name\": {\n        \"description\": \"The name of the upstream. Must be a valid DNS label as defined in RFC 1035. For example, hello and upstream-123 are valid. The name must be unique among all upstreams of the resource.\",\n        \"type\": \"string\"\n       },\n       \"next-upstream\": {\n        \"description\": \"Specifies in which cases a request should be passed to the next upstream server. The default is error timeout.\",\n        \"type\": \"string\"\n       },\n       \"next-upstream-timeout\": {\n        \"description\": \"The time during which a request can be passed to the next upstream server. The 0 value turns off the time limit. The default is 0.\",\n        \"type\": \"string\"\n       },\n       \"next-upstream-tries\": {\n        \"description\": \"The number of possible tries for passing a request to the next upstream server. The 0 value turns off this limit. The default is 0.\",\n        \"type\": \"integer\"\n       },\n       \"ntlm\": {\n        \"description\": \"Allows proxying requests with NTLM Authentication. In order for NTLM authentication to work, it is necessary to enable keepalive connections to upstream servers using the keepalive field. Note: this feature is supported only in NGINX Plus.\",\n        \"type\": \"boolean\"\n       },\n       \"port\": {\n        \"description\": \"The port of the service. If the service doesn’t define that port, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. The port must fall into the range 1..65535.\",\n        \"type\": \"integer\"\n       },\n       \"queue\": {\n        \"description\": \"Configures a queue for an upstream. A client request will be placed into the queue if an upstream server cannot be selected immediately while processing the request. By default, no queue is configured. Note: this feature is supported only in NGINX Plus.\",\n        \"properties\": {\n         \"size\": {\n          \"description\": \"The size of the queue.\",\n          \"type\": \"integer\"\n         },\n         \"timeout\": {\n          \"description\": \"The timeout of the queue. A request cannot be queued for a period longer than the timeout. The default is 60s.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"read-timeout\": {\n        \"description\": \"The timeout for reading a response from an upstream server. The default is specified in the proxy-read-timeout ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"send-timeout\": {\n        \"description\": \"The timeout for transmitting a request to an upstream server. The default is specified in the proxy-send-timeout ConfigMap key.\",\n        \"type\": \"string\"\n       },\n       \"service\": {\n        \"description\": \"The name of a service. The service must belong to the same namespace as the resource. If the service doesn’t exist, NGINX will assume the service has zero endpoints and return a 502 response for requests for this upstream. For NGINX Plus only, services of type ExternalName are also supported .\",\n        \"type\": \"string\"\n       },\n       \"sessionCookie\": {\n        \"description\": \"The SessionCookie field configures session persistence which allows requests from the same client to be passed to the same upstream server. The information about the designated upstream server is passed in a session cookie generated by NGINX Plus.\",\n        \"properties\": {\n         \"domain\": {\n          \"description\": \"The domain for which the cookie is set.\",\n          \"type\": \"string\"\n         },\n         \"enable\": {\n          \"description\": \"Enables session persistence with a session cookie for an upstream server. The default is false.\",\n          \"type\": \"boolean\"\n         },\n         \"expires\": {\n          \"description\": \"The time for which a browser should keep the cookie. Can be set to the special value max, which will cause the cookie to expire on 31 Dec 2037 23:55:55 GMT.\",\n          \"type\": \"string\"\n         },\n         \"httpOnly\": {\n          \"description\": \"Adds the HttpOnly attribute to the cookie.\",\n          \"type\": \"boolean\"\n         },\n         \"name\": {\n          \"description\": \"The name of the cookie.\",\n          \"type\": \"string\"\n         },\n         \"path\": {\n          \"description\": \"The path for which the cookie is set.\",\n          \"type\": \"string\"\n         },\n         \"samesite\": {\n          \"description\": \"Adds the SameSite attribute to the cookie. The allowed values are: strict, lax, none\",\n          \"type\": \"string\"\n         },\n         \"secure\": {\n          \"description\": \"Adds the Secure attribute to the cookie.\",\n          \"type\": \"boolean\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"slow-start\": {\n        \"description\": \"The slow start allows an upstream server to gradually recover its weight from 0 to its nominal value after it has been recovered or became available or when the server becomes available after a period of time it was considered unavailable. By default, the slow start is disabled. Note: The parameter cannot be used along with the random, hash or ip_hash load balancing methods and will be ignored.\",\n        \"type\": \"string\"\n       },\n       \"subselector\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Selects the pods within the service using label keys and values. By default, all pods of the service are selected. Note: the specified labels are expected to be present in the pods when they are created. If the pod labels are updated, NGINX Ingress Controller will not see that change until the number of the pods is changed.\",\n        \"type\": \"object\"\n       },\n       \"tls\": {\n        \"description\": \"The TLS configuration for the Upstream.\",\n        \"properties\": {\n         \"enable\": {\n          \"description\": \"Enables HTTPS for requests to upstream servers. The default is False , meaning that HTTP will be used. Note: by default, NGINX will not verify the upstream server certificate. To enable the verification, configure an EgressMTLS Policy.\",\n          \"type\": \"boolean\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"type\": {\n        \"description\": \"The type of the upstream. Supported values are http and grpc. The default is http. For gRPC, it is necessary to enable HTTP/2 in the ConfigMap and configure TLS termination in the VirtualServer.\",\n        \"type\": \"string\"\n       },\n       \"use-cluster-ip\": {\n        \"description\": \"Enables using the Cluster IP and port of the service instead of the default behavior of using the IP and port of the pods. When this field is enabled, the fields that configure NGINX behavior related to multiple upstream servers (like lb-method and next-upstream) will have no effect, as NGINX Ingress Controller will configure NGINX with only one upstream server that will match the service Cluster IP.\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    }\n   },\n   \"type\": \"object\"\n  }\n },\n \"title\": \"Virtual Server Route\",\n \"type\": \"object\"\n}"
  }
}