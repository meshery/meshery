{"kind":"VirtualGateway","apiVersion":"networking.enterprise.mesh.gloo.solo.io/v1beta1","displayName":"Virtual Gateway","format":"JSON","metadata":{"genealogy":"","isNamespaced":true,"logoURL":"","model":"gloo-mesh","modelDisplayName":"gloo-mesh","primaryColor":"#00B39F","published":false,"secondaryColor":"#00D3A9","shape":"circle","styleOverrides":"","subCategory":"Uncategorized","svgColor":"","svgComplete":"","svgWhite":""},"model":{"name":"gloo-mesh","version":"1.2.0-beta1","displayName":"gloo-mesh","category":{"name":"Uncategorized","metadata":null},"metadata":null},"schema":"{\n \"description\": \"VirtualGateway is the top-level object for configuring ingress into a Mesh or VirtualMesh.\\n   A single VirtualGateway can apply to multiple deployed ingress pods and sidecars across meshes and clusters contained within a VirtualMesh.\\n   VirtualGateways can route traffic to destination services which live in a specific cluster or mesh.\\n   This allows VirtualGateways to route traffic from an ingress or sidecar in one mesh to a service in another. In order to\\n   perform cross-mesh routing, the Gateway Mesh and Destination mesh must be contained in a single VirtualMesh, with federation enabled.\",\n \"properties\": {\n  \"connectionHandlers\": {\n   \"description\": \"Each Gateway must implement one or more ConnectionHandlers.\\nA ConnectionHandler instructs the gateway how to handle clients\\nwhich have connected to the specified bind address.\\nTypically `connectionHandlers` will consist of a single `http` handler\\nwhich serves HTTP Routes defined in a set of VirtualHosts.\\nMultiple `connectionHandlers` can be specified to provide different behavior\\non the same Gateway, e.g. one for TCP and one for HTTP traffic.\\nNOTE: Currently having multiple connection handlers is NOT supported. Only\\nexactly ONE connection handler can be specified.\",\n   \"items\": {\n    \"oneOf\": [\n     {\n      \"not\": {\n       \"anyOf\": [\n        {\n         \"required\": [\n          \"http\"\n         ]\n        },\n        {\n         \"required\": [\n          \"tcp\"\n         ]\n        }\n       ]\n      }\n     },\n     {\n      \"required\": [\n       \"http\"\n      ]\n     },\n     {\n      \"required\": [\n       \"tcp\"\n      ]\n     }\n    ],\n    \"properties\": {\n     \"connectionMatch\": {\n      \"description\": \"Additional options for matching a connection to a specific gateway.\\nThis is required when more than one `connectionHandler` is specified for a single gateway.\\nTypically this is used to serve different\",\n      \"properties\": {\n       \"serverNames\": {\n        \"description\": \"If non-empty, a list of server names (e.g. SNI for TLS protocol) to consider when determining\\na `connectionMatch`. Those values will be compared against the server names of a new\\nconnection, when detected by one of the listener filters.\\n\\nThe server name will be matched against all wildcard domains, i.e. `www.example.com`\\nwill be first matched against `www.example.com`, then `*.example.com`, then ``*.com`.\\n\\nNote that partial wildcards are not supported, and values like `*w.example.com` are invalid.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"transportProtocol\": {\n        \"description\": \"Optional, if set this will be used as the protocol for the gateway, otherwise it will be inferred based on the following logic:\\n\\n- If the connectionHandler is a HTTP handler and no SslConfig is set in the connectionOptions, use \\\"HTTP\\\"\\n\\n- If the connectionHandler is a HTTP handler and any SslConfig is set in the connectionOptions, use \\\"HTTPS\\\"\\n\\n- If the connectionHandler is a TCP handler and no SslConfig is set in the connectionOptions, use \\\"TCP\\\"\\n\\n- If the connectionHandler is a TCP handler and any SslConfig is set in the connectionOptions, use \\\"TLS\\\"\",\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"connectionOptions\": {\n      \"description\": \"Top level optional configuration for all routes on the ConnectionHandler.\",\n      \"oneOf\": [\n       {\n        \"not\": {\n         \"anyOf\": [\n          {\n           \"properties\": {\n            \"sslConfig\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"secretName\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"sslFiles\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"secretName\"\n               ]\n              },\n              {\n               \"required\": [\n                \"sslFiles\"\n               ]\n              }\n             ]\n            }\n           },\n           \"required\": [\n            \"sslConfig\"\n           ]\n          },\n          {\n           \"required\": [\n            \"httpsRedirect\"\n           ]\n          }\n         ]\n        }\n       },\n       {\n        \"properties\": {\n         \"sslConfig\": {\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"secretName\"\n               ]\n              },\n              {\n               \"required\": [\n                \"sslFiles\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"secretName\"\n            ]\n           },\n           {\n            \"required\": [\n             \"sslFiles\"\n            ]\n           }\n          ]\n         }\n        },\n        \"required\": [\n         \"sslConfig\"\n        ]\n       },\n       {\n        \"required\": [\n         \"httpsRedirect\"\n        ]\n       }\n      ],\n      \"properties\": {\n       \"enableProxyProtocol\": {\n        \"description\": \"enable PROXY protocol for this connection handler.\",\n        \"type\": \"boolean\"\n       },\n       \"httpsRedirect\": {\n        \"description\": \"If set to true, the load balancer will send a 301 redirect for all http connections, asking the clients to use HTTPS.\",\n        \"type\": \"boolean\"\n       },\n       \"sslConfig\": {\n        \"description\": \"Contains the options necessary to configure a virtual host or listener to use TLS\",\n        \"properties\": {\n         \"parameters\": {\n          \"properties\": {\n           \"cipherSuites\": {\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"maximumProtocolVersion\": {\n            \"enum\": [\n             \"TLS_AUTO\",\n             \"TLSv1_0\",\n             \"TLSv1_1\",\n             \"TLSv1_2\",\n             \"TLSv1_3\"\n            ],\n            \"type\": \"string\"\n           },\n           \"minimumProtocolVersion\": {\n            \"enum\": [\n             \"TLS_AUTO\",\n             \"TLSv1_0\",\n             \"TLSv1_1\",\n             \"TLSv1_2\",\n             \"TLSv1_3\"\n            ],\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"secretName\": {\n          \"description\": \"SecretName is the name of the kubernetes secret which contains the ssl secret. Each\\nGateway will look for a secret with this name on it's own local cluster in it's own namespace.\",\n          \"type\": \"string\"\n         },\n         \"sslFiles\": {\n          \"description\": \"SSLFiles reference paths to certificates which can be read by the proxy off of its local filesystem\",\n          \"properties\": {\n           \"rootCa\": {\n            \"description\": \"for client cert validation. optional\",\n            \"type\": \"string\"\n           },\n           \"tlsCert\": {\n            \"type\": \"string\"\n           },\n           \"tlsKey\": {\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"tlsMode\": {\n          \"description\": \"TLS modes enforced by the proxy\",\n          \"enum\": [\n           \"PASSTHROUGH\",\n           \"SIMPLE\",\n           \"MUTUAL\",\n           \"AUTO_PASSTHROUGH\",\n           \"ISTIO_MUTUAL\"\n          ],\n          \"type\": \"string\"\n         },\n         \"verifySubjectAltName\": {\n          \"description\": \"Verify that the Subject Alternative Name in the peer certificate is one of the specified values.\\nnote that a root_ca must be provided if this option is used.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"strictFilterManagement\": {\n        \"description\": \"Restricts filter from being added to the corresponding Envoy Listener unless they are explicitly configured\\nin the connection handler options\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"http\": {\n      \"properties\": {\n       \"routeConfig\": {\n        \"items\": {\n         \"oneOf\": [\n          {\n           \"not\": {\n            \"anyOf\": [\n             {\n              \"required\": [\n               \"virtualHostSelector\"\n              ]\n             },\n             {\n              \"required\": [\n               \"virtualHost\"\n              ]\n             }\n            ]\n           }\n          },\n          {\n           \"required\": [\n            \"virtualHostSelector\"\n           ]\n          },\n          {\n           \"required\": [\n            \"virtualHost\"\n           ]\n          }\n         ],\n         \"properties\": {\n          \"virtualHost\": {\n           \"description\": \"VirtualHost allows in-lining a route table directly in the Gateway Resource, for simple configs using fewer CRDs.\\nNote that Kubernetes admission validation of inline virtual hosts is disabled. For production, the use of `virtualHostSelector` is recommended.\",\n           \"format\": \"textarea\",\n           \"type\": \"string\"\n          },\n          \"virtualHostSelector\": {\n           \"description\": \"RouteSelector is used to specify which VirtualHosts should be attached to this gateway.\",\n           \"properties\": {\n            \"expressions\": {\n             \"description\": \"Expressions allow for more flexible object label matching, such as equality-based requirements, set-based requirements, or a combination of both.\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#equality-based-requirement\",\n             \"items\": {\n              \"properties\": {\n               \"key\": {\n                \"description\": \"Kubernetes label key, must conform to Kubernetes syntax requirements\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set\",\n                \"type\": \"string\"\n               },\n               \"operator\": {\n                \"description\": \"The operator can only be in, notin, =, ==, !=, exists, ! (DoesNotExist), gt (GreaterThan), lt (LessThan).\",\n                \"enum\": [\n                 \"Equals\",\n                 \"DoubleEquals\",\n                 \"NotEquals\",\n                 \"In\",\n                 \"NotIn\",\n                 \"Exists\",\n                 \"DoesNotExist\",\n                 \"GreaterThan\",\n                 \"LessThan\"\n                ],\n                \"type\": \"string\"\n               },\n               \"values\": {\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"type\": \"array\"\n            },\n            \"labels\": {\n             \"additionalProperties\": {\n              \"type\": \"string\"\n             },\n             \"description\": \"Select objects whose labels match the ones specified here.\",\n             \"type\": \"object\"\n            },\n            \"namespaces\": {\n             \"description\": \"Select Objects in these namespaces. If omitted, Gloo Mesh will only select Objects in the same namespace\\nas the parent resource (e.g. VirtualGateway) that owns this selector.\\nThe reserved value \\\"*\\\" can be used to select objects in all namespaces watched by Gloo Mesh.\",\n             \"items\": {\n              \"type\": \"string\"\n             },\n             \"type\": \"array\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       },\n       \"routeOptions\": {\n        \"description\": \"HTTP Listener Options // Root level RouteTable + VirtualHost + routes level\",\n        \"properties\": {\n         \"csrf\": {\n          \"description\": \"Configure Global CSRF options for clients connected to this Gateway.\",\n          \"properties\": {\n           \"additionalOrigins\": {\n            \"description\": \"Specifies additional source origins that will be allowed in addition to\\nthe destination origin.\",\n            \"items\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"exact\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"prefix\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"regex\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"suffix\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"exact\"\n               ]\n              },\n              {\n               \"required\": [\n                \"prefix\"\n               ]\n              },\n              {\n               \"required\": [\n                \"regex\"\n               ]\n              },\n              {\n               \"required\": [\n                \"suffix\"\n               ]\n              }\n             ],\n             \"properties\": {\n              \"exact\": {\n               \"description\": \"Exact string match.\",\n               \"type\": \"string\"\n              },\n              \"ignoreCase\": {\n               \"description\": \"If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the regex match.\",\n               \"type\": \"boolean\"\n              },\n              \"prefix\": {\n               \"description\": \"Prefix-based match.\",\n               \"type\": \"string\"\n              },\n              \"regex\": {\n               \"description\": \"ECMAscript style regex-based match.\",\n               \"type\": \"string\"\n              },\n              \"suffix\": {\n               \"description\": \"Suffix-based match.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"filterEnabled\": {\n            \"description\": \"Specifies that CSRF policies will be evaluated, tracked and enforced.\",\n            \"type\": \"boolean\"\n           },\n           \"percentage\": {\n            \"description\": \"Specifies the % of requests for which the CSRF filter is enabled or when shadow mode is enabled the % of requests\\nevaluated and tracked, but not enforced.\\n\\nIf filter_enabled or shadow_enabled is true.\\nEnvoy will lookup the runtime key to get the percentage of requests to filter.\\n\\n.. note:: This field defaults to 100\",\n            \"format\": \"double\",\n            \"type\": \"number\"\n           },\n           \"shadowEnabled\": {\n            \"description\": \"Specifies that CSRF policies will be evaluated and tracked, but not enforced.\\n\\nThis is intended to be used when ``filter_enabled`` is false and will be ignored otherwise.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"extauth\": {\n          \"description\": \"Configure the Global Extauth options for clients connected to this Gateway\",\n          \"properties\": {\n           \"clearRouteCache\": {\n            \"description\": \"Clears route cache in order to allow the external authorization service to correctly affect\\nrouting decisions. Filter clears all cached routes when:\\n\\n1. The field is set to *true*.\\n\\n2. The status returned from the authorization service is a HTTP 200 or gRPC 0.\\n\\n3. At least one *authorization response header* is added to the client request, or is used for\\naltering another client request header.\",\n            \"type\": \"boolean\"\n           },\n           \"extauthzRef\": {\n            \"description\": \"The destination ref for the envoy external authentication service to ask about auth decisions.\\n\\nThe fqdn used by envoy for extauth requests is derived from the kube service or is the first hostname\\nin an external service destination.\\nIMPORTANT: Envoy's extauth requests go to the port chosen from the destination that has the name or protocol of\\nthe extauth service protocol (i.e., grpc or http). In practice, this means the port handling extauth requests\\nshould be named grpc and/or have protocol GRPC (both case-insensitive), unless `http_service` is configured.\\n\\nThe provided ref will be used to search for a service of the given name/namespace on each cluster\\nthat a Gateway will be created.\\n\\nIf omitted, Gloo Mesh will search for a service with the name ext-auth-service in each namespace on each cluster\\nthat a Gateway will be created.\",\n            \"properties\": {\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"failureModeAllow\": {\n            \"description\": \"In case of a failure or timeout querying the auth server, normally a request is denied.\\nif this is set to true, the request will be allowed.\",\n            \"type\": \"boolean\"\n           },\n           \"httpService\": {\n            \"description\": \"If this is set, communication to the upstream will be via HTTP and not GRPC.\",\n            \"properties\": {\n             \"pathPrefix\": {\n              \"description\": \"Sets a prefix to the value of authorization request header *Path*.\",\n              \"type\": \"string\"\n             },\n             \"request\": {\n              \"properties\": {\n               \"allowedHeaders\": {\n                \"description\": \"These headers will be copied from the incoming request to the request going\\nto the auth server. Note that in addition to the user's supplied matchers:\\n\\n1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.\\n\\n2. *Content-Length* will be set to 0 and the request to the authorization service will not have\\na message body.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\"\n               },\n               \"headersToAdd\": {\n                \"additionalProperties\": {\n                 \"type\": \"string\"\n                },\n                \"description\": \"These headers that will be included to the request to authorization service. Note that\\nclient request of the same key will be overridden.\",\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"response\": {\n              \"properties\": {\n               \"allowedClientHeaders\": {\n                \"description\": \"When this. is set, authorization response headers that will be added to the client's response when auth request is denied.\\nNote that when this list is *not* set, all the authorization response headers, except *Authority\\n(Host)* will be in the response to the client. When a header is included in this list, *Path*,\\n*Status*, *Content-Length*, *WWW-Authenticate* and *Location* are automatically added.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\"\n               },\n               \"allowedUpstreamHeaders\": {\n                \"description\": \"When this is set, authorization response headers that have a will be added to the original client request and sent to the upstream.\\nNote that coexistent headers will be overridden.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\"\n               }\n              },\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"requestBody\": {\n            \"description\": \"Set this if you also want to send the body of the request, and not just the headers.\",\n            \"properties\": {\n             \"allowPartialMessage\": {\n              \"description\": \"When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.\\nThe authorization request will be dispatched and no 413 HTTP error will be returned by the\\nfilter.\",\n              \"type\": \"boolean\"\n             },\n             \"maxRequestBytes\": {\n              \"description\": \"Sets the maximum size of a message body that the filter will hold in memory. Envoy will return\\n*HTTP 413* and will *not* initiate the authorization process when buffer reaches the number\\nset in this field. Note that this setting will have precedence over failure_mode_allow.\\nDefaults to 4KB.\",\n              \"maximum\": 4294967295,\n              \"minimum\": 0,\n              \"type\": \"integer\"\n             },\n             \"packAsBytes\": {\n              \"description\": \"When this field is true, Envoy will send the body sent to the external authorization service with raw bytes.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"requestTimeout\": {\n            \"description\": \"Timeout for the ext auth service to respond. Defaults to 2000ms. (OIDC requests to external IDPs can be slow)\\nFor latency critical applications, this value should be tuned much lower, as extauth is on the request path.\",\n            \"type\": \"string\"\n           },\n           \"statPrefix\": {\n            \"description\": \"Optional additional prefix to use when emitting statistics.\\nThis allows to distinguish emitted statistics between configured ext_authz filters in an HTTP filter chain.\",\n            \"type\": \"string\"\n           },\n           \"statusOnError\": {\n            \"description\": \"Sets the HTTP status that is returned to the client when there is a network error between the\\nfilter and the authorization server. The default status is HTTP 403 Forbidden.\\nIf set, this must be one of the following:\\n- 100\\n- 200 201 202 203 204 205 206 207 208 226\\n- 300 301 302 303 304 305 307 308\\n- 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 421 422 423 424 426 428 429 431\\n- 500 501 502 503 504 505 506 507 508 510 511\",\n            \"maximum\": 4294967295,\n            \"minimum\": 0,\n            \"type\": \"integer\"\n           },\n           \"transportApiVersion\": {\n            \"description\": \"Determines the API version for the `ext_authz` transport protocol that will be used by Envoy\\nto communicate with the auth server. Defaults to `V3`. For more info, see the `transport_api_version` field\\n[here](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto#extensions-filters-http-ext-authz-v3-extauthz).\",\n            \"enum\": [\n             \"GLOO_MESH_AUTO\",\n             \"ENVOY_AUTO\",\n             \"V3\"\n            ],\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"rateLimit\": {\n          \"description\": \"Configure Global Rate limit options for clients connected to this Gateway.\\nRate limits must be configured on specific routes in order to enable rate limiting for a Gateway.\",\n          \"properties\": {\n           \"denyOnFail\": {\n            \"description\": \"Defaults to false\",\n            \"type\": \"boolean\"\n           },\n           \"ratelimitServerRef\": {\n            \"description\": \"The ratelimit service to ask about ratelimit decisions.\\nThe provided ref will be used to search for a service of the given name/namespace on each cluster\\nthat a Gateway will be created.\\n\\nIf omitted, Gloo Mesh will search for a service with the name rate-limiter in each namespace on each cluster\\nthat a Gateway will be created.\",\n            \"properties\": {\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"requestTimeout\": {\n            \"description\": \"Timeout for the ratelimit service to respond. Defaults to 100ms\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"tcp\": {\n      \"properties\": {\n       \"options\": {\n        \"description\": \"TCP Gateway configuration\",\n        \"properties\": {\n         \"tcpProxySettings\": {\n          \"properties\": {\n           \"idleTimeout\": {\n            \"type\": \"string\"\n           },\n           \"maxConnectAttempts\": {\n            \"description\": \"Contains various settings for Envoy's tcp proxy filter.\\nSee here for more information: https://www.envoyproxy.io/docs/envoy/v1.10.0/api-v2/config/filter/network/tcp_proxy/v2/tcp_proxy.proto#envoy-api-msg-config-filter-network-tcp-proxy-v2-tcpproxy\",\n            \"maximum\": 4294967295,\n            \"minimum\": 0,\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"tunnelingConfig\": {\n            \"description\": \"If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP\\npayloads over a shared HTTP tunnel. If this message is absent, the payload\\nwill be proxied upstream as per usual.\",\n            \"properties\": {\n             \"hostname\": {\n              \"description\": \"The hostname to send in the synthesized CONNECT headers to the upstream proxy.\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"tcpHosts\": {\n        \"description\": \"TCP hosts that the gateway can route to\",\n        \"items\": {\n         \"properties\": {\n          \"destination\": {\n           \"oneOf\": [\n            {\n             \"not\": {\n              \"anyOf\": [\n               {\n                \"required\": [\n                 \"static\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"virtual\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"kube\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"forwardSniClusterName\"\n                ]\n               }\n              ]\n             }\n            },\n            {\n             \"required\": [\n              \"static\"\n             ]\n            },\n            {\n             \"required\": [\n              \"virtual\"\n             ]\n            },\n            {\n             \"required\": [\n              \"kube\"\n             ]\n            },\n            {\n             \"required\": [\n              \"forwardSniClusterName\"\n             ]\n            }\n           ],\n           \"properties\": {\n            \"forwardSniClusterName\": {\n             \"description\": \"Forwards the request to a cluster name matching the TLS SNI name\\nhttps://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/network/sni_cluster/empty/sni_cluster\\nNote: This filter will only work properly with TLS connections in which the upstream SNI domain is specified\",\n             \"maxProperties\": 0,\n             \"type\": \"object\"\n            },\n            \"kube\": {\n             \"description\": \"Reference to a Kubernetes Service. Note that the service must exist in the same mesh or virtual mesh (with federation enabled) as\\neach gateway workload which routes to this destination.\",\n             \"properties\": {\n              \"clusterName\": {\n               \"description\": \"name of the cluster in which the resource exists\",\n               \"type\": \"string\"\n              },\n              \"name\": {\n               \"description\": \"name of the resource being referenced\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"namespace of the resource being referenced\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"static\": {\n             \"description\": \"Reference to a gloo mesh Static Destination\",\n             \"properties\": {\n              \"name\": {\n               \"description\": \"name of the resource being referenced\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"namespace of the resource being referenced\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"virtual\": {\n             \"description\": \"Reference to a gloo mesh VirtualDestination\",\n             \"properties\": {\n              \"name\": {\n               \"description\": \"name of the resource being referenced\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"namespace of the resource being referenced\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"weight\": {\n             \"description\": \"Relative weight of this destination to others in the same route.\\nIf omitted, all destinations in the route will be load balanced between evenly.\",\n             \"maximum\": 4294967295,\n             \"minimum\": 0,\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"name\": {\n           \"description\": \"the logical name of the tcp host. names must be unique for each tcp host within a listener\",\n           \"type\": \"string\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"type\": \"object\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"ingressGatewaySelectors\": {\n   \"description\": \"Select the destinations to deploy the gateway to.\",\n   \"items\": {\n    \"properties\": {\n     \"destinationSelectors\": {\n      \"description\": \"The set of Destinations that will be used as ingress gateways for external traffic entering the Mesh.\\nIf omitted, a mesh-specific default ingress gateway destination will be used.\\nFor Istio, any Kubernetes Service(s) with the label pair `{\\\"istio\\\": \\\"ingressgateway\\\"}` will be selected.\",\n      \"items\": {\n       \"properties\": {\n        \"kubeServiceMatcher\": {\n         \"description\": \"Match Kubernetes Services by their labels, namespaces, and/or clusters.\",\n         \"properties\": {\n          \"clusters\": {\n           \"description\": \"If specified, match Kubernetes Services if they exist in one of the specified clusters.\\n           When used in a networking policy, omission matches any cluster.\\n           When used in a Gloo Mesh Role, a wildcard (`\\\"*\\\"`) must be specified to match any cluster.\",\n           \"items\": {\n            \"type\": \"string\"\n           },\n           \"type\": \"array\"\n          },\n          \"labels\": {\n           \"additionalProperties\": {\n            \"type\": \"string\"\n           },\n           \"description\": \"If specified, a match requires all labels to exist on a Kubernetes Service.\\n           When used in a networking policy, omission matches any labels.\\n           When used in a Gloo Mesh Role, a wildcard (`\\\"*\\\"`) must be specified to match any label key and/or value.\",\n           \"type\": \"object\"\n          },\n          \"namespaces\": {\n           \"description\": \"If specified, match Kubernetes Services if they exist in one of the specified namespaces.\\n           When used in a networking policy, omission matches any namespace.\\n           When used in a Gloo Mesh Role, a wildcard (`\\\"*\\\"`) must be specified to match any namespace.\",\n           \"items\": {\n            \"type\": \"string\"\n           },\n           \"type\": \"array\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"kubeServiceRefs\": {\n         \"description\": \"Match Kubernetes Services by direct reference.\",\n         \"properties\": {\n          \"services\": {\n           \"description\": \"Match Kubernetes Services by direct reference. All fields are required.\\n           When used in a Gloo Mesh Role, a wildcard (`\\\"*\\\"`) must be specified to match any value for the given field.\",\n           \"items\": {\n            \"properties\": {\n             \"clusterName\": {\n              \"description\": \"name of the cluster in which the resource exists\",\n              \"type\": \"string\"\n             },\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"type\": \"array\"\n     },\n     \"portName\": {\n      \"description\": \"Specify the name of the port on the ingress gateway service. If not specified, will default to \\\"tls\\\".\",\n      \"type\": \"string\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"options\": {\n   \"description\": \"Options applied to all clients who connect to this gateway\",\n   \"properties\": {\n    \"bindAddress\": {\n     \"description\": \"The bind address the gateway should serve traffic on\\nThis maps to the Envoy Listener address.\\nDefaults to \\\"::\\\" or \\\"0.0.0.0\\\".\",\n     \"type\": \"string\"\n    },\n    \"perConnectionBufferLimitBytes\": {\n     \"description\": \"Soft limit on size of the listener's new connection read and write buffers. If unspecified, defaults to 1MiB\\nFor more info, check out the [Envoy docs](https://www.envoyproxy.io/docs/envoy/v1.17.1/api-v3/config/listener/v3/listener.proto)\",\n     \"maximum\": 4294967295,\n     \"minimum\": 0,\n     \"nullable\": true,\n     \"type\": \"integer\"\n    }\n   },\n   \"type\": \"object\"\n  }\n },\n \"title\": \"Virtual Gateway\",\n \"type\": \"object\"\n}"}