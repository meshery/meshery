{"kind":"Ingress","apiVersion":"networking.internal.knative.dev/v1alpha1","displayName":"Ingress","format":"JSON","metadata":{"genealogy":"","logoURL":"","model":"knative-serving","modelDisplayName":"knative-serving","primaryColor":"#0865ad","published":false,"secondaryColor":"#4DAAF2","shape":"circle","styleOverrides":"","subCategory":"Uncategorized","svgColor":"","svgComplete":"","svgWhite":""},"model":{"name":"knative-serving","version":"1.0.1","displayName":"knative-serving","category":{"name":"Uncategorized","metadata":null},"metadata":null},"schema":"{\n \"description\": \"Spec is the desired state of the Ingress. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\",\n \"properties\": {\n  \"httpOption\": {\n   \"description\": \"HTTPOption is the option of HTTP. It has the following two values: `HTTPOptionEnabled`, `HTTPOptionRedirected`\",\n   \"type\": \"string\"\n  },\n  \"rules\": {\n   \"description\": \"A list of host rules used to configure the Ingress.\",\n   \"items\": {\n    \"description\": \"IngressRule represents the rules mapping the paths under a specified host to the related backend services. Incoming requests are first evaluated for a host match, then routed to the backend associated with the matching IngressRuleValue.\",\n    \"properties\": {\n     \"hosts\": {\n      \"description\": \"Host is the fully qualified domain name of a network host, as defined by RFC 3986. Note the following deviations from the \\\"host\\\" part of the URI as defined in the RFC: 1. IPs are not allowed. Currently a rule value can only apply to the IP in the Spec of the parent . 2. The `:` delimiter is not respected because ports are not allowed. Currently the port of an Ingress is implicitly :80 for http and :443 for https. Both these may change in the future. If the host is unspecified, the Ingress routes all traffic based on the specified IngressRuleValue. If multiple matching Hosts were provided, the first rule will take precedent.\",\n      \"items\": {\n       \"type\": \"string\"\n      },\n      \"type\": \"array\"\n     },\n     \"http\": {\n      \"description\": \"HTTP represents a rule to apply against incoming requests. If the rule is satisfied, the request is routed to the specified backend.\",\n      \"properties\": {\n       \"paths\": {\n        \"description\": \"A collection of paths that map requests to backends. \\n If they are multiple matching paths, the first match takes precedence.\",\n        \"items\": {\n         \"description\": \"HTTPIngressPath associates a path regex with a backend. Incoming URLs matching the path are forwarded to the backend.\",\n         \"properties\": {\n          \"appendHeaders\": {\n           \"additionalProperties\": {\n            \"type\": \"string\"\n           },\n           \"description\": \"AppendHeaders allow specifying additional HTTP headers to add before forwarding a request to the destination service. \\n NOTE: This differs from K8s Ingress which doesn't allow header appending.\",\n           \"type\": \"object\"\n          },\n          \"headers\": {\n           \"additionalProperties\": {\n            \"description\": \"HeaderMatch represents a matching value of Headers in HTTPIngressPath. Currently, only the exact matching is supported.\",\n            \"properties\": {\n             \"exact\": {\n              \"type\": \"string\"\n             }\n            },\n            \"required\": [\n             \"exact\"\n            ],\n            \"type\": \"object\"\n           },\n           \"description\": \"Headers defines header matching rules which is a map from a header name to HeaderMatch which specify a matching condition. When a request matched with all the header matching rules, the request is routed by the corresponding ingress rule. If it is empty, the headers are not used for matching\",\n           \"type\": \"object\"\n          },\n          \"path\": {\n           \"description\": \"Path represents a literal prefix to which this rule should apply. Currently it can contain characters disallowed from the conventional \\\"path\\\" part of a URL as defined by RFC 3986. Paths must begin with a '/'. If unspecified, the path defaults to a catch all sending traffic to the backend.\",\n           \"type\": \"string\"\n          },\n          \"rewriteHost\": {\n           \"description\": \"RewriteHost rewrites the incoming request's host header. \\n This field is currently experimental and not supported by all Ingress implementations.\",\n           \"type\": \"string\"\n          },\n          \"splits\": {\n           \"description\": \"Splits defines the referenced service endpoints to which the traffic will be forwarded to.\",\n           \"items\": {\n            \"description\": \"IngressBackendSplit describes all endpoints for a given service and port.\",\n            \"properties\": {\n             \"appendHeaders\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"AppendHeaders allow specifying additional HTTP headers to add before forwarding a request to the destination service. \\n NOTE: This differs from K8s Ingress which doesn't allow header appending.\",\n              \"type\": \"object\"\n             },\n             \"percent\": {\n              \"description\": \"Specifies the split percentage, a number between 0 and 100.  If only one split is specified, we default to 100. \\n NOTE: This differs from K8s Ingress to allow percentage split.\",\n              \"type\": \"integer\"\n             },\n             \"serviceName\": {\n              \"description\": \"Specifies the name of the referenced service.\",\n              \"type\": \"string\"\n             },\n             \"serviceNamespace\": {\n              \"description\": \"Specifies the namespace of the referenced service. \\n NOTE: This differs from K8s Ingress to allow routing to different namespaces.\",\n              \"type\": \"string\"\n             },\n             \"servicePort\": {\n              \"anyOf\": [\n               {\n                \"type\": \"integer\"\n               },\n               {\n                \"type\": \"string\"\n               }\n              ],\n              \"description\": \"Specifies the port of the referenced service.\",\n              \"x-kubernetes-int-or-string\": true\n             }\n            },\n            \"required\": [\n             \"serviceName\",\n             \"serviceNamespace\",\n             \"servicePort\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          }\n         },\n         \"required\": [\n          \"splits\"\n         ],\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"required\": [\n       \"paths\"\n      ],\n      \"type\": \"object\"\n     },\n     \"visibility\": {\n      \"description\": \"Visibility signifies whether this rule should `ClusterLocal`. If it's not specified then it defaults to `ExternalIP`.\",\n      \"type\": \"string\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"tls\": {\n   \"description\": \"TLS configuration. Currently Ingress only supports a single TLS port: 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI.\",\n   \"items\": {\n    \"description\": \"IngressTLS describes the transport layer security associated with an Ingress.\",\n    \"properties\": {\n     \"hosts\": {\n      \"description\": \"Hosts is a list of hosts included in the TLS certificate. The values in this list must match the name/s used in the tlsSecret. Defaults to the wildcard host setting for the loadbalancer controller fulfilling this Ingress, if left unspecified.\",\n      \"items\": {\n       \"type\": \"string\"\n      },\n      \"type\": \"array\"\n     },\n     \"secretName\": {\n      \"description\": \"SecretName is the name of the secret used to terminate SSL traffic.\",\n      \"type\": \"string\"\n     },\n     \"secretNamespace\": {\n      \"description\": \"SecretNamespace is the namespace of the secret used to terminate SSL traffic. If not set the namespace should be assumed to be the same as the Ingress. If set the secret should have the same namespace as the Ingress otherwise the behaviour is undefined and not supported.\",\n      \"type\": \"string\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  }\n },\n \"title\": \"Ingress\",\n \"type\": \"object\"\n}"}