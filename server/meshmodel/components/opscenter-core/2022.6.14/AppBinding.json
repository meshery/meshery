{"kind":"AppBinding","apiVersion":"v1alpha1","display-name":"App Binding","format":"JSON","metadata":{"logo-URL":"","model":"opscenter-core","model-display-name":"Opscenter Core","primary-color":"","secondary-color":"","shape":"","svg_color":"","svg_white":""},"model":{"name":"opscenter-core","version":"2022.6.14","display-name":"Opscenter Core","category":"Not Found","sub-category":"Not Found"},"schema":"{\n \"description\": \"AppBindingSpec is the spec for app\",\n \"properties\": {\n  \"clientConfig\": {\n   \"description\": \"ClientConfig defines how to communicate with the app. Required\",\n   \"properties\": {\n    \"caBundle\": {\n     \"description\": \"CABundle is a PEM encoded CA bundle which will be used to validate the serving certificate of this app.\",\n     \"format\": \"byte\",\n     \"type\": \"string\"\n    },\n    \"insecureSkipTLSVerify\": {\n     \"description\": \"InsecureSkipTLSVerify disables TLS certificate verification when communicating with this app. This is strongly discouraged.  You should use the CABundle instead.\",\n     \"type\": \"boolean\"\n    },\n    \"serverName\": {\n     \"description\": \"ServerName is used to verify the hostname on the returned certificates unless InsecureSkipVerify is given. It is also included in the client's handshake to support virtual hosting unless it is an IP address.\",\n     \"type\": \"string\"\n    },\n    \"service\": {\n     \"description\": \"`service` is a reference to the service for this app. Either `service` or `url` must be specified. \\n If the webhook is running within the cluster, then you should use `service`.\",\n     \"properties\": {\n      \"name\": {\n       \"description\": \"`name` is the name of the service. Required\",\n       \"type\": \"string\"\n      },\n      \"namespace\": {\n       \"description\": \"`namespace` is the namespace of the service.\",\n       \"type\": \"string\"\n      },\n      \"path\": {\n       \"description\": \"`path` is an optional URL path which will be sent in any request to this service.\",\n       \"type\": \"string\"\n      },\n      \"port\": {\n       \"description\": \"The port that will be exposed by this app.\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"query\": {\n       \"description\": \"`query` is optional encoded query string, without '?' which will be sent in any request to this service.\",\n       \"type\": \"string\"\n      },\n      \"scheme\": {\n       \"description\": \"Specifies which scheme to use, for example: http, https If specified, then it will applied as prefix in this format: scheme:// If not specified, then nothing will be prefixed\",\n       \"type\": \"string\"\n      }\n     },\n     \"required\": [\n      \"name\",\n      \"port\",\n      \"scheme\"\n     ],\n     \"type\": \"object\"\n    },\n    \"url\": {\n     \"description\": \"`url` gives the location of the app, in standard URL form (`[scheme://]host:port/path`). Exactly one of `url` or `service` must be specified. \\n The `host` should not refer to a service running in the cluster; use the `service` field instead. The host might be resolved via external DNS in some apiservers (e.g., `kube-apiserver` cannot resolve in-cluster DNS as that would be a layering violation). `host` may also be an IP address. \\n A path is optional, and if present may be any string permissible in a URL. You may use the path to pass an arbitrary string to the app, for example, a cluster identifier. \\n Attempting to use a user or basic auth e.g. \\\"user:password@\\\" is not allowed. Fragments (\\\"#...\\\") and query parameters (\\\"?...\\\") are not allowed, either.\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"parameters\": {\n   \"description\": \"Parameters is a set of the parameters to be used to connect to the app. The inline YAML/JSON payload to be translated into equivalent JSON object. \\n The Parameters field is NOT secret or secured in any way and should NEVER be used to hold sensitive information. To set parameters that contain secret information, you should ALWAYS store that information in a Secret.\",\n   \"type\": \"object\",\n   \"x-kubernetes-embedded-resource\": true,\n   \"x-kubernetes-preserve-unknown-fields\": true\n  },\n  \"secret\": {\n   \"description\": \"Secret is the name of the secret to create in the AppBinding's namespace that will hold the credentials associated with the AppBinding.\",\n   \"properties\": {\n    \"name\": {\n     \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"secretTransforms\": {\n   \"description\": \"List of transformations that should be applied to the credentials associated with the ServiceBinding before they are inserted into the Secret.\",\n   \"items\": {\n    \"description\": \"SecretTransform is a single transformation that is applied to the credentials returned from the broker before they are inserted into the Secret associated with the ServiceBinding. Because different brokers providing the same type of service may each return a different credentials structure, users can specify the transformations that should be applied to the Secret to adapt its entries to whatever the service consumer expects. For example, the credentials returned by the broker may include the key \\\"USERNAME\\\", but the consumer requires the username to be exposed under the key \\\"DB_USER\\\" instead. To have the Service Catalog transform the Secret, the following SecretTransform must be specified in ServiceBinding.spec.secretTransform: - {\\\"renameKey\\\": {\\\"from\\\": \\\"USERNAME\\\", \\\"to\\\": \\\"DB_USER\\\"}} Only one of the SecretTransform's members may be specified.\",\n    \"properties\": {\n     \"addKey\": {\n      \"description\": \"AddKey represents a transform that adds an additional key to the credentials Secret\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The name of the key to add\",\n        \"type\": \"string\"\n       },\n       \"stringValue\": {\n        \"description\": \"The string (non-binary) value to add to the Secret under the specified key.\",\n        \"type\": \"string\"\n       },\n       \"value\": {\n        \"description\": \"The binary value (possibly non-string) to add to the Secret under the specified key. If both value and stringValue are specified, then value is ignored and stringValue is stored.\",\n        \"format\": \"byte\",\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\"\n     },\n     \"addKeysFrom\": {\n      \"description\": \"AddKeysFrom represents a transform that merges all the entries of an existing Secret into the credentials Secret\",\n      \"properties\": {\n       \"secretRef\": {\n        \"description\": \"The reference to the Secret that should be merged into the credentials Secret.\",\n        \"properties\": {\n         \"name\": {\n          \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"removeKey\": {\n      \"description\": \"RemoveKey represents a transform that removes a credentials Secret entry\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key to remove from the Secret\",\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\"\n     },\n     \"renameKey\": {\n      \"description\": \"RenameKey represents a transform that renames a credentials Secret entry's key\",\n      \"properties\": {\n       \"from\": {\n        \"description\": \"The name of the key to rename\",\n        \"type\": \"string\"\n       },\n       \"to\": {\n        \"description\": \"The new name for the key\",\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"from\",\n       \"to\"\n      ],\n      \"type\": \"object\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"tlsSecret\": {\n   \"description\": \"TLSSecret is the name of the secret that will hold the client certificate and private key associated with the AppBinding.\",\n   \"properties\": {\n    \"name\": {\n     \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"type\": {\n   \"description\": \"Type used to facilitate programmatic handling of application.\",\n   \"type\": \"string\"\n  },\n  \"version\": {\n   \"description\": \"Version used to facilitate programmatic handling of application.\",\n   \"type\": \"string\"\n  }\n },\n \"required\": [\n  \"clientConfig\"\n ],\n \"title\": \"App Binding\",\n \"type\": \"object\"\n}"}