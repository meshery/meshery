{"kind":"SidecarSet","apiVersion":"apps.kruise.io/v1alpha1","displayName":"Sidecar Set","format":"JSON","metadata":{"genealogy":"","logoURL":"","model":"contrail-analytics","modelDisplayName":"Contrail Analytics","primaryColor":"#00B39F","published":false,"secondaryColor":"#00D3A9","shape":"circle","styleOverrides":"","subCategory":"Not Found","svgColor":"","svgComplete":"","svgWhite":""},"model":{"name":"contrail-analytics","version":"22.2.0-rev0bb9dbbd1","displayName":"Contrail Analytics","category":{"name":"Cloud Native Network","metadata":null},"metadata":null},"schema":"{\n \"description\": \"SidecarSetSpec defines the desired state of SidecarSet\",\n \"properties\": {\n  \"containers\": {\n   \"description\": \"Containers is the list of sidecar containers to be injected into the selected pod\",\n   \"items\": {\n    \"description\": \"SidecarContainer defines the container of Sidecar\",\n    \"properties\": {\n     \"podInjectPolicy\": {\n      \"description\": \"The rules that injected SidecarContainer into Pod.spec.containers, not takes effect in initContainers If BeforeAppContainer, the SidecarContainer will be injected in front of the pod.spec.containers otherwise it will be injected into the back. default BeforeAppContainerType\",\n      \"type\": \"string\"\n     },\n     \"shareVolumePolicy\": {\n      \"description\": \"If ShareVolumePolicy is enabled, the sidecar container will share the other container's VolumeMounts in the pod(don't contains the injected sidecar container).\",\n      \"properties\": {\n       \"type\": {\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"transferEnv\": {\n      \"description\": \"TransferEnv will transfer env info from other container SourceContainerName is pod.spec.container[x].name; EnvName is pod.spec.container[x].Env.name\",\n      \"items\": {\n       \"properties\": {\n        \"envName\": {\n         \"type\": \"string\"\n        },\n        \"envNames\": {\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"sourceContainerName\": {\n         \"type\": \"string\"\n        },\n        \"sourceContainerNameFrom\": {\n         \"properties\": {\n          \"fieldRef\": {\n           \"description\": \"Selects a field of the pod: supports metadata.name, `metadata.labels['\\u003cKEY\\u003e']`, `metadata.annotations['\\u003cKEY\\u003e']`,\",\n           \"properties\": {\n            \"apiVersion\": {\n             \"description\": \"Version of the schema the FieldPath is written in terms of, defaults to \\\"v1\\\".\",\n             \"type\": \"string\"\n            },\n            \"fieldPath\": {\n             \"description\": \"Path of the field to select in the specified API version.\",\n             \"type\": \"string\"\n            }\n           },\n           \"required\": [\n            \"fieldPath\"\n           ],\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"type\": \"array\"\n     },\n     \"upgradeStrategy\": {\n      \"description\": \"sidecarContainer upgrade strategy, include: ColdUpgrade, HotUpgrade\",\n      \"properties\": {\n       \"hotUpgradeEmptyImage\": {\n        \"description\": \"when HotUpgrade, HotUpgradeEmptyImage is used to complete the hot upgrading process HotUpgradeEmptyImage is consistent of sidecar container in Command, Args, Liveness probe, etc. but it does no actual work.\",\n        \"type\": \"string\"\n       },\n       \"upgradeType\": {\n        \"description\": \"when sidecar container is stateless, use ColdUpgrade otherwise HotUpgrade are more HotUpgrade. examples for istio envoy container is suitable for HotUpgrade default is ColdUpgrade\",\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     }\n    },\n    \"type\": \"object\",\n    \"x-kubernetes-preserve-unknown-fields\": true\n   },\n   \"type\": \"array\"\n  },\n  \"imagePullSecrets\": {\n   \"description\": \"List of the names of secrets required by pulling sidecar container images\",\n   \"items\": {\n    \"description\": \"LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.\",\n    \"properties\": {\n     \"name\": {\n      \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n      \"type\": \"string\"\n     }\n    },\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"initContainers\": {\n   \"description\": \"InitContainers is the list of init containers to be injected into the selected pod We will inject those containers by their name in ascending order We only inject init containers when a new pod is created, it does not apply to any existing pod\",\n   \"items\": {\n    \"description\": \"SidecarContainer defines the container of Sidecar\",\n    \"properties\": {\n     \"podInjectPolicy\": {\n      \"description\": \"The rules that injected SidecarContainer into Pod.spec.containers, not takes effect in initContainers If BeforeAppContainer, the SidecarContainer will be injected in front of the pod.spec.containers otherwise it will be injected into the back. default BeforeAppContainerType\",\n      \"type\": \"string\"\n     },\n     \"shareVolumePolicy\": {\n      \"description\": \"If ShareVolumePolicy is enabled, the sidecar container will share the other container's VolumeMounts in the pod(don't contains the injected sidecar container).\",\n      \"properties\": {\n       \"type\": {\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"transferEnv\": {\n      \"description\": \"TransferEnv will transfer env info from other container SourceContainerName is pod.spec.container[x].name; EnvName is pod.spec.container[x].Env.name\",\n      \"items\": {\n       \"properties\": {\n        \"envName\": {\n         \"type\": \"string\"\n        },\n        \"envNames\": {\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"sourceContainerName\": {\n         \"type\": \"string\"\n        },\n        \"sourceContainerNameFrom\": {\n         \"properties\": {\n          \"fieldRef\": {\n           \"description\": \"Selects a field of the pod: supports metadata.name, `metadata.labels['\\u003cKEY\\u003e']`, `metadata.annotations['\\u003cKEY\\u003e']`,\",\n           \"properties\": {\n            \"apiVersion\": {\n             \"description\": \"Version of the schema the FieldPath is written in terms of, defaults to \\\"v1\\\".\",\n             \"type\": \"string\"\n            },\n            \"fieldPath\": {\n             \"description\": \"Path of the field to select in the specified API version.\",\n             \"type\": \"string\"\n            }\n           },\n           \"required\": [\n            \"fieldPath\"\n           ],\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"type\": \"array\"\n     },\n     \"upgradeStrategy\": {\n      \"description\": \"sidecarContainer upgrade strategy, include: ColdUpgrade, HotUpgrade\",\n      \"properties\": {\n       \"hotUpgradeEmptyImage\": {\n        \"description\": \"when HotUpgrade, HotUpgradeEmptyImage is used to complete the hot upgrading process HotUpgradeEmptyImage is consistent of sidecar container in Command, Args, Liveness probe, etc. but it does no actual work.\",\n        \"type\": \"string\"\n       },\n       \"upgradeType\": {\n        \"description\": \"when sidecar container is stateless, use ColdUpgrade otherwise HotUpgrade are more HotUpgrade. examples for istio envoy container is suitable for HotUpgrade default is ColdUpgrade\",\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     }\n    },\n    \"type\": \"object\",\n    \"x-kubernetes-preserve-unknown-fields\": true\n   },\n   \"type\": \"array\"\n  },\n  \"injectionStrategy\": {\n   \"description\": \"InjectionStrategy describe the strategy when sidecarset is injected into pods\",\n   \"properties\": {\n    \"paused\": {\n     \"description\": \"Paused indicates that SidecarSet will suspend injection into Pods If Paused is true, the sidecarSet will not be injected to newly created Pods, but the injected sidecar container remains updating and running. default is false\",\n     \"type\": \"boolean\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"namespace\": {\n   \"description\": \"Namespace sidecarSet will only match the pods in the namespace otherwise, match pods in all namespaces(in cluster)\",\n   \"type\": \"string\"\n  },\n  \"revisionHistoryLimit\": {\n   \"description\": \"RevisionHistoryLimit indicates the maximum quantity of stored revisions about the SidecarSet. default value is 10\",\n   \"format\": \"int32\",\n   \"type\": \"integer\"\n  },\n  \"selector\": {\n   \"description\": \"selector is a label query over pods that should be injected\",\n   \"properties\": {\n    \"matchExpressions\": {\n     \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n     \"items\": {\n      \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"key is the label key that the selector applies to.\",\n        \"type\": \"string\"\n       },\n       \"operator\": {\n        \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n        \"type\": \"string\"\n       },\n       \"values\": {\n        \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"required\": [\n       \"key\",\n       \"operator\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"matchLabels\": {\n     \"additionalProperties\": {\n      \"type\": \"string\"\n     },\n     \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"updateStrategy\": {\n   \"description\": \"The sidecarset updateStrategy to use to replace existing pods with new ones.\",\n   \"properties\": {\n    \"maxUnavailable\": {\n     \"anyOf\": [\n      {\n       \"type\": \"integer\"\n      },\n      {\n       \"type\": \"string\"\n      }\n     ],\n     \"description\": \"The maximum number of SidecarSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of SidecarSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1.\",\n     \"x-kubernetes-int-or-string\": true\n    },\n    \"partition\": {\n     \"anyOf\": [\n      {\n       \"type\": \"integer\"\n      },\n      {\n       \"type\": \"string\"\n      }\n     ],\n     \"description\": \"Partition is the desired number of pods in old revisions. It means when partition is set during pods updating, (replicas - partition) number of pods will be updated. Default value is 0.\",\n     \"x-kubernetes-int-or-string\": true\n    },\n    \"paused\": {\n     \"description\": \"Paused indicates that the SidecarSet is paused to update the injected pods, but it don't affect the webhook inject sidecar container into the newly created pods. default is false\",\n     \"type\": \"boolean\"\n    },\n    \"scatterStrategy\": {\n     \"description\": \"ScatterStrategy defines the scatter rules to make pods been scattered when update. This will avoid pods with the same key-value to be updated in one batch. - Note that pods will be scattered after priority sort. So, although priority strategy and scatter strategy can be applied together, we suggest to use either one of them. - If scatterStrategy is used, we suggest to just use one term. Otherwise, the update order can be hard to understand.\",\n     \"items\": {\n      \"properties\": {\n       \"key\": {\n        \"type\": \"string\"\n       },\n       \"value\": {\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"key\",\n       \"value\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"selector\": {\n     \"description\": \"If selector is not nil, this upgrade will only update the selected pods.\",\n     \"properties\": {\n      \"matchExpressions\": {\n       \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n       \"items\": {\n        \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n        \"properties\": {\n         \"key\": {\n          \"description\": \"key is the label key that the selector applies to.\",\n          \"type\": \"string\"\n         },\n         \"operator\": {\n          \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n          \"type\": \"string\"\n         },\n         \"values\": {\n          \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         }\n        },\n        \"required\": [\n         \"key\",\n         \"operator\"\n        ],\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"matchLabels\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"type\": {\n     \"description\": \"Type is NotUpdate, the SidecarSet don't update the injected pods, it will only inject sidecar container into the newly created pods. Type is RollingUpdate, the SidecarSet will update the injected pods to the latest version on RollingUpdate Strategy. default is RollingUpdate\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"volumes\": {\n   \"description\": \"List of volumes that can be mounted by sidecar containers\",\n   \"x-kubernetes-preserve-unknown-fields\": true\n  }\n },\n \"title\": \"Sidecar Set\",\n \"type\": \"object\"\n}"}