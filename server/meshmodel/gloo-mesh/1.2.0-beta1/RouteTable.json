{"kind":"RouteTable","apiVersion":"networking.enterprise.mesh.gloo.solo.io/v1beta1","displayName":"Route Table","format":"JSON","metadata":{"genealogy":"","isNamespaced":true,"logoURL":"","model":"gloo-mesh","modelDisplayName":"gloo-mesh","primaryColor":"#00B39F","published":false,"secondaryColor":"#00D3A9","shape":"circle","styleOverrides":"","subCategory":"Uncategorized","svgColor":"","svgComplete":"","svgWhite":""},"model":{"name":"gloo-mesh","version":"1.2.0-beta1","displayName":"gloo-mesh","category":{"name":"Uncategorized","metadata":null},"metadata":{"source_uri":"https://storage.googleapis.com/gloo-mesh/gloo-mesh/gloo-mesh-1.2.0-beta1.tgz"}},"schema":"{\n \"properties\": {\n  \"spec\": {\n   \"description\": \"RouteTable is a resource which can be referenced either from the top level VirtualHost resource, or from\\n   other RouteTables. It's primary use is to organizationally and logically separate the configuration of Routes,\\n   so that the responsibilities of Route configuration and maintenance can be divided between teams where appropriate.\",\n   \"properties\": {\n    \"routes\": {\n     \"description\": \"The list of HTTP Routes define routing actions to be taken for incoming HTTP requests whose host header matches\\nthis virtual host. If the request matches more than one Route in the list, the first Route matched will be selected.\\nIf the list of Routes is empty, the virtual host will be ignored by Gloo.\",\n     \"items\": {\n      \"oneOf\": [\n       {\n        \"not\": {\n         \"anyOf\": [\n          {\n           \"required\": [\n            \"routeAction\"\n           ]\n          },\n          {\n           \"properties\": {\n            \"redirectAction\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"pathRedirect\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"prefixRewrite\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"pathRedirect\"\n               ]\n              },\n              {\n               \"required\": [\n                \"prefixRewrite\"\n               ]\n              }\n             ]\n            }\n           },\n           \"required\": [\n            \"redirectAction\"\n           ]\n          },\n          {\n           \"required\": [\n            \"directResponseAction\"\n           ]\n          },\n          {\n           \"required\": [\n            \"delegateAction\"\n           ]\n          }\n         ]\n        }\n       },\n       {\n        \"required\": [\n         \"routeAction\"\n        ]\n       },\n       {\n        \"properties\": {\n         \"redirectAction\": {\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"pathRedirect\"\n               ]\n              },\n              {\n               \"required\": [\n                \"prefixRewrite\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"pathRedirect\"\n            ]\n           },\n           {\n            \"required\": [\n             \"prefixRewrite\"\n            ]\n           }\n          ]\n         }\n        },\n        \"required\": [\n         \"redirectAction\"\n        ]\n       },\n       {\n        \"required\": [\n         \"directResponseAction\"\n        ]\n       },\n       {\n        \"required\": [\n         \"delegateAction\"\n        ]\n       }\n      ],\n      \"properties\": {\n       \"delegateAction\": {\n        \"description\": \"Delegate routing actions for the given matcher to one or more RouteTables.\",\n        \"properties\": {\n         \"refs\": {\n          \"description\": \"Delegate to the RouteTable resources with matching `name` and `namespace`.\",\n          \"items\": {\n           \"properties\": {\n            \"name\": {\n             \"description\": \"name of the resource being referenced\",\n             \"type\": \"string\"\n            },\n            \"namespace\": {\n             \"description\": \"namespace of the resource being referenced\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"type\": \"array\"\n         },\n         \"selector\": {\n          \"description\": \"Delegate to the RouteTables that match the given selector.\\nSelected route tables are ordered by creation time stamp in ascending order to guarantee consistent ordering.\",\n          \"properties\": {\n           \"expressions\": {\n            \"description\": \"Expressions allow for more flexible object label matching, such as equality-based requirements, set-based requirements, or a combination of both.\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#equality-based-requirement\",\n            \"items\": {\n             \"properties\": {\n              \"key\": {\n               \"description\": \"Kubernetes label key, must conform to Kubernetes syntax requirements\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set\",\n               \"type\": \"string\"\n              },\n              \"operator\": {\n               \"description\": \"The operator can only be in, notin, =, ==, !=, exists, ! (DoesNotExist), gt (GreaterThan), lt (LessThan).\",\n               \"enum\": [\n                \"Equals\",\n                \"DoubleEquals\",\n                \"NotEquals\",\n                \"In\",\n                \"NotIn\",\n                \"Exists\",\n                \"DoesNotExist\",\n                \"GreaterThan\",\n                \"LessThan\"\n               ],\n               \"type\": \"string\"\n              },\n              \"values\": {\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"labels\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"Select objects whose labels match the ones specified here.\",\n            \"type\": \"object\"\n           },\n           \"namespaces\": {\n            \"description\": \"Select Objects in these namespaces. If omitted, Gloo Mesh will only select Objects in the same namespace\\nas the parent resource (e.g. VirtualGateway) that owns this selector.\\nThe reserved value \\\"*\\\" can be used to select objects in all namespaces watched by Gloo Mesh.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"sortMethod\": {\n          \"description\": \"How routes should be sorted\",\n          \"enum\": [\n           \"TABLE_WEIGHT\",\n           \"ROUTE_SPECIFICITY\"\n          ],\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"directResponseAction\": {\n        \"description\": \"Return an arbitrary HTTP response directly, without proxying.\",\n        \"properties\": {\n         \"body\": {\n          \"description\": \"Specifies the content of the response body. If this setting is omitted,\\nno body is included in the generated response.\\n\\nNote: Headers can be specified using the Header Modification feature in the enclosing\\nRoute, ConnectionHandler, or Gateway options.\",\n          \"type\": \"string\"\n         },\n         \"status\": {\n          \"description\": \"Specifies the HTTP response status to be returned.\",\n          \"maximum\": 4294967295,\n          \"minimum\": 0,\n          \"type\": \"integer\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"labels\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Specify labels for this route, which are used by other resources (e.g. TrafficPolicy) to\\nselect specific routes within a given gateway object.\",\n        \"type\": \"object\"\n       },\n       \"matchers\": {\n        \"description\": \"Matchers contain parameters for matching requests (i.e., based on HTTP path, headers, etc.).\\nIf empty, the route will match all requests (i.e, a single \\\"/\\\" path prefix matcher).\\nFor delegated routes, any parent matcher must have a `prefix` path matcher.\",\n        \"items\": {\n         \"properties\": {\n          \"headers\": {\n           \"description\": \"Specify a set of headers which requests must match in entirety (all headers must match).\",\n           \"items\": {\n            \"properties\": {\n             \"invertMatch\": {\n              \"description\": \"If set to true, the result of the match will be inverted. Defaults to false.\\n\\n   Examples:\\n\\n       - name=foo, invert_match=true: matches if no header named `foo` is present\\n       - name=foo, value=bar, invert_match=true: matches if no header named `foo` with value `bar` is present\\n       - name=foo, value=``\\\\d{3}``, regex=true, invert_match=true: matches if no header named `foo` with a value consisting of three integers is present.\",\n              \"type\": \"boolean\"\n             },\n             \"name\": {\n              \"description\": \"Specify the name of the header in the request.\",\n              \"type\": \"string\"\n             },\n             \"regex\": {\n              \"description\": \"Specify whether the header value should be treated as regex.\",\n              \"type\": \"boolean\"\n             },\n             \"value\": {\n              \"description\": \"Specify the value of the header. If the value is absent a request that\\nhas the name header will match, regardless of the header’s value.\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          },\n          \"method\": {\n           \"description\": \"Specify an HTTP method to match against.\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"The name assigned to a match. The match's name will be\\nconcatenated with the parent route's name and will be logged in\\nthe access logs for requests matching this route.\",\n           \"type\": \"string\"\n          },\n          \"queryParameters\": {\n           \"description\": \"Specify a set of URL query parameters which requests must match in entirety (all query params must match).\",\n           \"items\": {\n            \"properties\": {\n             \"name\": {\n              \"description\": \"Specify the name of a key that must be present in the requested path's query string.\",\n              \"type\": \"string\"\n             },\n             \"regex\": {\n              \"description\": \"If true, treat `value` as a regular expression.\",\n              \"type\": \"boolean\"\n             },\n             \"value\": {\n              \"description\": \"Specify the value of the query parameter keyed on `name`.\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          },\n          \"uri\": {\n           \"description\": \"Specify match criteria against the targeted path.\",\n           \"oneOf\": [\n            {\n             \"not\": {\n              \"anyOf\": [\n               {\n                \"required\": [\n                 \"exact\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"prefix\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"regex\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"suffix\"\n                ]\n               }\n              ]\n             }\n            },\n            {\n             \"required\": [\n              \"exact\"\n             ]\n            },\n            {\n             \"required\": [\n              \"prefix\"\n             ]\n            },\n            {\n             \"required\": [\n              \"regex\"\n             ]\n            },\n            {\n             \"required\": [\n              \"suffix\"\n             ]\n            }\n           ],\n           \"properties\": {\n            \"exact\": {\n             \"description\": \"Exact string match.\",\n             \"type\": \"string\"\n            },\n            \"ignoreCase\": {\n             \"description\": \"If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the regex match.\",\n             \"type\": \"boolean\"\n            },\n            \"prefix\": {\n             \"description\": \"Prefix-based match.\",\n             \"type\": \"string\"\n            },\n            \"regex\": {\n             \"description\": \"ECMAscript style regex-based match.\",\n             \"type\": \"string\"\n            },\n            \"suffix\": {\n             \"description\": \"Suffix-based match.\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       },\n       \"name\": {\n        \"description\": \"The name provides a convenience for users to be able to refer to a route by name.\\nIt includes names of VS, Route, and RouteTable ancestors of the Route.\",\n        \"type\": \"string\"\n       },\n       \"options\": {\n        \"description\": \"Route Options extend the behavior of routes.\\nRoute options include configuration such as retries, rate limiting, and request/response transformation.\\nRouteOption behavior will be inherited by delegated routes which do not specify their own `options`\",\n        \"properties\": {\n         \"corsPolicy\": {\n          \"description\": \"Set a Cross-Origin Resource Sharing policy (CORS) for requests. Refer to [this link](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS)\\nfor further details about cross origin resource sharing.\",\n          \"properties\": {\n           \"allowCredentials\": {\n            \"description\": \"Indicates whether the caller is allowed to send the actual request\\n(not the preflight) using credentials. Translates to the\\n`Access-Control-Allow-Credentials` header.\",\n            \"nullable\": true,\n            \"type\": \"boolean\"\n           },\n           \"allowHeaders\": {\n            \"description\": \"List of HTTP headers that can be used when requesting the\\nresource. Serialized to the `Access-Control-Allow-Headers` header.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"allowMethods\": {\n            \"description\": \"List of HTTP methods allowed to access the resource. The content will\\nbe serialized to the `Access-Control-Allow-Methods` header.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"allowOrigins\": {\n            \"description\": \"String patterns that match allowed origins. An origin is allowed if any of the string matchers match.\",\n            \"items\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"exact\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"prefix\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"regex\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"suffix\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"exact\"\n               ]\n              },\n              {\n               \"required\": [\n                \"prefix\"\n               ]\n              },\n              {\n               \"required\": [\n                \"regex\"\n               ]\n              },\n              {\n               \"required\": [\n                \"suffix\"\n               ]\n              }\n             ],\n             \"properties\": {\n              \"exact\": {\n               \"description\": \"Exact string match.\",\n               \"type\": \"string\"\n              },\n              \"ignoreCase\": {\n               \"description\": \"If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the regex match.\",\n               \"type\": \"boolean\"\n              },\n              \"prefix\": {\n               \"description\": \"Prefix-based match.\",\n               \"type\": \"string\"\n              },\n              \"regex\": {\n               \"description\": \"ECMAscript style regex-based match.\",\n               \"type\": \"string\"\n              },\n              \"suffix\": {\n               \"description\": \"Suffix-based match.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"exposeHeaders\": {\n            \"description\": \"A list of HTTP headers that browsers are allowed to\\naccess. Serialized to the `Access-Control-Expose-Headers` header.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"maxAge\": {\n            \"description\": \"Specify how long the results of a preflight request can be\\ncached. Serialized to the `Access-Control-Max-Age` header.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"csrf\": {\n          \"description\": \"Configure the Envoy based CSRF filter\",\n          \"properties\": {\n           \"additionalOrigins\": {\n            \"description\": \"Specifies additional source origins that will be allowed in addition to\\nthe destination origin.\",\n            \"items\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"exact\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"prefix\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"regex\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"suffix\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"exact\"\n               ]\n              },\n              {\n               \"required\": [\n                \"prefix\"\n               ]\n              },\n              {\n               \"required\": [\n                \"regex\"\n               ]\n              },\n              {\n               \"required\": [\n                \"suffix\"\n               ]\n              }\n             ],\n             \"properties\": {\n              \"exact\": {\n               \"description\": \"Exact string match.\",\n               \"type\": \"string\"\n              },\n              \"ignoreCase\": {\n               \"description\": \"If true, indicates the exact/prefix/suffix matching should be case insensitive. This has no effect for the regex match.\",\n               \"type\": \"boolean\"\n              },\n              \"prefix\": {\n               \"description\": \"Prefix-based match.\",\n               \"type\": \"string\"\n              },\n              \"regex\": {\n               \"description\": \"ECMAscript style regex-based match.\",\n               \"type\": \"string\"\n              },\n              \"suffix\": {\n               \"description\": \"Suffix-based match.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"filterEnabled\": {\n            \"description\": \"Specifies that CSRF policies will be evaluated, tracked and enforced.\",\n            \"type\": \"boolean\"\n           },\n           \"percentage\": {\n            \"description\": \"Specifies the % of requests for which the CSRF filter is enabled or when shadow mode is enabled the % of requests\\nevaluated and tracked, but not enforced.\\n\\nIf filter_enabled or shadow_enabled is true.\\nEnvoy will lookup the runtime key to get the percentage of requests to filter.\\n\\n.. note:: This field defaults to 100\",\n            \"format\": \"double\",\n            \"type\": \"number\"\n           },\n           \"shadowEnabled\": {\n            \"description\": \"Specifies that CSRF policies will be evaluated and tracked, but not enforced.\\n\\nThis is intended to be used when ``filter_enabled`` is false and will be ignored otherwise.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"extauth\": {\n          \"description\": \"Configure the Envoy based Extauth filter\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"disable\"\n               ]\n              },\n              {\n               \"required\": [\n                \"configRef\"\n               ]\n              },\n              {\n               \"required\": [\n                \"customAuth\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"disable\"\n            ]\n           },\n           {\n            \"required\": [\n             \"configRef\"\n            ]\n           },\n           {\n            \"required\": [\n             \"customAuth\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"configRef\": {\n            \"description\": \"A reference to an AuthConfig. This is used to configure the mesh clients to identify themselves by\\nmatching their client identifier to the extauth server config for the same AuthConfig.\",\n            \"properties\": {\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"customAuth\": {\n            \"description\": \"Use this field if you are running your own custom extauth server.\",\n            \"properties\": {\n             \"contextExtensions\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"When a request matches the route or traffic policy on which this configuration is defined,\\nGloo Mesh will add the given context_extensions to the request that is sent to the external authorization server.\\nThis allows the server to base the auth decision on metadata that you define on the source of the request.\\n\\nThis attribute is analogous to Envoy's config.filter.http.ext_authz.v2.CheckSettings. See the official\\n[Envoy documentation](https://www.envoyproxy.io/docs/envoy/latest/api-v2/config/filter/http/ext_authz/v2/ext_authz.proto.html?highlight=ext_authz#config-filter-http-ext-authz-v2-checksettings)\\nfor more details.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"disable\": {\n            \"description\": \"Set to true to disable auth on the route.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"faultInjection\": {\n          \"description\": \"Inject faulty responses.\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"fixedDelay\"\n               ]\n              },\n              {\n               \"required\": [\n                \"abort\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"fixedDelay\"\n            ]\n           },\n           {\n            \"required\": [\n             \"abort\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"abort\": {\n            \"description\": \"Abort the request and return the specified error code back to traffic source.\",\n            \"properties\": {\n             \"httpStatus\": {\n              \"description\": \"Required. HTTP status code to use to abort the request.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"fixedDelay\": {\n            \"description\": \"Add a delay of a fixed duration before sending the request. Format: `1h`/`1m`/`1s`/`1ms`. MUST be \\u003e=1ms.\",\n            \"type\": \"string\"\n           },\n           \"percentage\": {\n            \"description\": \"Percentage of requests to be faulted. Values range between 0 and 100. If omitted all requests will be faulted.\",\n            \"format\": \"double\",\n            \"type\": \"number\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"headerManipulation\": {\n          \"description\": \"Manipulate request and response headers.\",\n          \"properties\": {\n           \"appendRequestHeaders\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"Additional HTTP headers to add before forwarding a request to the destination service.\",\n            \"type\": \"object\"\n           },\n           \"appendResponseHeaders\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"Additional HTTP headers to add before returning a response to the caller.\",\n            \"type\": \"object\"\n           },\n           \"removeRequestHeaders\": {\n            \"description\": \"HTTP headers to remove before forwarding a request to the destination service.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"removeResponseHeaders\": {\n            \"description\": \"HTTP headers to remove before returning a response to the caller.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"mirror\": {\n          \"description\": \"Mirror traffic to a another destination (traffic will be sent to its original destination in addition to the mirrored destinations).\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"kubeService\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"kubeService\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"kubeService\": {\n            \"description\": \"Reference (name, namespace, Gloo Mesh cluster) to a Kubernetes service.\",\n            \"properties\": {\n             \"clusterName\": {\n              \"description\": \"name of the cluster in which the resource exists\",\n              \"type\": \"string\"\n             },\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"percentage\": {\n            \"description\": \"Percentage of traffic to mirror. If omitted all traffic will be mirrored. Values must be between 0 and 100.\",\n            \"format\": \"double\",\n            \"type\": \"number\"\n           },\n           \"port\": {\n            \"description\": \"Port on the destination to receive traffic. Required if the destination exposes multiple ports.\",\n            \"maximum\": 4294967295,\n            \"minimum\": 0,\n            \"type\": \"integer\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"mtls\": {\n          \"description\": \"Configure mTLS settings. If specified will override global default defined in Settings.\",\n          \"properties\": {\n           \"istio\": {\n            \"description\": \"Istio TLS settings.\",\n            \"properties\": {\n             \"tlsMode\": {\n              \"description\": \"TLS connection mode\",\n              \"enum\": [\n               \"DISABLE\",\n               \"SIMPLE\",\n               \"ISTIO_MUTUAL\"\n              ],\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"outlierDetection\": {\n          \"description\": \"Configure [outlier detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier) on the selected destinations.\\nSpecifying this field requires an empty `source_selector` because it must apply to all traffic.\",\n          \"properties\": {\n           \"baseEjectionTime\": {\n            \"description\": \"The minimum ejection duration. Format: `1h`/`1m`/`1s`/`1ms`. Must be \\u003e= `1ms`. A default will be used if not set.\",\n            \"type\": \"string\"\n           },\n           \"consecutiveErrors\": {\n            \"description\": \"The number of errors before a host is ejected from the connection pool. A default will be used if not set.\",\n            \"maximum\": 4294967295,\n            \"minimum\": 0,\n            \"type\": \"integer\"\n           },\n           \"interval\": {\n            \"description\": \"The time interval between ejection sweep analysis. Format: `1h`/`1m`/`1s`/`1ms`. Must be \\u003e= `1ms`. A default will be used if not set.\",\n            \"type\": \"string\"\n           },\n           \"maxEjectionPercent\": {\n            \"description\": \"The maximum percentage of hosts that can be ejected from the load balancing pool.\\nAt least one host will be ejected regardless of the value. Must be between 0 and 100. A default will be used if not set.\",\n            \"maximum\": 4294967295,\n            \"minimum\": 0,\n            \"type\": \"integer\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"rateLimit\": {\n          \"description\": \"Configure the Envoy based Ratelimit filter\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"raw\"\n               ]\n              },\n              {\n               \"required\": [\n                \"ratelimitClientConfigRef\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"raw\"\n            ]\n           },\n           {\n            \"required\": [\n             \"ratelimitClientConfigRef\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"ratelimitClientConfigRef\": {\n            \"description\": \"Reference to the RateLimitClientConfig that configures the rate limiting model\",\n            \"properties\": {\n             \"name\": {\n              \"description\": \"name of the resource being referenced\",\n              \"type\": \"string\"\n             },\n             \"namespace\": {\n              \"description\": \"namespace of the resource being referenced\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"ratelimitServerConfigSelector\": {\n            \"description\": \"Labels to the RateLimitServerConfig ref sent to the ratelimit server\",\n            \"properties\": {\n             \"expressions\": {\n              \"description\": \"Expressions allow for more flexible object label matching, such as equality-based requirements, set-based requirements, or a combination of both.\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#equality-based-requirement\",\n              \"items\": {\n               \"properties\": {\n                \"key\": {\n                 \"description\": \"Kubernetes label key, must conform to Kubernetes syntax requirements\\nhttps://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set\",\n                 \"type\": \"string\"\n                },\n                \"operator\": {\n                 \"description\": \"The operator can only be in, notin, =, ==, !=, exists, ! (DoesNotExist), gt (GreaterThan), lt (LessThan).\",\n                 \"enum\": [\n                  \"Equals\",\n                  \"DoubleEquals\",\n                  \"NotEquals\",\n                  \"In\",\n                  \"NotIn\",\n                  \"Exists\",\n                  \"DoesNotExist\",\n                  \"GreaterThan\",\n                  \"LessThan\"\n                 ],\n                 \"type\": \"string\"\n                },\n                \"values\": {\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"labels\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"Select objects whose labels match the ones specified here.\",\n              \"type\": \"object\"\n             },\n             \"namespaces\": {\n              \"description\": \"Select Objects in these namespaces. If omitted, Gloo Mesh will only select Objects in the same namespace\\nas the parent resource (e.g. VirtualGateway) that owns this selector.\\nThe reserved value \\\"*\\\" can be used to select objects in all namespaces watched by Gloo Mesh.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"raw\": {\n            \"description\": \"Configure the actions and/or set actions that determine how Envoy composes the descriptors\",\n            \"properties\": {\n             \"rateLimits\": {\n              \"description\": \"Actions specify how the client (Envoy) will compose the descriptors that\\nwill be sent to the server to make a rate limiting decision.\",\n              \"items\": {\n               \"properties\": {\n                \"actions\": {\n                 \"items\": {\n                  \"oneOf\": [\n                   {\n                    \"not\": {\n                     \"anyOf\": [\n                      {\n                       \"required\": [\n                        \"sourceCluster\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"destinationCluster\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"requestHeaders\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"remoteAddress\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"genericKey\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"headerValueMatch\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"metadata\"\n                       ]\n                      }\n                     ]\n                    }\n                   },\n                   {\n                    \"required\": [\n                     \"sourceCluster\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"destinationCluster\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"requestHeaders\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"remoteAddress\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"genericKey\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"headerValueMatch\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"metadata\"\n                    ]\n                   }\n                  ],\n                  \"properties\": {\n                   \"destinationCluster\": {\n                    \"description\": \"Rate limit on destination cluster.\",\n                    \"type\": \"object\"\n                   },\n                   \"genericKey\": {\n                    \"description\": \"Rate limit on a generic key.\",\n                    \"properties\": {\n                     \"descriptorValue\": {\n                      \"description\": \"The value to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"headerValueMatch\": {\n                    \"description\": \"Rate limit on the existence of request headers.\",\n                    \"properties\": {\n                     \"descriptorValue\": {\n                      \"description\": \"The value to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"expectMatch\": {\n                      \"description\": \"If set to true, the action will append a descriptor entry when the\\nrequest matches the headers. If set to false, the action will append a\\ndescriptor entry when the request does not match the headers. The\\ndefault value is true.\",\n                      \"nullable\": true,\n                      \"type\": \"boolean\"\n                     },\n                     \"headers\": {\n                      \"description\": \"Specifies a set of headers that the rate limit action should match\\non. The action will check the request’s headers against all the\\nspecified headers in the config. A match will happen if all the\\nheaders in the config are present in the request with the same values\\n(or based on presence if the value field is not in the config).\",\n                      \"items\": {\n                       \"oneOf\": [\n                        {\n                         \"not\": {\n                          \"anyOf\": [\n                           {\n                            \"required\": [\n                             \"exactMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"regexMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"rangeMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"presentMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"prefixMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"suffixMatch\"\n                            ]\n                           }\n                          ]\n                         }\n                        },\n                        {\n                         \"required\": [\n                          \"exactMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"regexMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"rangeMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"presentMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"prefixMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"suffixMatch\"\n                         ]\n                        }\n                       ],\n                       \"properties\": {\n                        \"exactMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the value of the header.\",\n                         \"type\": \"string\"\n                        },\n                        \"invertMatch\": {\n                         \"description\": \"If specified, the match result will be inverted before checking. Defaults to false.\\n\\nExamples:\\n\\n* The regex *\\\\d{3}* does not match the value *1234*, so it will match when inverted.\\n* The range [-10,0) will match the value -1, so it will not match when inverted.\",\n                         \"type\": \"boolean\"\n                        },\n                        \"name\": {\n                         \"description\": \"Specifies the name of the header in the request.\",\n                         \"type\": \"string\"\n                        },\n                        \"prefixMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the prefix of the header value.\\nNote: empty prefix is not allowed, please use present_match instead.\\n\\nExamples:\\n\\n* The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.\",\n                         \"type\": \"string\"\n                        },\n                        \"presentMatch\": {\n                         \"description\": \"If specified, header match will be performed based on whether the header is in the\\nrequest.\",\n                         \"type\": \"boolean\"\n                        },\n                        \"rangeMatch\": {\n                         \"description\": \"If specified, header match will be performed based on range.\\nThe rule will match if the request header value is within this range.\\nThe entire request header value must represent an integer in base 10 notation: consisting of\\nan optional plus or minus sign followed by a sequence of digits. The rule will not match if\\nthe header value does not represent an integer. Match will fail for empty values, floating\\npoint numbers or if only a subsequence of the header value is an integer.\\n\\nExamples:\\n\\n* For range [-10,0), route will match for header value -1, but not for 0, \\\"somestring\\\", 10.9,\\n  \\\"-1somestring\\\"\",\n                         \"properties\": {\n                          \"end\": {\n                           \"description\": \"end of the range (exclusive)\",\n                           \"format\": \"int64\",\n                           \"type\": \"integer\"\n                          },\n                          \"start\": {\n                           \"description\": \"start of the range (inclusive)\",\n                           \"format\": \"int64\",\n                           \"type\": \"integer\"\n                          }\n                         },\n                         \"type\": \"object\"\n                        },\n                        \"regexMatch\": {\n                         \"description\": \"If specified, this regex string is a regular expression rule which implies the entire request\\nheader value must match the regex. The rule will not match if only a subsequence of the\\nrequest header value matches the regex. The regex grammar used in the value field is defined\\n`(here)[https://en.cppreference.com/w/cpp/regex/ecmascript]`.\\n\\nExamples:\\n\\n* The regex *\\\\d{3}* matches the value *123*\\n* The regex *\\\\d{3}* does not match the value *1234*\\n* The regex *\\\\d{3}* does not match the value *123.456*\",\n                         \"type\": \"string\"\n                        },\n                        \"suffixMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the suffix of the header value.\\nNote: empty suffix is not allowed, please use present_match instead.\\n\\nExamples:\\n\\n* The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.\",\n                         \"type\": \"string\"\n                        }\n                       },\n                       \"type\": \"object\"\n                      },\n                      \"type\": \"array\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"metadata\": {\n                    \"description\": \"Rate limit on metadata.\",\n                    \"properties\": {\n                     \"defaultValue\": {\n                      \"description\": \"An optional value to use if *metadata_key* is empty. If not set and\\nno value is present under the metadata_key then no descriptor is generated.\",\n                      \"type\": \"string\"\n                     },\n                     \"descriptorKey\": {\n                      \"description\": \"Required. The key to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"metadataKey\": {\n                      \"description\": \"Required. Metadata struct that defines the key and path to retrieve the string value. A match will\\nonly happen if the value in the metadata is of type string.\",\n                      \"properties\": {\n                       \"key\": {\n                        \"description\": \"Required. The key name of Metadata to retrieve the Struct from the metadata.\\nTypically, it represents a builtin subsystem or custom extension.\",\n                        \"type\": \"string\"\n                       },\n                       \"path\": {\n                        \"description\": \"Must have at least one element. The path to retrieve the Value from the Struct. It can be a prefix or a full path,\\ne.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,\\nwhich depends on the particular scenario.\\n\\nNote: Due to that only the key type segment is supported, the path can not specify a list\\nunless the list is the last segment.\",\n                        \"items\": {\n                         \"oneOf\": [\n                          {\n                           \"not\": {\n                            \"anyOf\": [\n                             {\n                              \"required\": [\n                               \"key\"\n                              ]\n                             }\n                            ]\n                           }\n                          },\n                          {\n                           \"required\": [\n                            \"key\"\n                           ]\n                          }\n                         ],\n                         \"properties\": {\n                          \"key\": {\n                           \"description\": \"Required. If specified, use the key to retrieve the value in a Struct.\",\n                           \"type\": \"string\"\n                          }\n                         },\n                         \"type\": \"object\"\n                        },\n                        \"type\": \"array\"\n                       }\n                      },\n                      \"type\": \"object\"\n                     },\n                     \"source\": {\n                      \"description\": \"Source of metadata\",\n                      \"enum\": [\n                       \"DYNAMIC\",\n                       \"ROUTE_ENTRY\"\n                      ],\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"remoteAddress\": {\n                    \"description\": \"Rate limit on remote address.\",\n                    \"type\": \"object\"\n                   },\n                   \"requestHeaders\": {\n                    \"description\": \"Rate limit on request headers.\",\n                    \"properties\": {\n                     \"descriptorKey\": {\n                      \"description\": \"The key to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"headerName\": {\n                      \"description\": \"The header name to be queried from the request headers. The header’s\\nvalue is used to populate the value of the descriptor entry for the\\ndescriptor_key.\",\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"sourceCluster\": {\n                    \"description\": \"Rate limit on source cluster.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"setActions\": {\n                 \"items\": {\n                  \"oneOf\": [\n                   {\n                    \"not\": {\n                     \"anyOf\": [\n                      {\n                       \"required\": [\n                        \"sourceCluster\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"destinationCluster\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"requestHeaders\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"remoteAddress\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"genericKey\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"headerValueMatch\"\n                       ]\n                      },\n                      {\n                       \"required\": [\n                        \"metadata\"\n                       ]\n                      }\n                     ]\n                    }\n                   },\n                   {\n                    \"required\": [\n                     \"sourceCluster\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"destinationCluster\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"requestHeaders\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"remoteAddress\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"genericKey\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"headerValueMatch\"\n                    ]\n                   },\n                   {\n                    \"required\": [\n                     \"metadata\"\n                    ]\n                   }\n                  ],\n                  \"properties\": {\n                   \"destinationCluster\": {\n                    \"description\": \"Rate limit on destination cluster.\",\n                    \"type\": \"object\"\n                   },\n                   \"genericKey\": {\n                    \"description\": \"Rate limit on a generic key.\",\n                    \"properties\": {\n                     \"descriptorValue\": {\n                      \"description\": \"The value to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"headerValueMatch\": {\n                    \"description\": \"Rate limit on the existence of request headers.\",\n                    \"properties\": {\n                     \"descriptorValue\": {\n                      \"description\": \"The value to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"expectMatch\": {\n                      \"description\": \"If set to true, the action will append a descriptor entry when the\\nrequest matches the headers. If set to false, the action will append a\\ndescriptor entry when the request does not match the headers. The\\ndefault value is true.\",\n                      \"nullable\": true,\n                      \"type\": \"boolean\"\n                     },\n                     \"headers\": {\n                      \"description\": \"Specifies a set of headers that the rate limit action should match\\non. The action will check the request’s headers against all the\\nspecified headers in the config. A match will happen if all the\\nheaders in the config are present in the request with the same values\\n(or based on presence if the value field is not in the config).\",\n                      \"items\": {\n                       \"oneOf\": [\n                        {\n                         \"not\": {\n                          \"anyOf\": [\n                           {\n                            \"required\": [\n                             \"exactMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"regexMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"rangeMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"presentMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"prefixMatch\"\n                            ]\n                           },\n                           {\n                            \"required\": [\n                             \"suffixMatch\"\n                            ]\n                           }\n                          ]\n                         }\n                        },\n                        {\n                         \"required\": [\n                          \"exactMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"regexMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"rangeMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"presentMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"prefixMatch\"\n                         ]\n                        },\n                        {\n                         \"required\": [\n                          \"suffixMatch\"\n                         ]\n                        }\n                       ],\n                       \"properties\": {\n                        \"exactMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the value of the header.\",\n                         \"type\": \"string\"\n                        },\n                        \"invertMatch\": {\n                         \"description\": \"If specified, the match result will be inverted before checking. Defaults to false.\\n\\nExamples:\\n\\n* The regex *\\\\d{3}* does not match the value *1234*, so it will match when inverted.\\n* The range [-10,0) will match the value -1, so it will not match when inverted.\",\n                         \"type\": \"boolean\"\n                        },\n                        \"name\": {\n                         \"description\": \"Specifies the name of the header in the request.\",\n                         \"type\": \"string\"\n                        },\n                        \"prefixMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the prefix of the header value.\\nNote: empty prefix is not allowed, please use present_match instead.\\n\\nExamples:\\n\\n* The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.\",\n                         \"type\": \"string\"\n                        },\n                        \"presentMatch\": {\n                         \"description\": \"If specified, header match will be performed based on whether the header is in the\\nrequest.\",\n                         \"type\": \"boolean\"\n                        },\n                        \"rangeMatch\": {\n                         \"description\": \"If specified, header match will be performed based on range.\\nThe rule will match if the request header value is within this range.\\nThe entire request header value must represent an integer in base 10 notation: consisting of\\nan optional plus or minus sign followed by a sequence of digits. The rule will not match if\\nthe header value does not represent an integer. Match will fail for empty values, floating\\npoint numbers or if only a subsequence of the header value is an integer.\\n\\nExamples:\\n\\n* For range [-10,0), route will match for header value -1, but not for 0, \\\"somestring\\\", 10.9,\\n  \\\"-1somestring\\\"\",\n                         \"properties\": {\n                          \"end\": {\n                           \"description\": \"end of the range (exclusive)\",\n                           \"format\": \"int64\",\n                           \"type\": \"integer\"\n                          },\n                          \"start\": {\n                           \"description\": \"start of the range (inclusive)\",\n                           \"format\": \"int64\",\n                           \"type\": \"integer\"\n                          }\n                         },\n                         \"type\": \"object\"\n                        },\n                        \"regexMatch\": {\n                         \"description\": \"If specified, this regex string is a regular expression rule which implies the entire request\\nheader value must match the regex. The rule will not match if only a subsequence of the\\nrequest header value matches the regex. The regex grammar used in the value field is defined\\n`(here)[https://en.cppreference.com/w/cpp/regex/ecmascript]`.\\n\\nExamples:\\n\\n* The regex *\\\\d{3}* matches the value *123*\\n* The regex *\\\\d{3}* does not match the value *1234*\\n* The regex *\\\\d{3}* does not match the value *123.456*\",\n                         \"type\": \"string\"\n                        },\n                        \"suffixMatch\": {\n                         \"description\": \"If specified, header match will be performed based on the suffix of the header value.\\nNote: empty suffix is not allowed, please use present_match instead.\\n\\nExamples:\\n\\n* The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.\",\n                         \"type\": \"string\"\n                        }\n                       },\n                       \"type\": \"object\"\n                      },\n                      \"type\": \"array\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"metadata\": {\n                    \"description\": \"Rate limit on metadata.\",\n                    \"properties\": {\n                     \"defaultValue\": {\n                      \"description\": \"An optional value to use if *metadata_key* is empty. If not set and\\nno value is present under the metadata_key then no descriptor is generated.\",\n                      \"type\": \"string\"\n                     },\n                     \"descriptorKey\": {\n                      \"description\": \"Required. The key to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"metadataKey\": {\n                      \"description\": \"Required. Metadata struct that defines the key and path to retrieve the string value. A match will\\nonly happen if the value in the metadata is of type string.\",\n                      \"properties\": {\n                       \"key\": {\n                        \"description\": \"Required. The key name of Metadata to retrieve the Struct from the metadata.\\nTypically, it represents a builtin subsystem or custom extension.\",\n                        \"type\": \"string\"\n                       },\n                       \"path\": {\n                        \"description\": \"Must have at least one element. The path to retrieve the Value from the Struct. It can be a prefix or a full path,\\ne.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,\\nwhich depends on the particular scenario.\\n\\nNote: Due to that only the key type segment is supported, the path can not specify a list\\nunless the list is the last segment.\",\n                        \"items\": {\n                         \"oneOf\": [\n                          {\n                           \"not\": {\n                            \"anyOf\": [\n                             {\n                              \"required\": [\n                               \"key\"\n                              ]\n                             }\n                            ]\n                           }\n                          },\n                          {\n                           \"required\": [\n                            \"key\"\n                           ]\n                          }\n                         ],\n                         \"properties\": {\n                          \"key\": {\n                           \"description\": \"Required. If specified, use the key to retrieve the value in a Struct.\",\n                           \"type\": \"string\"\n                          }\n                         },\n                         \"type\": \"object\"\n                        },\n                        \"type\": \"array\"\n                       }\n                      },\n                      \"type\": \"object\"\n                     },\n                     \"source\": {\n                      \"description\": \"Source of metadata\",\n                      \"enum\": [\n                       \"DYNAMIC\",\n                       \"ROUTE_ENTRY\"\n                      ],\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"remoteAddress\": {\n                    \"description\": \"Rate limit on remote address.\",\n                    \"type\": \"object\"\n                   },\n                   \"requestHeaders\": {\n                    \"description\": \"Rate limit on request headers.\",\n                    \"properties\": {\n                     \"descriptorKey\": {\n                      \"description\": \"The key to use in the descriptor entry.\",\n                      \"type\": \"string\"\n                     },\n                     \"headerName\": {\n                      \"description\": \"The header name to be queried from the request headers. The header’s\\nvalue is used to populate the value of the descriptor entry for the\\ndescriptor_key.\",\n                      \"type\": \"string\"\n                     }\n                    },\n                    \"type\": \"object\"\n                   },\n                   \"sourceCluster\": {\n                    \"description\": \"Rate limit on source cluster.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"requestTimeout\": {\n          \"description\": \"Set a timeout on requests.\",\n          \"type\": \"string\"\n         },\n         \"retries\": {\n          \"description\": \"Set a retry policy on requests.\",\n          \"properties\": {\n           \"attempts\": {\n            \"description\": \"Number of retries for a given request\",\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"perTryTimeout\": {\n            \"description\": \"Timeout per retry attempt for a given request. Format: `1h`/`1m`/`1s`/`1ms`. *Must be \\u003e= 1ms*.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"trafficShift\": {\n          \"description\": \"Shift traffic to a different destination.\",\n          \"properties\": {\n           \"destinations\": {\n            \"description\": \"Specify weighted traffic shift destinations.\",\n            \"items\": {\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"kubeService\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"virtualDestination\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"staticDestination\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"clusterHeader\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"kubeService\"\n               ]\n              },\n              {\n               \"required\": [\n                \"virtualDestination\"\n               ]\n              },\n              {\n               \"required\": [\n                \"staticDestination\"\n               ]\n              },\n              {\n               \"required\": [\n                \"clusterHeader\"\n               ]\n              }\n             ],\n             \"properties\": {\n              \"clusterHeader\": {\n               \"description\": \"Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers.\\nIf the header is not found or the referenced cluster does not exist, Envoy will return a 404 response.\\nAvoid using this whenever possible, it does not allow for custom filter configuration based on Virtual Host.\\n{{/* NOTE: unimplemented */}}\",\n               \"type\": \"string\"\n              },\n              \"kubeService\": {\n               \"description\": \"Specify a Kubernetes Service.\",\n               \"properties\": {\n                \"clusterName\": {\n                 \"description\": \"The Gloo Mesh cluster name (registration name) of the service.\",\n                 \"type\": \"string\"\n                },\n                \"name\": {\n                 \"description\": \"The name of the service.\",\n                 \"type\": \"string\"\n                },\n                \"namespace\": {\n                 \"description\": \"The namespace of the service.\",\n                 \"type\": \"string\"\n                },\n                \"port\": {\n                 \"description\": \"Port on the service to receive traffic. Required if the service exposes more than one port.\",\n                 \"maximum\": 4294967295,\n                 \"minimum\": 0,\n                 \"type\": \"integer\"\n                },\n                \"subset\": {\n                 \"additionalProperties\": {\n                  \"type\": \"string\"\n                 },\n                 \"description\": \"Specify, by labels, a subset of service instances to route to.\",\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"options\": {\n               \"description\": \"additional options / config for a route which will be applied\\nwhen this destination is selected.\",\n               \"properties\": {\n                \"headerManipulation\": {\n                 \"description\": \"manipualte headers on traffic sent to this destination\",\n                 \"properties\": {\n                  \"appendRequestHeaders\": {\n                   \"additionalProperties\": {\n                    \"type\": \"string\"\n                   },\n                   \"description\": \"Additional HTTP headers to add before forwarding a request to the destination service.\",\n                   \"type\": \"object\"\n                  },\n                  \"appendResponseHeaders\": {\n                   \"additionalProperties\": {\n                    \"type\": \"string\"\n                   },\n                   \"description\": \"Additional HTTP headers to add before returning a response to the caller.\",\n                   \"type\": \"object\"\n                  },\n                  \"removeRequestHeaders\": {\n                   \"description\": \"HTTP headers to remove before forwarding a request to the destination service.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\"\n                  },\n                  \"removeResponseHeaders\": {\n                   \"description\": \"HTTP headers to remove before returning a response to the caller.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\"\n                  }\n                 },\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"staticDestination\": {\n               \"description\": \"Reference to a Gloo Mesh Static Destination.\\nRoughly translates into a static cluster in envoy.\",\n               \"properties\": {\n                \"name\": {\n                 \"description\": \"name of the resource being referenced\",\n                 \"type\": \"string\"\n                },\n                \"namespace\": {\n                 \"description\": \"namespace of the resource being referenced\",\n                 \"type\": \"string\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"virtualDestination\": {\n               \"description\": \"Specify a VirtualDestination.\\nVirtual destinations get a new hostname that services reference and route to,\\nand then Gloo Mesh orchestrates locality-based load-balancing among the destinations.\\nThis is helpful to setup, for example, cluster-agnostic routing and failover with\\npreference given to local services.\",\n               \"properties\": {\n                \"name\": {\n                 \"description\": \"The name of the VirtualDestination object.\",\n                 \"type\": \"string\"\n                },\n                \"namespace\": {\n                 \"description\": \"The namespace of the VirtualDestination object.\",\n                 \"type\": \"string\"\n                },\n                \"subset\": {\n                 \"additionalProperties\": {\n                  \"type\": \"string\"\n                 },\n                 \"description\": \"Specify, by labels, a subset of service instances backing the VirtualDestination to route to.\",\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"weight\": {\n               \"description\": \"Specify the proportion of traffic to be forwarded to this destination.\\nWeights across all of the `destinations` must sum to 100.\",\n               \"maximum\": 4294967295,\n               \"minimum\": 0,\n               \"type\": \"integer\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"redirectAction\": {\n        \"description\": \"Redirect actions tell the proxy to return a redirect response to the downstream client.\",\n        \"properties\": {\n         \"hostRedirect\": {\n          \"description\": \"The host portion of the URL will be swapped with this value.\",\n          \"type\": \"string\"\n         },\n         \"httpsRedirect\": {\n          \"description\": \"The scheme portion of the URL will be swapped with \\\"https\\\".\",\n          \"type\": \"boolean\"\n         },\n         \"pathRedirect\": {\n          \"description\": \"The path portion of the URL will be swapped with this value.\",\n          \"type\": \"string\"\n         },\n         \"prefixRewrite\": {\n          \"description\": \"Indicates that during redirection, the matched prefix (or path)\\nshould be swapped with this value. This option allows redirect URLs be dynamically created\\nbased on the request.\\n\\n  Pay attention to the use of trailing slashes as mentioned in\\n  `RouteAction`'s `prefix_rewrite`.\",\n          \"type\": \"string\"\n         },\n         \"responseCode\": {\n          \"description\": \"The HTTP status code to use in the redirect response. The default response\\ncode is MOVED_PERMANENTLY (301).\",\n          \"enum\": [\n           \"MOVED_PERMANENTLY\",\n           \"FOUND\",\n           \"SEE_OTHER\",\n           \"TEMPORARY_REDIRECT\",\n           \"PERMANENT_REDIRECT\"\n          ],\n          \"type\": \"string\"\n         },\n         \"stripQuery\": {\n          \"description\": \"Indicates that during redirection, the query portion of the URL will\\nbe removed. Default value is false.\",\n          \"type\": \"boolean\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"routeAction\": {\n        \"description\": \"This action is the primary action to be selected for most routes. The RouteAction tells the proxy to\\nroute requests to an upstream.\",\n        \"properties\": {\n         \"destinations\": {\n          \"description\": \"Defines the destination upstream for routing\\nSome destinations require additional configuration for the route (e.g. AWS upstreams require a function name\\nto be specified).\",\n          \"items\": {\n           \"oneOf\": [\n            {\n             \"not\": {\n              \"anyOf\": [\n               {\n                \"required\": [\n                 \"kubeService\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"virtualDestination\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"staticDestination\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"clusterHeader\"\n                ]\n               }\n              ]\n             }\n            },\n            {\n             \"required\": [\n              \"kubeService\"\n             ]\n            },\n            {\n             \"required\": [\n              \"virtualDestination\"\n             ]\n            },\n            {\n             \"required\": [\n              \"staticDestination\"\n             ]\n            },\n            {\n             \"required\": [\n              \"clusterHeader\"\n             ]\n            }\n           ],\n           \"properties\": {\n            \"clusterHeader\": {\n             \"description\": \"Envoy will determine the cluster to route to by reading the value of the HTTP header named by cluster_header from the request headers.\\nIf the header is not found or the referenced cluster does not exist, Envoy will return a 404 response.\\nAvoid using this whenever possible, it does not allow for custom filter configuration based on Virtual Host.\\n{{/* NOTE: unimplemented */}}\",\n             \"type\": \"string\"\n            },\n            \"kubeService\": {\n             \"description\": \"Specify a Kubernetes Service.\",\n             \"properties\": {\n              \"clusterName\": {\n               \"description\": \"The Gloo Mesh cluster name (registration name) of the service.\",\n               \"type\": \"string\"\n              },\n              \"name\": {\n               \"description\": \"The name of the service.\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"The namespace of the service.\",\n               \"type\": \"string\"\n              },\n              \"port\": {\n               \"description\": \"Port on the service to receive traffic. Required if the service exposes more than one port.\",\n               \"maximum\": 4294967295,\n               \"minimum\": 0,\n               \"type\": \"integer\"\n              },\n              \"subset\": {\n               \"additionalProperties\": {\n                \"type\": \"string\"\n               },\n               \"description\": \"Specify, by labels, a subset of service instances to route to.\",\n               \"type\": \"object\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"options\": {\n             \"description\": \"additional options / config for a route which will be applied\\nwhen this destination is selected.\",\n             \"properties\": {\n              \"headerManipulation\": {\n               \"description\": \"manipualte headers on traffic sent to this destination\",\n               \"properties\": {\n                \"appendRequestHeaders\": {\n                 \"additionalProperties\": {\n                  \"type\": \"string\"\n                 },\n                 \"description\": \"Additional HTTP headers to add before forwarding a request to the destination service.\",\n                 \"type\": \"object\"\n                },\n                \"appendResponseHeaders\": {\n                 \"additionalProperties\": {\n                  \"type\": \"string\"\n                 },\n                 \"description\": \"Additional HTTP headers to add before returning a response to the caller.\",\n                 \"type\": \"object\"\n                },\n                \"removeRequestHeaders\": {\n                 \"description\": \"HTTP headers to remove before forwarding a request to the destination service.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"removeResponseHeaders\": {\n                 \"description\": \"HTTP headers to remove before returning a response to the caller.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"staticDestination\": {\n             \"description\": \"Reference to a Gloo Mesh Static Destination.\\nRoughly translates into a static cluster in envoy.\",\n             \"properties\": {\n              \"name\": {\n               \"description\": \"name of the resource being referenced\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"namespace of the resource being referenced\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"virtualDestination\": {\n             \"description\": \"Specify a VirtualDestination.\\nVirtual destinations get a new hostname that services reference and route to,\\nand then Gloo Mesh orchestrates locality-based load-balancing among the destinations.\\nThis is helpful to setup, for example, cluster-agnostic routing and failover with\\npreference given to local services.\",\n             \"properties\": {\n              \"name\": {\n               \"description\": \"The name of the VirtualDestination object.\",\n               \"type\": \"string\"\n              },\n              \"namespace\": {\n               \"description\": \"The namespace of the VirtualDestination object.\",\n               \"type\": \"string\"\n              },\n              \"subset\": {\n               \"additionalProperties\": {\n                \"type\": \"string\"\n               },\n               \"description\": \"Specify, by labels, a subset of service instances backing the VirtualDestination to route to.\",\n               \"type\": \"object\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"weight\": {\n             \"description\": \"Specify the proportion of traffic to be forwarded to this destination.\\nWeights across all of the `destinations` must sum to 100.\",\n             \"maximum\": 4294967295,\n             \"minimum\": 0,\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"type\": \"array\"\n         },\n         \"pathRewrite\": {\n          \"description\": \"Replace the path specified in the matcher with this value before passing upstream.\\nWhen a prefix matcher is used, only the prefix portion of the path is rewritten.\\nWhen an exact matcher is used, the whole path is replaced.\\nRewriting the path when a regex matcher is used is currently unsupported.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"weight\": {\n     \"description\": \"Weight is used when sorting route tables in delegate action or routes when sorted by specificity.\\nHigher integer values are considered higher priority. The default value is 0.\",\n     \"format\": \"int32\",\n     \"type\": \"integer\"\n    }\n   },\n   \"type\": \"object\"\n  }\n },\n \"title\": \"Route Table\",\n \"type\": \"object\"\n}"}