{
  "id": "00000000-0000-0000-0000-000000000000",
  "schemaVersion": "components.meshery.io/v1beta1",
  "version": "v1.0.0",
  "displayName": "Vertica Autoscaler",
  "description": "",
  "format": "JSON",
  "model": {
    "id": "00000000-0000-0000-0000-000000000000",
    "schemaVersion": "models.meshery.io/v1beta1",
    "version": "v1.0.0",
    "name": "verticadb-operator",
    "displayName": "Verticadb Operator",
    "status": "ignored",
    "registrant": {
      "id": "00000000-0000-0000-0000-000000000000",
      "name": "Artifact Hub",
      "credential_id": "00000000-0000-0000-0000-000000000000",
      "type": "registry",
      "sub_type": "",
      "kind": "artifacthub",
      "status": "discovered",
      "user_id": "00000000-0000-0000-0000-000000000000",
      "created_at": "0001-01-01T00:00:00Z",
      "updated_at": "0001-01-01T00:00:00Z",
      "deleted_at": "0001-01-01T00:00:00Z"
    },
    "connection_id": "00000000-0000-0000-0000-000000000000",
    "category": {
      "id": "00000000-0000-0000-0000-000000000000",
      "name": "App Definition and Development"
    },
    "subCategory": "Database",
    "metadata": {
      "isAnnotation": false,
      "primaryColor": "#00B39F",
      "secondaryColor": "#00D3A9",
      "shape": "circle",
      "source_uri": "https://github.com/vertica/vertica-kubernetes/releases/download/v25.2.1-0/verticadb-operator-25.2.1-0.tgz",
      "styleOverrides": "",
      "svgColor": "",
      "svgComplete": "",
      "svgWhite": ""
    },
    "model": {
      "version": "25.2.1"
    },
    "components_count": 0,
    "relationships_count": 0,
    "components": null,
    "relationships": null
  },
  "styles": {
    "primaryColor": "#00B39F",
    "secondaryColor": "#00D3A9",
    "shape": "circle",
    "svgColor": "",
    "svgComplete": "",
    "svgWhite": ""
  },
  "capabilities": [
    {
      "description": "Initiate a performance test. Meshery will execute the load generation, collect metrics, and present the results.",
      "displayName": "Performance Test",
      "entityState": [
        "instance"
      ],
      "key": "",
      "kind": "action",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "perf-test",
      "type": "operator",
      "version": "0.7.0"
    },
    {
      "description": "Configure the workload specific setting of a component",
      "displayName": "Workload Configuration",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "config",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "Configure Labels And Annotations for  the component ",
      "displayName": "Labels and Annotations Configuration",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "labels-and-annotations",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "View relationships for the component",
      "displayName": "Relationships",
      "entityState": [
        "declaration",
        "instance"
      ],
      "key": "",
      "kind": "view",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "relationship",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "View Component Definition ",
      "displayName": "Json Schema",
      "entityState": [
        "declaration",
        "instance"
      ],
      "key": "",
      "kind": "view",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "definition",
      "type": "configuration",
      "version": "0.7.0"
    },
    {
      "description": "Configure the visual styles for the component",
      "displayName": "Styling",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "",
      "type": "style",
      "version": "0.7.0"
    },
    {
      "description": "Change the shape of the component",
      "displayName": "Change Shape",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "mutate",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "shape",
      "type": "style",
      "version": "0.7.0"
    },
    {
      "description": "Drag and Drop a component into a parent component in graph view",
      "displayName": "Compound Drag And Drop",
      "entityState": [
        "declaration"
      ],
      "key": "",
      "kind": "interaction",
      "schemaVersion": "capability.meshery.io/v1alpha1",
      "status": "enabled",
      "subType": "compoundDnd",
      "type": "graph",
      "version": "0.7.0"
    }
  ],
  "status": "enabled",
  "metadata": {
    "configurationUISchema": "",
    "genealogy": "",
    "instanceDetails": null,
    "isAnnotation": false,
    "isNamespaced": true,
    "published": false,
    "source_uri": "https://github.com/vertica/vertica-kubernetes/releases/download/v25.2.1-0/verticadb-operator-25.2.1-0.tgz"
  },
  "configuration": null,
  "component": {
    "version": "vertica.com/v1",
    "kind": "VerticaAutoscaler",
    "schema": "{\n \"description\": \"VerticaAutoscaler is a CR that allows you to autoscale one or more\\nsubclusters in a VerticaDB.\",\n \"properties\": {\n  \"spec\": {\n   \"description\": \"VerticaAutoscalerSpec defines the desired state of VerticaAutoscaler\",\n   \"properties\": {\n    \"customAutoscaler\": {\n     \"description\": \"This struct allows customization of autoscaling. Custom metrics can be used instead of the memory and cpu metrics.\\nThe scaling behavior can also be customized to meet different performance requirements. The maximum and mininum of\\nsizes of the replica sets can be specified to limit the use of resources.\",\n     \"properties\": {\n      \"hpa\": {\n       \"description\": \"It refers to an autoscaling definition through the horizontal pod autoscaler.\\nIf type is \\\"HPA\\\", this must be set.\",\n       \"properties\": {\n        \"behavior\": {\n         \"description\": \"Specifies the scaling behavior for both scale out and in.\",\n         \"properties\": {\n          \"scaleDown\": {\n           \"description\": \"scaleDown is scaling policy for scaling Down.\\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\\n300 second stabilization window (i.e., the highest recommendation for\\nthe last 300sec is used).\",\n           \"properties\": {\n            \"policies\": {\n             \"description\": \"policies is a list of potential scaling polices which can be used during scaling.\\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid\",\n             \"items\": {\n              \"description\": \"HPAScalingPolicy is a single policy which must hold true for a specified past interval.\",\n              \"properties\": {\n               \"periodSeconds\": {\n                \"description\": \"periodSeconds specifies the window of time for which the policy should hold true.\\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               },\n               \"type\": {\n                \"description\": \"type is used to specify the scaling policy.\",\n                \"type\": \"string\"\n               },\n               \"value\": {\n                \"description\": \"value contains the amount of change which is permitted by the policy.\\nIt must be greater than zero\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               }\n              },\n              \"required\": [\n               \"periodSeconds\",\n               \"type\",\n               \"value\"\n              ],\n              \"type\": \"object\"\n             },\n             \"type\": \"array\",\n             \"x-kubernetes-list-type\": \"atomic\"\n            },\n            \"selectPolicy\": {\n             \"description\": \"selectPolicy is used to specify which policy should be used.\\nIf not set, the default value Max is used.\",\n             \"type\": \"string\"\n            },\n            \"stabilizationWindowSeconds\": {\n             \"description\": \"stabilizationWindowSeconds is the number of seconds for which past recommendations should be\\nconsidered while scaling up or scaling down.\\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\\nIf not set, use the default values:\\n- For scale up: 0 (i.e. no stabilization is done).\\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).\",\n             \"format\": \"int32\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"scaleUp\": {\n           \"description\": \"scaleUp is scaling policy for scaling Up.\\nIf not set, the default value is the higher of:\\n  * increase no more than 4 pods per 60 seconds\\n  * double the number of pods per 60 seconds\\nNo stabilization is used.\",\n           \"properties\": {\n            \"policies\": {\n             \"description\": \"policies is a list of potential scaling polices which can be used during scaling.\\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid\",\n             \"items\": {\n              \"description\": \"HPAScalingPolicy is a single policy which must hold true for a specified past interval.\",\n              \"properties\": {\n               \"periodSeconds\": {\n                \"description\": \"periodSeconds specifies the window of time for which the policy should hold true.\\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               },\n               \"type\": {\n                \"description\": \"type is used to specify the scaling policy.\",\n                \"type\": \"string\"\n               },\n               \"value\": {\n                \"description\": \"value contains the amount of change which is permitted by the policy.\\nIt must be greater than zero\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               }\n              },\n              \"required\": [\n               \"periodSeconds\",\n               \"type\",\n               \"value\"\n              ],\n              \"type\": \"object\"\n             },\n             \"type\": \"array\",\n             \"x-kubernetes-list-type\": \"atomic\"\n            },\n            \"selectPolicy\": {\n             \"description\": \"selectPolicy is used to specify which policy should be used.\\nIf not set, the default value Max is used.\",\n             \"type\": \"string\"\n            },\n            \"stabilizationWindowSeconds\": {\n             \"description\": \"stabilizationWindowSeconds is the number of seconds for which past recommendations should be\\nconsidered while scaling up or scaling down.\\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\\nIf not set, use the default values:\\n- For scale up: 0 (i.e. no stabilization is done).\\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).\",\n             \"format\": \"int32\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"maxReplicas\": {\n         \"description\": \"The maximum number of pods when scaling.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"metrics\": {\n         \"description\": \"The custom metric definition to be used for autocaling.\",\n         \"items\": {\n          \"description\": \"MetricDefinition defines increment and metric to be used for autoscaling\",\n          \"properties\": {\n           \"metric\": {\n            \"description\": \"The custom metric to be used for autocaling.\",\n            \"properties\": {\n             \"containerResource\": {\n              \"description\": \"containerResource refers to a resource metric (such as those specified in\\nrequests and limits) known to Kubernetes describing a single container in\\neach pod of the current scale target (e.g. CPU or memory). Such metrics are\\nbuilt in to Kubernetes, and have special scaling options on top of those\\navailable to normal per-pod metrics using the \\\"pods\\\" source.\\nThis is an alpha feature and can be enabled by the HPAContainerMetrics feature flag.\",\n              \"properties\": {\n               \"container\": {\n                \"description\": \"container is the name of the container in the pods of the scaling target\",\n                \"type\": \"string\"\n               },\n               \"name\": {\n                \"description\": \"name is the name of the resource in question.\",\n                \"type\": \"string\"\n               },\n               \"target\": {\n                \"description\": \"target specifies the target value for the given metric\",\n                \"properties\": {\n                 \"averageUtilization\": {\n                  \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n                  \"format\": \"int32\",\n                  \"type\": \"integer\"\n                 },\n                 \"averageValue\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 },\n                 \"type\": {\n                  \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"value is the target value of the metric (as a quantity).\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 }\n                },\n                \"required\": [\n                 \"type\"\n                ],\n                \"type\": \"object\"\n               }\n              },\n              \"required\": [\n               \"container\",\n               \"name\",\n               \"target\"\n              ],\n              \"type\": \"object\"\n             },\n             \"external\": {\n              \"description\": \"external refers to a global metric that is not associated\\nwith any Kubernetes object. It allows autoscaling based on information\\ncoming from components running outside of cluster\\n(for example length of queue in cloud messaging service, or\\nQPS from loadbalancer running outside of cluster).\",\n              \"properties\": {\n               \"metric\": {\n                \"description\": \"metric identifies the target metric by name and selector\",\n                \"properties\": {\n                 \"name\": {\n                  \"description\": \"name is the name of the given metric\",\n                  \"type\": \"string\"\n                 },\n                 \"selector\": {\n                  \"description\": \"selector is the string-encoded form of a standard kubernetes label selector for the given metric\\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\\nWhen unset, just the metricName will be used to gather metrics.\",\n                  \"properties\": {\n                   \"matchExpressions\": {\n                    \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                    \"items\": {\n                     \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                     \"properties\": {\n                      \"key\": {\n                       \"description\": \"key is the label key that the selector applies to.\",\n                       \"type\": \"string\"\n                      },\n                      \"operator\": {\n                       \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                       \"type\": \"string\"\n                      },\n                      \"values\": {\n                       \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                       \"items\": {\n                        \"type\": \"string\"\n                       },\n                       \"type\": \"array\",\n                       \"x-kubernetes-list-type\": \"atomic\"\n                      }\n                     },\n                     \"required\": [\n                      \"key\",\n                      \"operator\"\n                     ],\n                     \"type\": \"object\"\n                    },\n                    \"type\": \"array\",\n                    \"x-kubernetes-list-type\": \"atomic\"\n                   },\n                   \"matchLabels\": {\n                    \"additionalProperties\": {\n                     \"type\": \"string\"\n                    },\n                    \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\",\n                  \"x-kubernetes-map-type\": \"atomic\"\n                 }\n                },\n                \"required\": [\n                 \"name\"\n                ],\n                \"type\": \"object\"\n               },\n               \"target\": {\n                \"description\": \"target specifies the target value for the given metric\",\n                \"properties\": {\n                 \"averageUtilization\": {\n                  \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n                  \"format\": \"int32\",\n                  \"type\": \"integer\"\n                 },\n                 \"averageValue\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 },\n                 \"type\": {\n                  \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"value is the target value of the metric (as a quantity).\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 }\n                },\n                \"required\": [\n                 \"type\"\n                ],\n                \"type\": \"object\"\n               }\n              },\n              \"required\": [\n               \"metric\",\n               \"target\"\n              ],\n              \"type\": \"object\"\n             },\n             \"object\": {\n              \"description\": \"object refers to a metric describing a single kubernetes object\\n(for example, hits-per-second on an Ingress object).\",\n              \"properties\": {\n               \"describedObject\": {\n                \"description\": \"describedObject specifies the descriptions of a object,such as kind,name apiVersion\",\n                \"properties\": {\n                 \"apiVersion\": {\n                  \"description\": \"apiVersion is the API version of the referent\",\n                  \"type\": \"string\"\n                 },\n                 \"kind\": {\n                  \"description\": \"kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\n                  \"type\": \"string\"\n                 },\n                 \"name\": {\n                  \"description\": \"name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names\",\n                  \"type\": \"string\"\n                 }\n                },\n                \"required\": [\n                 \"kind\",\n                 \"name\"\n                ],\n                \"type\": \"object\"\n               },\n               \"metric\": {\n                \"description\": \"metric identifies the target metric by name and selector\",\n                \"properties\": {\n                 \"name\": {\n                  \"description\": \"name is the name of the given metric\",\n                  \"type\": \"string\"\n                 },\n                 \"selector\": {\n                  \"description\": \"selector is the string-encoded form of a standard kubernetes label selector for the given metric\\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\\nWhen unset, just the metricName will be used to gather metrics.\",\n                  \"properties\": {\n                   \"matchExpressions\": {\n                    \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                    \"items\": {\n                     \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                     \"properties\": {\n                      \"key\": {\n                       \"description\": \"key is the label key that the selector applies to.\",\n                       \"type\": \"string\"\n                      },\n                      \"operator\": {\n                       \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                       \"type\": \"string\"\n                      },\n                      \"values\": {\n                       \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                       \"items\": {\n                        \"type\": \"string\"\n                       },\n                       \"type\": \"array\",\n                       \"x-kubernetes-list-type\": \"atomic\"\n                      }\n                     },\n                     \"required\": [\n                      \"key\",\n                      \"operator\"\n                     ],\n                     \"type\": \"object\"\n                    },\n                    \"type\": \"array\",\n                    \"x-kubernetes-list-type\": \"atomic\"\n                   },\n                   \"matchLabels\": {\n                    \"additionalProperties\": {\n                     \"type\": \"string\"\n                    },\n                    \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\",\n                  \"x-kubernetes-map-type\": \"atomic\"\n                 }\n                },\n                \"required\": [\n                 \"name\"\n                ],\n                \"type\": \"object\"\n               },\n               \"target\": {\n                \"description\": \"target specifies the target value for the given metric\",\n                \"properties\": {\n                 \"averageUtilization\": {\n                  \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n                  \"format\": \"int32\",\n                  \"type\": \"integer\"\n                 },\n                 \"averageValue\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 },\n                 \"type\": {\n                  \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"value is the target value of the metric (as a quantity).\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 }\n                },\n                \"required\": [\n                 \"type\"\n                ],\n                \"type\": \"object\"\n               }\n              },\n              \"required\": [\n               \"describedObject\",\n               \"metric\",\n               \"target\"\n              ],\n              \"type\": \"object\"\n             },\n             \"pods\": {\n              \"description\": \"pods refers to a metric describing each pod in the current scale target\\n(for example, transactions-processed-per-second).  The values will be\\naveraged together before being compared to the target value.\",\n              \"properties\": {\n               \"metric\": {\n                \"description\": \"metric identifies the target metric by name and selector\",\n                \"properties\": {\n                 \"name\": {\n                  \"description\": \"name is the name of the given metric\",\n                  \"type\": \"string\"\n                 },\n                 \"selector\": {\n                  \"description\": \"selector is the string-encoded form of a standard kubernetes label selector for the given metric\\nWhen set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.\\nWhen unset, just the metricName will be used to gather metrics.\",\n                  \"properties\": {\n                   \"matchExpressions\": {\n                    \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                    \"items\": {\n                     \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                     \"properties\": {\n                      \"key\": {\n                       \"description\": \"key is the label key that the selector applies to.\",\n                       \"type\": \"string\"\n                      },\n                      \"operator\": {\n                       \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                       \"type\": \"string\"\n                      },\n                      \"values\": {\n                       \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                       \"items\": {\n                        \"type\": \"string\"\n                       },\n                       \"type\": \"array\",\n                       \"x-kubernetes-list-type\": \"atomic\"\n                      }\n                     },\n                     \"required\": [\n                      \"key\",\n                      \"operator\"\n                     ],\n                     \"type\": \"object\"\n                    },\n                    \"type\": \"array\",\n                    \"x-kubernetes-list-type\": \"atomic\"\n                   },\n                   \"matchLabels\": {\n                    \"additionalProperties\": {\n                     \"type\": \"string\"\n                    },\n                    \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\",\n                  \"x-kubernetes-map-type\": \"atomic\"\n                 }\n                },\n                \"required\": [\n                 \"name\"\n                ],\n                \"type\": \"object\"\n               },\n               \"target\": {\n                \"description\": \"target specifies the target value for the given metric\",\n                \"properties\": {\n                 \"averageUtilization\": {\n                  \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n                  \"format\": \"int32\",\n                  \"type\": \"integer\"\n                 },\n                 \"averageValue\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 },\n                 \"type\": {\n                  \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"value is the target value of the metric (as a quantity).\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 }\n                },\n                \"required\": [\n                 \"type\"\n                ],\n                \"type\": \"object\"\n               }\n              },\n              \"required\": [\n               \"metric\",\n               \"target\"\n              ],\n              \"type\": \"object\"\n             },\n             \"resource\": {\n              \"description\": \"resource refers to a resource metric (such as those specified in\\nrequests and limits) known to Kubernetes describing each pod in the\\ncurrent scale target (e.g. CPU or memory). Such metrics are built in to\\nKubernetes, and have special scaling options on top of those available\\nto normal per-pod metrics using the \\\"pods\\\" source.\",\n              \"properties\": {\n               \"name\": {\n                \"description\": \"name is the name of the resource in question.\",\n                \"type\": \"string\"\n               },\n               \"target\": {\n                \"description\": \"target specifies the target value for the given metric\",\n                \"properties\": {\n                 \"averageUtilization\": {\n                  \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n                  \"format\": \"int32\",\n                  \"type\": \"integer\"\n                 },\n                 \"averageValue\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 },\n                 \"type\": {\n                  \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n                  \"type\": \"string\"\n                 },\n                 \"value\": {\n                  \"anyOf\": [\n                   {\n                    \"type\": \"integer\"\n                   },\n                   {\n                    \"type\": \"string\"\n                   }\n                  ],\n                  \"description\": \"value is the target value of the metric (as a quantity).\",\n                  \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n                  \"x-kubernetes-int-or-string\": true\n                 }\n                },\n                \"required\": [\n                 \"type\"\n                ],\n                \"type\": \"object\"\n               }\n              },\n              \"required\": [\n               \"name\",\n               \"target\"\n              ],\n              \"type\": \"object\"\n             },\n             \"type\": {\n              \"description\": \"type is the type of metric source.  It should be one of \\\"ContainerResource\\\", \\\"External\\\",\\n\\\"Object\\\", \\\"Pods\\\" or \\\"Resource\\\", each mapping to a matching field in the object.\\nNote: \\\"ContainerResource\\\" type is available on when the feature-gate\\nHPAContainerMetrics is enabled\",\n              \"type\": \"string\"\n             }\n            },\n            \"required\": [\n             \"type\"\n            ],\n            \"type\": \"object\"\n           },\n           \"scaleInThreshold\": {\n            \"description\": \"The threshold to use for scaling in. It must be of the same type as\\nthe one used for scaling up, defined in the metric field.\",\n            \"properties\": {\n             \"averageUtilization\": {\n              \"description\": \"averageUtilization is the target value of the average of the\\nresource metric across all relevant pods, represented as a percentage of\\nthe requested value of the resource for the pods.\\nCurrently only valid for Resource metric source type\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"averageValue\": {\n              \"anyOf\": [\n               {\n                \"type\": \"integer\"\n               },\n               {\n                \"type\": \"string\"\n               }\n              ],\n              \"description\": \"averageValue is the target value of the average of the\\nmetric across all relevant pods (as a quantity)\",\n              \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n              \"x-kubernetes-int-or-string\": true\n             },\n             \"type\": {\n              \"description\": \"type represents whether the metric type is Utilization, Value, or AverageValue\",\n              \"type\": \"string\"\n             },\n             \"value\": {\n              \"anyOf\": [\n               {\n                \"type\": \"integer\"\n               },\n               {\n                \"type\": \"string\"\n               }\n              ],\n              \"description\": \"value is the target value of the metric (as a quantity).\",\n              \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n              \"x-kubernetes-int-or-string\": true\n             }\n            },\n            \"required\": [\n             \"type\"\n            ],\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"minReplicas\": {\n         \"default\": 1,\n         \"description\": \"The miminum number of pods when scaling.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        }\n       },\n       \"required\": [\n        \"maxReplicas\"\n       ],\n       \"type\": \"object\"\n      },\n      \"scaledObject\": {\n       \"description\": \"It refers to an autoscaling definition through a scaledObject.\\nIf type is \\\"ScaledObject\\\", this must be set.\",\n       \"properties\": {\n        \"behavior\": {\n         \"description\": \"Specifies the scaling behavior for both scale out and in.\",\n         \"properties\": {\n          \"scaleDown\": {\n           \"description\": \"scaleDown is scaling policy for scaling Down.\\nIf not set, the default value is to allow to scale down to minReplicas pods, with a\\n300 second stabilization window (i.e., the highest recommendation for\\nthe last 300sec is used).\",\n           \"properties\": {\n            \"policies\": {\n             \"description\": \"policies is a list of potential scaling polices which can be used during scaling.\\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid\",\n             \"items\": {\n              \"description\": \"HPAScalingPolicy is a single policy which must hold true for a specified past interval.\",\n              \"properties\": {\n               \"periodSeconds\": {\n                \"description\": \"periodSeconds specifies the window of time for which the policy should hold true.\\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               },\n               \"type\": {\n                \"description\": \"type is used to specify the scaling policy.\",\n                \"type\": \"string\"\n               },\n               \"value\": {\n                \"description\": \"value contains the amount of change which is permitted by the policy.\\nIt must be greater than zero\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               }\n              },\n              \"required\": [\n               \"periodSeconds\",\n               \"type\",\n               \"value\"\n              ],\n              \"type\": \"object\"\n             },\n             \"type\": \"array\",\n             \"x-kubernetes-list-type\": \"atomic\"\n            },\n            \"selectPolicy\": {\n             \"description\": \"selectPolicy is used to specify which policy should be used.\\nIf not set, the default value Max is used.\",\n             \"type\": \"string\"\n            },\n            \"stabilizationWindowSeconds\": {\n             \"description\": \"stabilizationWindowSeconds is the number of seconds for which past recommendations should be\\nconsidered while scaling up or scaling down.\\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\\nIf not set, use the default values:\\n- For scale up: 0 (i.e. no stabilization is done).\\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).\",\n             \"format\": \"int32\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"scaleUp\": {\n           \"description\": \"scaleUp is scaling policy for scaling Up.\\nIf not set, the default value is the higher of:\\n  * increase no more than 4 pods per 60 seconds\\n  * double the number of pods per 60 seconds\\nNo stabilization is used.\",\n           \"properties\": {\n            \"policies\": {\n             \"description\": \"policies is a list of potential scaling polices which can be used during scaling.\\nAt least one policy must be specified, otherwise the HPAScalingRules will be discarded as invalid\",\n             \"items\": {\n              \"description\": \"HPAScalingPolicy is a single policy which must hold true for a specified past interval.\",\n              \"properties\": {\n               \"periodSeconds\": {\n                \"description\": \"periodSeconds specifies the window of time for which the policy should hold true.\\nPeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               },\n               \"type\": {\n                \"description\": \"type is used to specify the scaling policy.\",\n                \"type\": \"string\"\n               },\n               \"value\": {\n                \"description\": \"value contains the amount of change which is permitted by the policy.\\nIt must be greater than zero\",\n                \"format\": \"int32\",\n                \"type\": \"integer\"\n               }\n              },\n              \"required\": [\n               \"periodSeconds\",\n               \"type\",\n               \"value\"\n              ],\n              \"type\": \"object\"\n             },\n             \"type\": \"array\",\n             \"x-kubernetes-list-type\": \"atomic\"\n            },\n            \"selectPolicy\": {\n             \"description\": \"selectPolicy is used to specify which policy should be used.\\nIf not set, the default value Max is used.\",\n             \"type\": \"string\"\n            },\n            \"stabilizationWindowSeconds\": {\n             \"description\": \"stabilizationWindowSeconds is the number of seconds for which past recommendations should be\\nconsidered while scaling up or scaling down.\\nStabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).\\nIf not set, use the default values:\\n- For scale up: 0 (i.e. no stabilization is done).\\n- For scale down: 300 (i.e. the stabilization window is 300 seconds long).\",\n             \"format\": \"int32\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"cooldownPeriod\": {\n         \"default\": 30,\n         \"description\": \"Defines the time to wait between scaling actions. This is helpful to avoid constant scaling out/in. Default: 30s.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"maxReplicas\": {\n         \"description\": \"The maximum number of pods when scaling.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"metrics\": {\n         \"description\": \"The list of prometheus queries that will be used for scaling.\",\n         \"items\": {\n          \"properties\": {\n           \"authSecret\": {\n            \"description\": \"The secret that contains prometheus credentials. Supports basic auth, bearer tokens, and TLS authentication.\\nIt will ignored if the type is not prometheus\",\n            \"type\": \"string\"\n           },\n           \"metricType\": {\n            \"description\": \"Represents whether the metric type is Utilization, Value, or AverageValue.\\nAllowed types are 'Value' or 'AverageValue' for prometheus and\\n'Utilization' or 'AverageValue' for cpu/memory. If not specified, it defaults to Value\\nfor prometheus and Utilization for cpu/memory.\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"The custom name of this metric, which can be used for logging\\nor referring to this particular metric.\",\n            \"type\": \"string\"\n           },\n           \"prometheus\": {\n            \"description\": \"The detail about how to fetch metrics from Prometheus and scale workloads based on them.\\nif type is \\\"prometheus\\\", this must be set.\",\n            \"properties\": {\n             \"authModes\": {\n              \"default\": \"\",\n              \"description\": \"The authentication methods for Prometheus.\\nAllowed types are 'basic', 'bearer', 'tls', 'custom' and 'tls,basic'.\\nFor 'basic' type, 'username' and 'password' are required fields in AuthSecret.\\nFor 'bearer' type, 'bearerToken' is required field in AuthSecret.\\nFor 'tls' type, 'ca', 'cert' and 'key' are required fields in AuthSecret.\\nFor 'custom' type, 'customAuthHeader' and 'customAuthValue' are required fields in AuthSecret.\\nFor 'tls,basic' type, 'username', 'password', 'ca', 'cert' and 'key' are required fields in AuthSecret.\",\n              \"type\": \"string\"\n             },\n             \"query\": {\n              \"description\": \"The PromQL query to fetch metrics (e.g., sum(vertica_sessions_running_counter{type=\\\"active\\\", initiator=\\\"user\\\"})).\",\n              \"type\": \"string\"\n             },\n             \"scaleInThreshold\": {\n              \"description\": \"This is the lower bound at which the autoscaler starts scaling in to the minimum replica count.\\nIf the metric falls below threshold but is still above this value, the current replica count remains unchanged.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"serverAddress\": {\n              \"description\": \"The URL of the Prometheus server.\",\n              \"type\": \"string\"\n             },\n             \"threshold\": {\n              \"description\": \"The threshold value at which scale out is triggered.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"unsafeSsl\": {\n              \"default\": false,\n              \"description\": \"Used for skipping certificate check e.g: using self-signed certs.\",\n              \"type\": \"boolean\"\n             },\n             \"useCachedMetrics\": {\n              \"default\": false,\n              \"description\": \"Enables caching of metric values during polling interval. It is Used to control whether the autoscaler should use cached metrics for scaling\\ndecisions rather than querying the external metric provider (e.g., Prometheus) on each scale event. This feature is not supported for cpu and memory.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"required\": [\n             \"query\",\n             \"serverAddress\",\n             \"threshold\"\n            ],\n            \"type\": \"object\"\n           },\n           \"resource\": {\n            \"description\": \"The detail about the target value and container name. if type is cpu/memory\\nthis must be set.\",\n            \"properties\": {\n             \"threshold\": {\n              \"description\": \"The value to trigger scaling for.\\n\\n\\n- When using Utilization, the target value is the average of the resource metric across all relevant pods,\\n\\t represented as a percentage of the requested value of the resource for the pods.\\n- When using AverageValue, the target value is the target value of the average of the metric\\n  across all relevant pods (quantity).\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             }\n            },\n            \"required\": [\n             \"threshold\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": {\n            \"default\": \"\",\n            \"description\": \"The type of metric that is being defined. It can be either cpu, memory, or prometheus.\\nAn empty string currently defaults prometheus.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"minReplicas\": {\n         \"default\": 1,\n         \"description\": \"The miminum number of pods when scaling.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"pollingInterval\": {\n         \"default\": 30,\n         \"description\": \"The time interval at which the scaler will check the metric condition and scale the target (in seconds).\\nIf not specified, the default is 30 seconds.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        }\n       },\n       \"required\": [\n        \"maxReplicas\",\n        \"metrics\"\n       ],\n       \"type\": \"object\"\n      },\n      \"type\": {\n       \"default\": \"ScaledObject\",\n       \"description\": \"The type of autoscaler. It must be one of \\\"HPA\\\" or \\\"ScaledObject\\\".\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"scalingGranularity\": {\n     \"default\": \"Subcluster\",\n     \"description\": \"This defines how the scaling will happen.  This can be one of the following:\\n- Subcluster: Scaling will be achieved by creating or deleting entire subclusters.\\n  The template for new subclusters are either the template if filled out\\n  or an existing subcluster that matches the service name.\\n- Pod: Only increase or decrease the size of an existing subcluster.\\n  If multiple subclusters are selected by the serviceName, this will grow\\n  the last subcluster only.\",\n     \"type\": \"string\"\n    },\n    \"serviceName\": {\n     \"description\": \"This acts as a selector for the subclusters that are being scaled together.\\nEach subcluster has a service name field, which if omitted is the same\\nname as the subcluster name.  Multiple subclusters that have the same\\nservice name use the same service object.\\nif this field is empty, all the subclusters will be selected for scaling.\",\n     \"type\": \"string\"\n    },\n    \"targetSize\": {\n     \"description\": \"This is the total pod count for all subclusters that match the\\nserviceName.  Changing this value may trigger a change in the\\nVerticaDB that is associated with this object.  This value is generally\\nleft as zero.  It will get initialized in the operator and then modified\\nvia the /scale subresource.\",\n     \"format\": \"int32\",\n     \"type\": \"integer\"\n    },\n    \"template\": {\n     \"description\": \"When the scaling granularity is Subcluster, this field defines a template\\nto use for when a new subcluster needs to be created.  If size is 0, then\\nthe operator will use an existing subcluster to use as the template.  If\\nsize is \\u003e 0 service name must match the serviceName parameter (if non-empty).\\n\\n\\nIf the serviceName parameter is empty, service name can be an existing service and\\nin that case the new subcluster will share it with other(s) subcluster, service\\nname can also be non-existing and all the subclusters created from the template\\nwill share that service. If service name is empty, each new subcluster will have its\\nown service.\\n\\n\\nThe name of the new subcluster is always auto generated.  If the name is set\\nhere it will be used as a prefix for the new subcluster.  Otherwise, we\\nuse the name of this VerticaAutoscaler object as a prefix for all\\nsubclusters.\",\n     \"properties\": {\n      \"affinity\": {\n       \"description\": \"Like nodeSelector this allows you to constrain the pod only to certain\\npods. It is more expressive than just using node selectors.\\nMore info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity\",\n       \"properties\": {\n        \"nodeAffinity\": {\n         \"description\": \"Describes node affinity scheduling rules for the pod.\",\n         \"properties\": {\n          \"preferredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"The scheduler will prefer to schedule pods to nodes that satisfy\\nthe affinity expressions specified by this field, but it may choose\\na node that violates one or more of the expressions. The node that is\\nmost preferred is the one with the greatest sum of weights, i.e.\\nfor each node that meets all of the scheduling requirements (resource\\nrequest, requiredDuringScheduling affinity expressions, etc.),\\ncompute a sum by iterating through the elements of this field and adding\\n\\\"weight\\\" to the sum if the node matches the corresponding matchExpressions; the\\nnode(s) with the highest sum are the most preferred.\",\n           \"items\": {\n            \"description\": \"An empty preferred scheduling term matches all objects with implicit weight 0\\n(i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).\",\n            \"properties\": {\n             \"preference\": {\n              \"description\": \"A node selector term, associated with the corresponding weight.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"A list of node selector requirements by node's labels.\",\n                \"items\": {\n                 \"description\": \"A node selector requirement is a selector that contains values, a key, and an operator\\nthat relates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"The label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"Represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. If the operator is Gt or Lt, the values\\narray must have a single element, which will be interpreted as an integer.\\nThis array is replaced during a strategic merge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchFields\": {\n                \"description\": \"A list of node selector requirements by node's fields.\",\n                \"items\": {\n                 \"description\": \"A node selector requirement is a selector that contains values, a key, and an operator\\nthat relates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"The label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"Represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. If the operator is Gt or Lt, the values\\narray must have a single element, which will be interpreted as an integer.\\nThis array is replaced during a strategic merge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"weight\": {\n              \"description\": \"Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             }\n            },\n            \"required\": [\n             \"preference\",\n             \"weight\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-type\": \"atomic\"\n          },\n          \"requiredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"If the affinity requirements specified by this field are not met at\\nscheduling time, the pod will not be scheduled onto the node.\\nIf the affinity requirements specified by this field cease to be met\\nat some point during pod execution (e.g. due to an update), the system\\nmay or may not try to eventually evict the pod from its node.\",\n           \"properties\": {\n            \"nodeSelectorTerms\": {\n             \"description\": \"Required. A list of node selector terms. The terms are ORed.\",\n             \"items\": {\n              \"description\": \"A null or empty node selector term matches no objects. The requirements of\\nthem are ANDed.\\nThe TopologySelectorTerm type implements a subset of the NodeSelectorTerm.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"A list of node selector requirements by node's labels.\",\n                \"items\": {\n                 \"description\": \"A node selector requirement is a selector that contains values, a key, and an operator\\nthat relates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"The label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"Represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. If the operator is Gt or Lt, the values\\narray must have a single element, which will be interpreted as an integer.\\nThis array is replaced during a strategic merge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchFields\": {\n                \"description\": \"A list of node selector requirements by node's fields.\",\n                \"items\": {\n                 \"description\": \"A node selector requirement is a selector that contains values, a key, and an operator\\nthat relates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"The label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"Represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"An array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. If the operator is Gt or Lt, the values\\narray must have a single element, which will be interpreted as an integer.\\nThis array is replaced during a strategic merge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"type\": \"array\",\n             \"x-kubernetes-list-type\": \"atomic\"\n            }\n           },\n           \"required\": [\n            \"nodeSelectorTerms\"\n           ],\n           \"type\": \"object\",\n           \"x-kubernetes-map-type\": \"atomic\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"podAffinity\": {\n         \"description\": \"Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).\",\n         \"properties\": {\n          \"preferredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"The scheduler will prefer to schedule pods to nodes that satisfy\\nthe affinity expressions specified by this field, but it may choose\\na node that violates one or more of the expressions. The node that is\\nmost preferred is the one with the greatest sum of weights, i.e.\\nfor each node that meets all of the scheduling requirements (resource\\nrequest, requiredDuringScheduling affinity expressions, etc.),\\ncompute a sum by iterating through the elements of this field and adding\\n\\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\\nnode(s) with the highest sum are the most preferred.\",\n           \"items\": {\n            \"description\": \"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\n            \"properties\": {\n             \"podAffinityTerm\": {\n              \"description\": \"Required. A pod affinity term, associated with the corresponding weight.\",\n              \"properties\": {\n               \"labelSelector\": {\n                \"description\": \"A label query over a set of resources, in this case pods.\\nIf it's null, this PodAffinityTerm matches with no Pods.\",\n                \"properties\": {\n                 \"matchExpressions\": {\n                  \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                  \"items\": {\n                   \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                   \"properties\": {\n                    \"key\": {\n                     \"description\": \"key is the label key that the selector applies to.\",\n                     \"type\": \"string\"\n                    },\n                    \"operator\": {\n                     \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                     \"type\": \"string\"\n                    },\n                    \"values\": {\n                     \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                     \"items\": {\n                      \"type\": \"string\"\n                     },\n                     \"type\": \"array\",\n                     \"x-kubernetes-list-type\": \"atomic\"\n                    }\n                   },\n                   \"required\": [\n                    \"key\",\n                    \"operator\"\n                   ],\n                   \"type\": \"object\"\n                  },\n                  \"type\": \"array\",\n                  \"x-kubernetes-list-type\": \"atomic\"\n                 },\n                 \"matchLabels\": {\n                  \"additionalProperties\": {\n                   \"type\": \"string\"\n                  },\n                  \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                  \"type\": \"object\"\n                 }\n                },\n                \"type\": \"object\",\n                \"x-kubernetes-map-type\": \"atomic\"\n               },\n               \"matchLabelKeys\": {\n                \"description\": \"MatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"mismatchLabelKeys\": {\n                \"description\": \"MismatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"namespaceSelector\": {\n                \"description\": \"A label query over the set of namespaces that the term applies to.\\nThe term is applied to the union of the namespaces selected by this field\\nand the ones listed in the namespaces field.\\nnull selector and null or empty namespaces list means \\\"this pod's namespace\\\".\\nAn empty selector ({}) matches all namespaces.\",\n                \"properties\": {\n                 \"matchExpressions\": {\n                  \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                  \"items\": {\n                   \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                   \"properties\": {\n                    \"key\": {\n                     \"description\": \"key is the label key that the selector applies to.\",\n                     \"type\": \"string\"\n                    },\n                    \"operator\": {\n                     \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                     \"type\": \"string\"\n                    },\n                    \"values\": {\n                     \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                     \"items\": {\n                      \"type\": \"string\"\n                     },\n                     \"type\": \"array\",\n                     \"x-kubernetes-list-type\": \"atomic\"\n                    }\n                   },\n                   \"required\": [\n                    \"key\",\n                    \"operator\"\n                   ],\n                   \"type\": \"object\"\n                  },\n                  \"type\": \"array\",\n                  \"x-kubernetes-list-type\": \"atomic\"\n                 },\n                 \"matchLabels\": {\n                  \"additionalProperties\": {\n                   \"type\": \"string\"\n                  },\n                  \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                  \"type\": \"object\"\n                 }\n                },\n                \"type\": \"object\",\n                \"x-kubernetes-map-type\": \"atomic\"\n               },\n               \"namespaces\": {\n                \"description\": \"namespaces specifies a static list of namespace names that the term applies to.\\nThe term is applied to the union of the namespaces listed in this field\\nand the ones selected by namespaceSelector.\\nnull or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"topologyKey\": {\n                \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\\nwhose value of the label with key topologyKey matches that of any node on which any of the\\nselected pods is running.\\nEmpty topologyKey is not allowed.\",\n                \"type\": \"string\"\n               }\n              },\n              \"required\": [\n               \"topologyKey\"\n              ],\n              \"type\": \"object\"\n             },\n             \"weight\": {\n              \"description\": \"weight associated with matching the corresponding podAffinityTerm,\\nin the range 1-100.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             }\n            },\n            \"required\": [\n             \"podAffinityTerm\",\n             \"weight\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-type\": \"atomic\"\n          },\n          \"requiredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"If the affinity requirements specified by this field are not met at\\nscheduling time, the pod will not be scheduled onto the node.\\nIf the affinity requirements specified by this field cease to be met\\nat some point during pod execution (e.g. due to a pod label update), the\\nsystem may or may not try to eventually evict the pod from its node.\\nWhen there are multiple elements, the lists of nodes corresponding to each\\npodAffinityTerm are intersected, i.e. all terms must be satisfied.\",\n           \"items\": {\n            \"description\": \"Defines a set of pods (namely those matching the labelSelector\\nrelative to the given namespace(s)) that this pod should be\\nco-located (affinity) or not co-located (anti-affinity) with,\\nwhere co-located is defined as running on a node whose value of\\nthe label with key \\u003ctopologyKey\\u003e matches that of any node on which\\na pod of the set of pods is running\",\n            \"properties\": {\n             \"labelSelector\": {\n              \"description\": \"A label query over a set of resources, in this case pods.\\nIf it's null, this PodAffinityTerm matches with no Pods.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                \"items\": {\n                 \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"key is the label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchLabels\": {\n                \"additionalProperties\": {\n                 \"type\": \"string\"\n                },\n                \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"matchLabelKeys\": {\n              \"description\": \"MatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"mismatchLabelKeys\": {\n              \"description\": \"MismatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"namespaceSelector\": {\n              \"description\": \"A label query over the set of namespaces that the term applies to.\\nThe term is applied to the union of the namespaces selected by this field\\nand the ones listed in the namespaces field.\\nnull selector and null or empty namespaces list means \\\"this pod's namespace\\\".\\nAn empty selector ({}) matches all namespaces.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                \"items\": {\n                 \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"key is the label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchLabels\": {\n                \"additionalProperties\": {\n                 \"type\": \"string\"\n                },\n                \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"namespaces\": {\n              \"description\": \"namespaces specifies a static list of namespace names that the term applies to.\\nThe term is applied to the union of the namespaces listed in this field\\nand the ones selected by namespaceSelector.\\nnull or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"topologyKey\": {\n              \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\\nwhose value of the label with key topologyKey matches that of any node on which any of the\\nselected pods is running.\\nEmpty topologyKey is not allowed.\",\n              \"type\": \"string\"\n             }\n            },\n            \"required\": [\n             \"topologyKey\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-type\": \"atomic\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"podAntiAffinity\": {\n         \"description\": \"Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).\",\n         \"properties\": {\n          \"preferredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"The scheduler will prefer to schedule pods to nodes that satisfy\\nthe anti-affinity expressions specified by this field, but it may choose\\na node that violates one or more of the expressions. The node that is\\nmost preferred is the one with the greatest sum of weights, i.e.\\nfor each node that meets all of the scheduling requirements (resource\\nrequest, requiredDuringScheduling anti-affinity expressions, etc.),\\ncompute a sum by iterating through the elements of this field and adding\\n\\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the\\nnode(s) with the highest sum are the most preferred.\",\n           \"items\": {\n            \"description\": \"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\n            \"properties\": {\n             \"podAffinityTerm\": {\n              \"description\": \"Required. A pod affinity term, associated with the corresponding weight.\",\n              \"properties\": {\n               \"labelSelector\": {\n                \"description\": \"A label query over a set of resources, in this case pods.\\nIf it's null, this PodAffinityTerm matches with no Pods.\",\n                \"properties\": {\n                 \"matchExpressions\": {\n                  \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                  \"items\": {\n                   \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                   \"properties\": {\n                    \"key\": {\n                     \"description\": \"key is the label key that the selector applies to.\",\n                     \"type\": \"string\"\n                    },\n                    \"operator\": {\n                     \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                     \"type\": \"string\"\n                    },\n                    \"values\": {\n                     \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                     \"items\": {\n                      \"type\": \"string\"\n                     },\n                     \"type\": \"array\",\n                     \"x-kubernetes-list-type\": \"atomic\"\n                    }\n                   },\n                   \"required\": [\n                    \"key\",\n                    \"operator\"\n                   ],\n                   \"type\": \"object\"\n                  },\n                  \"type\": \"array\",\n                  \"x-kubernetes-list-type\": \"atomic\"\n                 },\n                 \"matchLabels\": {\n                  \"additionalProperties\": {\n                   \"type\": \"string\"\n                  },\n                  \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                  \"type\": \"object\"\n                 }\n                },\n                \"type\": \"object\",\n                \"x-kubernetes-map-type\": \"atomic\"\n               },\n               \"matchLabelKeys\": {\n                \"description\": \"MatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"mismatchLabelKeys\": {\n                \"description\": \"MismatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"namespaceSelector\": {\n                \"description\": \"A label query over the set of namespaces that the term applies to.\\nThe term is applied to the union of the namespaces selected by this field\\nand the ones listed in the namespaces field.\\nnull selector and null or empty namespaces list means \\\"this pod's namespace\\\".\\nAn empty selector ({}) matches all namespaces.\",\n                \"properties\": {\n                 \"matchExpressions\": {\n                  \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                  \"items\": {\n                   \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                   \"properties\": {\n                    \"key\": {\n                     \"description\": \"key is the label key that the selector applies to.\",\n                     \"type\": \"string\"\n                    },\n                    \"operator\": {\n                     \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                     \"type\": \"string\"\n                    },\n                    \"values\": {\n                     \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                     \"items\": {\n                      \"type\": \"string\"\n                     },\n                     \"type\": \"array\",\n                     \"x-kubernetes-list-type\": \"atomic\"\n                    }\n                   },\n                   \"required\": [\n                    \"key\",\n                    \"operator\"\n                   ],\n                   \"type\": \"object\"\n                  },\n                  \"type\": \"array\",\n                  \"x-kubernetes-list-type\": \"atomic\"\n                 },\n                 \"matchLabels\": {\n                  \"additionalProperties\": {\n                   \"type\": \"string\"\n                  },\n                  \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                  \"type\": \"object\"\n                 }\n                },\n                \"type\": \"object\",\n                \"x-kubernetes-map-type\": \"atomic\"\n               },\n               \"namespaces\": {\n                \"description\": \"namespaces specifies a static list of namespace names that the term applies to.\\nThe term is applied to the union of the namespaces listed in this field\\nand the ones selected by namespaceSelector.\\nnull or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n                \"items\": {\n                 \"type\": \"string\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"topologyKey\": {\n                \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\\nwhose value of the label with key topologyKey matches that of any node on which any of the\\nselected pods is running.\\nEmpty topologyKey is not allowed.\",\n                \"type\": \"string\"\n               }\n              },\n              \"required\": [\n               \"topologyKey\"\n              ],\n              \"type\": \"object\"\n             },\n             \"weight\": {\n              \"description\": \"weight associated with matching the corresponding podAffinityTerm,\\nin the range 1-100.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             }\n            },\n            \"required\": [\n             \"podAffinityTerm\",\n             \"weight\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-type\": \"atomic\"\n          },\n          \"requiredDuringSchedulingIgnoredDuringExecution\": {\n           \"description\": \"If the anti-affinity requirements specified by this field are not met at\\nscheduling time, the pod will not be scheduled onto the node.\\nIf the anti-affinity requirements specified by this field cease to be met\\nat some point during pod execution (e.g. due to a pod label update), the\\nsystem may or may not try to eventually evict the pod from its node.\\nWhen there are multiple elements, the lists of nodes corresponding to each\\npodAffinityTerm are intersected, i.e. all terms must be satisfied.\",\n           \"items\": {\n            \"description\": \"Defines a set of pods (namely those matching the labelSelector\\nrelative to the given namespace(s)) that this pod should be\\nco-located (affinity) or not co-located (anti-affinity) with,\\nwhere co-located is defined as running on a node whose value of\\nthe label with key \\u003ctopologyKey\\u003e matches that of any node on which\\na pod of the set of pods is running\",\n            \"properties\": {\n             \"labelSelector\": {\n              \"description\": \"A label query over a set of resources, in this case pods.\\nIf it's null, this PodAffinityTerm matches with no Pods.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                \"items\": {\n                 \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"key is the label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchLabels\": {\n                \"additionalProperties\": {\n                 \"type\": \"string\"\n                },\n                \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"matchLabelKeys\": {\n              \"description\": \"MatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both matchLabelKeys and labelSelector.\\nAlso, matchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"mismatchLabelKeys\": {\n              \"description\": \"MismatchLabelKeys is a set of pod label keys to select which pods will\\nbe taken into consideration. The keys are used to lookup values from the\\nincoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`\\nto select the group of existing pods which pods will be taken into consideration\\nfor the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming\\npod labels will be ignored. The default value is empty.\\nThe same key is forbidden to exist in both mismatchLabelKeys and labelSelector.\\nAlso, mismatchLabelKeys cannot be set when labelSelector isn't set.\\nThis is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"namespaceSelector\": {\n              \"description\": \"A label query over the set of namespaces that the term applies to.\\nThe term is applied to the union of the namespaces selected by this field\\nand the ones listed in the namespaces field.\\nnull selector and null or empty namespaces list means \\\"this pod's namespace\\\".\\nAn empty selector ({}) matches all namespaces.\",\n              \"properties\": {\n               \"matchExpressions\": {\n                \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n                \"items\": {\n                 \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that\\nrelates the key and values.\",\n                 \"properties\": {\n                  \"key\": {\n                   \"description\": \"key is the label key that the selector applies to.\",\n                   \"type\": \"string\"\n                  },\n                  \"operator\": {\n                   \"description\": \"operator represents a key's relationship to a set of values.\\nValid operators are In, NotIn, Exists and DoesNotExist.\",\n                   \"type\": \"string\"\n                  },\n                  \"values\": {\n                   \"description\": \"values is an array of string values. If the operator is In or NotIn,\\nthe values array must be non-empty. If the operator is Exists or DoesNotExist,\\nthe values array must be empty. This array is replaced during a strategic\\nmerge patch.\",\n                   \"items\": {\n                    \"type\": \"string\"\n                   },\n                   \"type\": \"array\",\n                   \"x-kubernetes-list-type\": \"atomic\"\n                  }\n                 },\n                 \"required\": [\n                  \"key\",\n                  \"operator\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"type\": \"array\",\n                \"x-kubernetes-list-type\": \"atomic\"\n               },\n               \"matchLabels\": {\n                \"additionalProperties\": {\n                 \"type\": \"string\"\n                },\n                \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\\nmap is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the\\noperator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n                \"type\": \"object\"\n               }\n              },\n              \"type\": \"object\",\n              \"x-kubernetes-map-type\": \"atomic\"\n             },\n             \"namespaces\": {\n              \"description\": \"namespaces specifies a static list of namespace names that the term applies to.\\nThe term is applied to the union of the namespaces listed in this field\\nand the ones selected by namespaceSelector.\\nnull or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\",\n              \"x-kubernetes-list-type\": \"atomic\"\n             },\n             \"topologyKey\": {\n              \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching\\nthe labelSelector in the specified namespaces, where co-located is defined as running on a node\\nwhose value of the label with key topologyKey matches that of any node on which any of the\\nselected pods is running.\\nEmpty topologyKey is not allowed.\",\n              \"type\": \"string\"\n             }\n            },\n            \"required\": [\n             \"topologyKey\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-type\": \"atomic\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"annotations\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"A map of key/value pairs appended to the stateful metadata.annotations of\\nthe subcluster.\",\n       \"type\": \"object\"\n      },\n      \"clientNodePort\": {\n       \"description\": \"When setting serviceType to NodePort, this parameter allows you to define the\\nport that is opened at each node for Vertica client connections. If using\\nNodePort and this is omitted, Kubernetes will choose the port\\nautomatically. This port must be from within the defined range allocated\\nby the control plane (default is 30000-32767).\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"externalIPs\": {\n       \"description\": \"Allows the service object to be attached to a list of external IPs that you\\nspecify. If not set, the external IP list is left empty in the service object.\\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#external-ips\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"imageOverride\": {\n       \"description\": \"This allows a different image to be used for the subcluster than the one\\nin VerticaDB.  This is intended to be used internally by the online image\\nchange process.\",\n       \"type\": \"string\"\n      },\n      \"loadBalancerIP\": {\n       \"description\": \"Specify IP address of LoadBalancer service for this subcluster.\\nThis field is ignored when serviceType != \\\"LoadBalancer\\\".\\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer\",\n       \"type\": \"string\"\n      },\n      \"name\": {\n       \"description\": \"The name of the subcluster. This is a required parameter. This cannot\\nchange after CRD creation.\",\n       \"type\": \"string\"\n      },\n      \"nodeSelector\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"A map of label keys and values to restrict Vertica node scheduling to workers\\nwith matching labels.\\nMore info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector\",\n       \"type\": \"object\"\n      },\n      \"priorityClassName\": {\n       \"description\": \"The priority class name given to pods in this subcluster. This affects\\nwhere the pod gets scheduled.\\nMore info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/#priorityclass\",\n       \"type\": \"string\"\n      },\n      \"proxy\": {\n       \"description\": \"Create client proxy pods for the subcluster if defined\\nAll incoming connections to the subclusters will be routed through the proxy pods\",\n       \"properties\": {\n        \"replicas\": {\n         \"description\": \"The number of replicas that the proxy server will have.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"resources\": {\n         \"description\": \"This defines the resource requests and limits for the client proxy pods in the subcluster.\\nIt is advisable that the request and limits match as this ensures the\\npods are assigned to the guaranteed QoS class. This will reduces the\\nchance that pods are chosen by the OOM killer.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"properties\": {\n          \"claims\": {\n           \"description\": \"Claims lists the names of resources, defined in spec.resourceClaims,\\nthat are used by this container.\\n\\n\\nThis is an alpha field and requires enabling the\\nDynamicResourceAllocation feature gate.\\n\\n\\nThis field is immutable. It can only be set for containers.\",\n           \"items\": {\n            \"description\": \"ResourceClaim references one entry in PodSpec.ResourceClaims.\",\n            \"properties\": {\n             \"name\": {\n              \"description\": \"Name must match the name of one entry in pod.spec.resourceClaims of\\nthe Pod where this field is used. It makes that resource available\\ninside a container.\",\n              \"type\": \"string\"\n             }\n            },\n            \"required\": [\n             \"name\"\n            ],\n            \"type\": \"object\"\n           },\n           \"type\": \"array\",\n           \"x-kubernetes-list-map-keys\": [\n            \"name\"\n           ],\n           \"x-kubernetes-list-type\": \"map\"\n          },\n          \"limits\": {\n           \"additionalProperties\": {\n            \"anyOf\": [\n             {\n              \"type\": \"integer\"\n             },\n             {\n              \"type\": \"string\"\n             }\n            ],\n            \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n            \"x-kubernetes-int-or-string\": true\n           },\n           \"description\": \"Limits describes the maximum amount of compute resources allowed.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n           \"type\": \"object\"\n          },\n          \"requests\": {\n           \"additionalProperties\": {\n            \"anyOf\": [\n             {\n              \"type\": \"integer\"\n             },\n             {\n              \"type\": \"string\"\n             }\n            ],\n            \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n            \"x-kubernetes-int-or-string\": true\n           },\n           \"description\": \"Requests describes the minimum amount of compute resources required.\\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\\notherwise to an implementation-defined value. Requests cannot exceed Limits.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"resources\": {\n       \"description\": \"This defines the resource requests and limits for pods in the subcluster.\\nIt is advisable that the request and limits match as this ensures the\\npods are assigned to the guaranteed QoS class. This will reduces the\\nchance that pods are chosen by the OOM killer.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n       \"properties\": {\n        \"claims\": {\n         \"description\": \"Claims lists the names of resources, defined in spec.resourceClaims,\\nthat are used by this container.\\n\\n\\nThis is an alpha field and requires enabling the\\nDynamicResourceAllocation feature gate.\\n\\n\\nThis field is immutable. It can only be set for containers.\",\n         \"items\": {\n          \"description\": \"ResourceClaim references one entry in PodSpec.ResourceClaims.\",\n          \"properties\": {\n           \"name\": {\n            \"description\": \"Name must match the name of one entry in pod.spec.resourceClaims of\\nthe Pod where this field is used. It makes that resource available\\ninside a container.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\",\n         \"x-kubernetes-list-map-keys\": [\n          \"name\"\n         ],\n         \"x-kubernetes-list-type\": \"map\"\n        },\n        \"limits\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Limits describes the maximum amount of compute resources allowed.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        },\n        \"requests\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Requests describes the minimum amount of compute resources required.\\nIf Requests is omitted for a container, it defaults to Limits if that is explicitly specified,\\notherwise to an implementation-defined value. Requests cannot exceed Limits.\\nMore info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"serviceAnnotations\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"A map of key/value pairs appended to service metadata.annotations.\",\n       \"type\": \"object\"\n      },\n      \"serviceClientPort\": {\n       \"description\": \"Client port for this subcluster's services\\nIf not set, it will use the port number specified in spec.ServiceClientPort,\\nwhich is defaulted to be 5433\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"serviceHTTPSPort\": {\n       \"description\": \"HTTPS port for this subcluster's services\\nIf not set, it will use the port number specified in spec.ServiceHTTPSPort,\\nwhich is defaulted to be 8443\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"serviceName\": {\n       \"description\": \"Identifies the name of the service object that will serve this\\nsubcluster.  If multiple subclusters share the same service name then\\nthey all share the same service object.  This allows for a single service\\nobject to round robin between multiple subclusters.  If this is left\\nblank, a service object matching the subcluster name is used.  The actual\\nname of the service object is always prefixed with the name of the owning\\nVerticaDB.\",\n       \"type\": \"string\"\n      },\n      \"serviceType\": {\n       \"default\": \"ClusterIP\",\n       \"description\": \"Identifies the type of Kubernetes service to use for external client\\nconnectivity. The default is to use a ClusterIP, which sets a stable IP\\nand port to use that is accessible only from within Kubernetes itself.\\nDepending on the service type chosen the user may need to set other\\nconfig knobs to further config it. These other knobs follow this one.\\nMore info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types\",\n       \"type\": \"string\"\n      },\n      \"shutdown\": {\n       \"description\": \"State to indicate whether the operator must shut down the subcluster\\nand not try to restart it.\",\n       \"type\": \"boolean\"\n      },\n      \"size\": {\n       \"default\": 3,\n       \"description\": \"The number of pods that the subcluster will have. This determines the\\nnumber of Vertica nodes that it will have. Changing this number will\\neither delete or schedule new pods.\\n\\n\\nThe database has a k-safety of 1. So, if this is a primary subcluster,\\nthe minimum value is 3. If this is a secondary subcluster, the minimum is\\n0.\\n\\n\\nNote, you must have a valid license to pick a value larger than 3. The\\ndefault license that comes in the vertica container is for the community\\nedition, which can only have 3 nodes. The license can be set with the\\ndb.licenseSecret parameter.\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"tolerations\": {\n       \"description\": \"Any tolerations and taints to use to aid in where to schedule a pod.\\nMore info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/\",\n       \"items\": {\n        \"description\": \"The pod this Toleration is attached to tolerates any taint that matches\\nthe triple \\u003ckey,value,effect\\u003e using the matching operator \\u003coperator\\u003e.\",\n        \"properties\": {\n         \"effect\": {\n          \"description\": \"Effect indicates the taint effect to match. Empty means match all taint effects.\\nWhen specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.\",\n          \"type\": \"string\"\n         },\n         \"key\": {\n          \"description\": \"Key is the taint key that the toleration applies to. Empty means match all taint keys.\\nIf the key is empty, operator must be Exists; this combination means to match all values and all keys.\",\n          \"type\": \"string\"\n         },\n         \"operator\": {\n          \"description\": \"Operator represents a key's relationship to the value.\\nValid operators are Exists and Equal. Defaults to Equal.\\nExists is equivalent to wildcard for value, so that a pod can\\ntolerate all taints of a particular category.\",\n          \"type\": \"string\"\n         },\n         \"tolerationSeconds\": {\n          \"description\": \"TolerationSeconds represents the period of time the toleration (which must be\\nof effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,\\nit is not set, which means tolerate the taint forever (do not evict). Zero and\\nnegative values will be treated as 0 (evict immediately) by the system.\",\n          \"format\": \"int64\",\n          \"type\": \"integer\"\n         },\n         \"value\": {\n          \"description\": \"Value is the taint value the toleration matches to.\\nIf the operator is Exists, the value should be empty, otherwise just a regular string.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"type\": {\n       \"default\": \"primary\",\n       \"description\": \"Indicates the type of subcluster it is. Valid values are: primary,\\nsecondary or transient. Types are case-sensitive.\\nYou must have at least one primary subcluster in the database.\\nIf type is omitted, it will default to a primary.\\nTransient should only be set internally by the operator during online\\nupgrade. It is used to indicate a subcluster that exists temporarily to\\nserve traffic for subclusters that are restarting with a new image.\",\n       \"type\": \"string\"\n      },\n      \"verticaHTTPNodePort\": {\n       \"description\": \"Like the clientNodePort parameter, except this controls the node port to use\\nfor the http endpoint in the Vertica server.  The same rules apply: it\\nmust be defined within the range allocated by the control plane, if\\nomitted Kubernetes will choose the port automatically.\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      }\n     },\n     \"required\": [\n      \"name\"\n     ],\n     \"type\": \"object\"\n    },\n    \"verticaDBName\": {\n     \"description\": \"The name of the VerticaDB CR that this autoscaler is defined for.  The\\nVerticaDB object must exist in the same namespace as this object.\",\n     \"type\": \"string\"\n    }\n   },\n   \"required\": [\n    \"verticaDBName\"\n   ],\n   \"type\": \"object\"\n  }\n },\n \"title\": \"Vertica Autoscaler\",\n \"type\": \"object\"\n}"
  }
}