{"kind":"VDICluster","apiVersion":"app.kvdi.io/v1","displayName":"VDI Cluster","format":"JSON","hostname":"","hostID":"00000000-0000-0000-0000-000000000000","displayhostname":"","metadata":{"capabilities":"","genealogy":"","isAnnotation":false,"isModelAnnotation":"FALSE","isNamespaced":false,"logoURL":"","model":"kvdi","modelDisplayName":"Kvdi","primaryColor":"#00B39F","published":false,"secondaryColor":"#00D3A9","shape":"circle","styleOverrides":"","subCategory":"Uncategorized","svgColor":"","svgComplete":"","svgWhite":""},"model":{"name":"kvdi","version":"0.3.5","displayName":"Kvdi","hostname":"","hostID":"00000000-0000-0000-0000-000000000000","displayhostname":"","category":{"name":"Uncategorized","metadata":null},"metadata":{"isAnnotation":false,"source_uri":"https://kvdi.github.io/kvdi/deploy/charts/kvdi-v0.3.5.tgz"},"components":null,"relationships":null},"schema":"{\n \"description\": \"VDICluster is the Schema for the vdiclusters API\",\n \"properties\": {\n  \"spec\": {\n   \"description\": \"VDIClusterSpec defines the desired state of VDICluster\",\n   \"properties\": {\n    \"app\": {\n     \"description\": \"App configurations.\",\n     \"properties\": {\n      \"auditLog\": {\n       \"description\": \"Whether to log auditing events to stdout\",\n       \"type\": \"boolean\"\n      },\n      \"corsEnabled\": {\n       \"description\": \"Whether to add CORS headers to API requests\",\n       \"type\": \"boolean\"\n      },\n      \"image\": {\n       \"description\": \"The image to use for the app instances. Defaults to the public image matching the version of the currently running manager.\",\n       \"type\": \"string\"\n      },\n      \"replicas\": {\n       \"description\": \"The number of app replicas to run\",\n       \"format\": \"int32\",\n       \"type\": \"integer\"\n      },\n      \"resources\": {\n       \"description\": \"Resource requirements to place on the app pods\",\n       \"properties\": {\n        \"limits\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        },\n        \"requests\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"serviceAnnotations\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"Extra annotations to apply to the app service.\",\n       \"type\": \"object\"\n      },\n      \"serviceType\": {\n       \"description\": \"The type of service to create in front of the app instance. Defaults to `LoadBalancer`.\",\n       \"type\": \"string\"\n      },\n      \"tls\": {\n       \"description\": \"TLS configurations for the app instance\",\n       \"properties\": {\n        \"serverSecret\": {\n         \"description\": \"A pre-existing TLS secret to use for the HTTPS listener. If not defined, a certificate is generated.\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"appNamespace\": {\n     \"description\": \"The namespace to provision application resurces in. Defaults to the `default` namespace\",\n     \"type\": \"string\"\n    },\n    \"auth\": {\n     \"description\": \"Authentication configurations\",\n     \"properties\": {\n      \"adminSecret\": {\n       \"description\": \"A secret where a generated admin password will be stored\",\n       \"type\": \"string\"\n      },\n      \"allowAnonymous\": {\n       \"description\": \"Allow anonymous users to create desktop instances\",\n       \"type\": \"boolean\"\n      },\n      \"defaultRoleRules\": {\n       \"description\": \"The rules to apply to the default role created for this cluster. These are the rules applied to anonymous users (if allowed) and non-grouped OIDC users. They can also be used for convenience when getting started. The defaults only allow for launching templates in the `appNamespace`.\",\n       \"items\": {\n        \"description\": \"Rule represents a set of permissions applied to a VDIRole. It mostly resembles an rbacv1.PolicyRule, with resources being a regex and the addition of a namespace selector.\",\n        \"properties\": {\n         \"namespaces\": {\n          \"description\": \"Namespaces this rule applies to. Only evaluated for template launching permissions. Including \\\"*\\\" as an option matches all namespaces.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"resourcePatterns\": {\n          \"description\": \"Resource regexes that match this rule. This can be template patterns, role names or user names. There is no All representation because * will have that effect on its own when the regex is evaluated. When referring to \\\"serviceaccounts\\\", only the \\\"use\\\" verb is evaluated in the context of assuming those accounts in desktop sessions. \\n **NOTE**: The `kvdi-manager` is responsible for launching pods with a service account requested for a given Desktop. If the service account itself contains more permissions than the manager itself, the Kubernetes API will deny the request. The way to remedy this would be to either mirror permissions to that ClusterRole, or make the `kvdi-manager` itself a cluster admin, both of which come with inherent risks. In the end, you can decide the best approach for your use case with regards to exposing access to the Kubernetes APIs via kvdi sessions.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"resources\": {\n          \"description\": \"Resources this rule applies to. ResourceAll matches all resources. Recognized options are: `[\\\"users\\\", \\\"roles\\\", \\\"templates\\\", \\\"serviceaccounts\\\", \\\"*\\\"]`\",\n          \"items\": {\n           \"description\": \"Resource represents the target of an API action\",\n           \"enum\": [\n            \"users\",\n            \"roles\",\n            \"templates\",\n            \"serviceaccounts\",\n            \"*\"\n           ],\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"verbs\": {\n          \"description\": \"The actions this rule applies for. VerbAll matches all actions. Recognized options are: `[\\\"create\\\", \\\"read\\\", \\\"update\\\", \\\"delete\\\", \\\"use\\\", \\\"launch\\\", \\\"*\\\"]`\",\n          \"items\": {\n           \"description\": \"Verb represents an API action\",\n           \"enum\": [\n            \"create\",\n            \"read\",\n            \"update\",\n            \"delete\",\n            \"use\",\n            \"launch\",\n            \"*\"\n           ],\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"ldapAuth\": {\n       \"description\": \"Use LDAP for authentication.\",\n       \"properties\": {\n        \"adminGroups\": {\n         \"description\": \"Group DNs that are allowed administrator access to the cluster. Kubernetes admins will still have the ability to change configurations via the CRDs.\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"bindCredentialsSecret\": {\n         \"description\": \"If you'd rather create a separate k8s secret (instead of the configured backend) for the LDAP credentials, set its name here. The keys in the secret need to be defined in the other fields still. Default is to use the secret backend.\",\n         \"type\": \"string\"\n        },\n        \"bindPasswordSecretKey\": {\n         \"description\": \"Similar to the `bindUserDNSecretKey`, but for the location of the password secret. Defaults to `ldap-password`.\",\n         \"type\": \"string\"\n        },\n        \"bindUserDNSecretKey\": {\n         \"description\": \"If you want to use the built-in secrets backend (vault or k8s currently), set this to either the name of the secret in the vault path (the key must be \\\"data\\\" for now), or the key of the secret used in `secrets.k8sSecret.secretName`. In default configurations this is `kvdi-app-secrets`. Defaults to `ldap-userdn`.\",\n         \"type\": \"string\"\n        },\n        \"doStatusCheck\": {\n         \"description\": \"When set to true, the authentication provider will query the user's attributes for the `userStatusAttribute` and make sure it matches the value in `userStatusEnabledValue` before attemtping to bind.\",\n         \"type\": \"boolean\"\n        },\n        \"tlsCACert\": {\n         \"description\": \"The base64 encoded CA certificate to use when verifying the TLS certificate of the LDAP server.\",\n         \"type\": \"string\"\n        },\n        \"tlsInsecureSkipVerify\": {\n         \"description\": \"Set to true to skip TLS verification of an `ldaps` connection.\",\n         \"type\": \"boolean\"\n        },\n        \"url\": {\n         \"description\": \"The URL to the LDAP server.\",\n         \"type\": \"string\"\n        },\n        \"userGroupsAttribute\": {\n         \"description\": \"The user attribute use to lookup group membership in LDAP. Defaults to `memberOf`.\",\n         \"type\": \"string\"\n        },\n        \"userIDAttribute\": {\n         \"description\": \"The user ID attribute to use when looking up a provided username. Defaults to `uid`. This value may be different depending on the LDAP provider. For example, in an Active Directory environment you may want to set this value to `sAMAccountName`.\",\n         \"type\": \"string\"\n        },\n        \"userSearchBase\": {\n         \"description\": \"The base scope to search for users in. Default is to search the entire directory.\",\n         \"type\": \"string\"\n        },\n        \"userStatusAttribute\": {\n         \"description\": \"The user attribute to use when querying if an account is active. Defaults to `accountStatus`. Only takes effect if `doStatusCheck` is `true`. A user is considered disabled when the attribute is both present and matches the value in `userStatusDisabledValue`.\",\n         \"type\": \"string\"\n        },\n        \"userStatusDisabledValue\": {\n         \"description\": \"The value for the `userStatusAttribute` that signifies that the user is disabled. Defaults to `inactive`.\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"localAuth\": {\n       \"description\": \"Use local auth (secret-backed) authentication\",\n       \"type\": \"object\"\n      },\n      \"oidcAuth\": {\n       \"description\": \"Use OIDC for authentication\",\n       \"properties\": {\n        \"adminGroups\": {\n         \"description\": \"Groups that are allowed administrator access to the cluster. Kubernetes admins will still have the ability to change rbac configurations via the CRDs.\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"allowNonGroupedReadOnly\": {\n         \"description\": \"Set to true if the OIDC provider does not support the \\\"groups\\\" claim (or any valid alternative) and/or you would like to allow any authenticated user read-only access.\",\n         \"type\": \"boolean\"\n        },\n        \"clientCredentialsSecret\": {\n         \"description\": \"When creating your own kubernets secret with the `clientIDKey` and `clientSecretKey`, set this to the name of the created secret. It must be in the same namespace as the manager and app instances. Defaults to `oidc-clientsecret`.\",\n         \"type\": \"string\"\n        },\n        \"clientIDKey\": {\n         \"description\": \"When using the built-in secrets backend, the key to where the client-id is stored. Set this to either the name of the secret in the vault path (the key must be \\\"data\\\" for now), or the key of the secret used in `secrets.k8sSecret.secretName`. When configuring `clientCredentialsSecret`, set this to the key in that secret. Defaults to `oidc-clientid`.\",\n         \"type\": \"string\"\n        },\n        \"clientSecretKey\": {\n         \"description\": \"Similar to `clientIDKey`, but for the location of the client secret. Defaults to `oidc-clientsecret`.\",\n         \"type\": \"string\"\n        },\n        \"groupScope\": {\n         \"description\": \"If your OIDC provider does not return a `groups` object, set this to the user attribute to use for binding authenticated users to VDIRoles. Defaults to `groups`.\",\n         \"type\": \"string\"\n        },\n        \"issuerURL\": {\n         \"description\": \"The OIDC issuer URL used for discovery\",\n         \"type\": \"string\"\n        },\n        \"preserveTokens\": {\n         \"description\": \"The access tokens returned by the OIDC provider are usually discarded after identify information is retrieved from them. If you set this to true, these fields will be available for mapping in desktops at the following paths: \\n   - `{{ .Session.Data.access_token }}`   - `{{ .Session.Data.token_type }}`   - `{{ .Session.Data.refresh_token }}`   - `{{ .Session.Data.expiry }}` \\n **NOTE:** This should be considered an insecure option and only turned on taking into account the inherent risks. If the access token used for authorizing actions against the kvdi API gets compromised, it would be relatively easy for the attacker to extract this information from the token and use it for authenticating against third-party resources. Additionally, when mapping these values to desktops, they will be stored temporarily in Kubernetes Secrets. The security of those secrets depends highly on your Kubernetes RBAC setup and who has access to secrets in the namespace where the Desktop is. So in short, it would be wise to only use this setting in trusted environments where access to the necessary kubernetes APIs is only available to a select group of administrators, and the risk of the user using a compromised browser is minimal.\",\n         \"type\": \"boolean\"\n        },\n        \"redirectURL\": {\n         \"description\": \"The redirect URL path configured in the OIDC provider. This should be the full path where kvdi is hosted followed by `/api/login`. For example, if `kvdi` is hosted at https://kvdi.local, then this value should be set `https://kvdi.local/api/login`.\",\n         \"type\": \"string\"\n        },\n        \"scopes\": {\n         \"description\": \"The scopes to request with the authentication request. Defaults to `[\\\"openid\\\", \\\"email\\\", \\\"profile\\\", \\\"groups\\\"]`.\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"tlsCACert\": {\n         \"description\": \"The base64 encoded CA certificate to use when verifying the TLS certificate of the OIDC provider.\",\n         \"type\": \"string\"\n        },\n        \"tlsInsecureSkipVerify\": {\n         \"description\": \"Set to true to skip TLS verification of an OIDC provider.\",\n         \"type\": \"boolean\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"tokenDuration\": {\n       \"description\": \"How long issued access tokens should be valid for. When using OIDC auth you may want to set this to a higher value (e.g. 8-10h) since the refresh token flow will not be able to lookup a user's grants from the provider. Defaults to `15m`.\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"desktops\": {\n     \"description\": \"Global desktop configurations\",\n     \"properties\": {\n      \"maxSessionLength\": {\n       \"description\": \"When configured, desktop sessions will be forcefully terminated when the time limit is reached.\",\n       \"type\": \"string\"\n      },\n      \"sessionsPerUser\": {\n       \"description\": \"The maximum number of sessions a user can run at a time. A zero value (or undefined) means no limit. When using a `userdataSpec`, you might want to set this value to 1 if you aren't using ReadWriteMany volumes. The storage controller would inevitably enforce this behavior anyway, but you would save the `kvdi-manager` some extra work.\",\n       \"type\": \"integer\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"imagePullSecrets\": {\n     \"description\": \"Pull secrets to use when pulling container images\",\n     \"items\": {\n      \"description\": \"LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.\",\n      \"properties\": {\n       \"name\": {\n        \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"metrics\": {\n     \"description\": \"Metrics configurations.\",\n     \"properties\": {\n      \"grafana\": {\n       \"description\": \"Grafana sidecar configurations.\",\n       \"properties\": {\n        \"enabled\": {\n         \"description\": \"Set to true to run a grafana sidecar with the app pods. This can be used to visualize data in the prometheus deployment.\",\n         \"type\": \"boolean\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"prometheus\": {\n       \"description\": \"Prometheus deployment configurations.g.\",\n       \"properties\": {\n        \"create\": {\n         \"description\": \"Set to true to create a prometheus instance.\",\n         \"type\": \"boolean\"\n        },\n        \"resources\": {\n         \"description\": \"Resource requirements to place on the Prometheus deployment\",\n         \"properties\": {\n          \"limits\": {\n           \"additionalProperties\": {\n            \"anyOf\": [\n             {\n              \"type\": \"integer\"\n             },\n             {\n              \"type\": \"string\"\n             }\n            ],\n            \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n            \"x-kubernetes-int-or-string\": true\n           },\n           \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n           \"type\": \"object\"\n          },\n          \"requests\": {\n           \"additionalProperties\": {\n            \"anyOf\": [\n             {\n              \"type\": \"integer\"\n             },\n             {\n              \"type\": \"string\"\n             }\n            ],\n            \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n            \"x-kubernetes-int-or-string\": true\n           },\n           \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"serviceMonitor\": {\n       \"description\": \"Configurations for creating a ServiceMonitor CR for a pre-existing prometheus-operator installation.\",\n       \"properties\": {\n        \"create\": {\n         \"description\": \"Set to true to create a ServiceMonitor object for the kvdi metrics.\",\n         \"type\": \"boolean\"\n        },\n        \"labels\": {\n         \"additionalProperties\": {\n          \"type\": \"string\"\n         },\n         \"description\": \"Extra labels to apply to the ServiceMonitor object. Set these to the selector in your prometheus-operator configuration (usually `{\\\"release\\\": \\\"\\u003chelm_release_name\\u003e\\\"}`). Defaults to `{\\\"release\\\": \\\"prometheus\\\"}`.\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"secrets\": {\n     \"description\": \"Secrets backend configurations\",\n     \"properties\": {\n      \"k8sSecret\": {\n       \"description\": \"Use a kubernetes secret for storing sensitive values. If no other coniguration is provided then this is the fallback.\",\n       \"properties\": {\n        \"secretName\": {\n         \"description\": \"The name of the secret backing the values. Default is `\\u003ccluster-name\\u003e-app-secrets`.\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"vault\": {\n       \"description\": \"Use vault for storing sensitive values. Requires kubernetes service account authentication.\",\n       \"properties\": {\n        \"address\": {\n         \"description\": \"The full URL to the vault server. Same as the `VAULT_ADDR` variable.\",\n         \"type\": \"string\"\n        },\n        \"authRole\": {\n         \"description\": \"The auth role to assume when authenticating against vault. Defaults to `kvdi`.\",\n         \"type\": \"string\"\n        },\n        \"caCertBase64\": {\n         \"description\": \"The base64 encoded CA certificate for verifying the vault server certificate.\",\n         \"type\": \"string\"\n        },\n        \"insecure\": {\n         \"description\": \"Set to true to disable TLS verification.\",\n         \"type\": \"boolean\"\n        },\n        \"secretsPath\": {\n         \"description\": \"The base path to store secrets in vault. \\\"Keys\\\" for other configurations in the context of the vault backend can be put at `\\u003csecretsPath\\u003e/\\u003csecretKey\\u003e.data`. This will change in the future to support keys inside the secret itself, instead of assuming `data`.\",\n         \"type\": \"string\"\n        },\n        \"tlsServerName\": {\n         \"description\": \"Optionally set the SNI when connecting using HTTPS.\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"userdataSelector\": {\n     \"description\": \"A configuration for selecting pre-existing PVCs to use as the $HOME directory for sessions. This configuration takes precedence over `userdataSpec`.\",\n     \"properties\": {\n      \"matchLabel\": {\n       \"description\": \"MatchLabel is a label **key** to use to select a PVC for the user. The value will in the selector will be the name of the user launching the session. Use this if your usernames may not always be DNS compliant.\",\n       \"type\": \"string\"\n      },\n      \"matchName\": {\n       \"description\": \"MatchName is a pattern to match for the name of the PVC. The string ${USERNAME} will be replaced in the pattern with the actual username when searching for the volume. Note, this will only work if usernames are DNS compliant.\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"userdataSpec\": {\n     \"description\": \"The configuration for user $HOME volumes to be managed by kVDI. \\n **NOTE:** Even though the controller will try to force the reclaim policy on created volumes to `Retain`, you may want to set it explicitly on your storage-class controller as an extra safeguard.\",\n     \"properties\": {\n      \"accessModes\": {\n       \"description\": \"AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"dataSource\": {\n       \"description\": \"This field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) * An existing custom resource that implements data population (Alpha) In order to use custom resource types that implement data population, the AnyVolumeDataSource feature gate must be enabled. If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source.\",\n       \"properties\": {\n        \"apiGroup\": {\n         \"description\": \"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.\",\n         \"type\": \"string\"\n        },\n        \"kind\": {\n         \"description\": \"Kind is the type of resource being referenced\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name is the name of resource being referenced\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"kind\",\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"resources\": {\n       \"description\": \"Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources\",\n       \"properties\": {\n        \"limits\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        },\n        \"requests\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"selector\": {\n       \"description\": \"A label query over volumes to consider for binding.\",\n       \"properties\": {\n        \"matchExpressions\": {\n         \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n         \"items\": {\n          \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"key is the label key that the selector applies to.\",\n            \"type\": \"string\"\n           },\n           \"operator\": {\n            \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n            \"type\": \"string\"\n           },\n           \"values\": {\n            \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"operator\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"matchLabels\": {\n         \"additionalProperties\": {\n          \"type\": \"string\"\n         },\n         \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"storageClassName\": {\n       \"description\": \"Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1\",\n       \"type\": \"string\"\n      },\n      \"volumeMode\": {\n       \"description\": \"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.\",\n       \"type\": \"string\"\n      },\n      \"volumeName\": {\n       \"description\": \"VolumeName is the binding reference to the PersistentVolume backing this claim.\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  }\n },\n \"title\": \"VDI Cluster\",\n \"type\": \"object\"\n}"}