{
  "id": "00000000-0000-0000-0000-000000000000",
  "schemaVersion": "core.meshery.io/v1beta1",
  "version": "v1.0.0",
  "displayName": "Destination Rule",
  "description": "",
  "format": "JSON",
  "model": {
   "id": "00000000-0000-0000-0000-000000000000",
   "schemaVersion": "core.meshery.io/v1beta1",
   "version": "v1.0.0",
   "name": "base",
   "displayName": "base",
   "description": "",
   "status": "ignored",
   "hostID": "00000000-0000-0000-0000-000000000000",
   "registrant": {
    "hostname": "artifacthub"
   },
   "category": {
    "name": "Uncategorized",
    "metadata": null
   },
   "subCategory": "Uncategorized",
   "metadata": {
    "isAnnotation": false,
    "subCategory": "Uncategorized",
    "svgColor": "\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 160 240\" fill=\"none\"\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M0 210H160L60 240L0 210Z\" fill=\"#466BB0\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M0 200L60 190V80L0 200Z\" fill=\"#466BB0\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M70 190L160 200L70 0V190Z\" fill=\"#466BB0\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n",
    "svgComplete": "",
    "svgWhite": "\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"6.386270046234131 3.7419400215148926 18.227430820465088 25.258059978485107\" fill=\"none\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M6.38627 24.7904L13.2215 23.738V12.1613L6.38627 24.7904Z\" fill=\"white\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M6.38627 25.8427H24.6137L13.2215 29L6.38627 25.8427Z\" fill=\"white\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M14.3608 23.7379L24.6137 24.7904L14.3608 3.74194V23.7379Z\" fill=\"white\"\u003e\u003c/path\u003e\u003c/svg\u003e"
   },
   "model": {
    "version": "1.21.0-rc.1"
   },
   "components": null,
   "relationships": null
  },
  "metadata": {
   "capabilities": "",
   "defaultData": "",
   "genealogy": "",
   "isAnnotation": false,
   "isNamespaced": true,
   "primaryColor": "#00B39F",
   "secondaryColor": "#00D3A9",
   "shape": "circle",
   "shapePolygonPoints": "",
   "status": "ignored",
   "styleOverrides": "",
   "styles": "",
   "subCategory": "",
   "svgColor": "\u003csvg width=\"160\" height=\"240\" viewBox=\"0 0 160 240\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n\u003cpath d=\"M0 210H160L60 240L0 210Z\" fill=\"#466BB0\"/\u003e\n\u003cpath d=\"M0 200L60 190V80L0 200Z\" fill=\"#466BB0\"/\u003e\n\u003cpath d=\"M70 190L160 200L70 0V190Z\" fill=\"#466BB0\"/\u003e\n\u003c/svg\u003e\n",
   "svgComplete": "",
   "svgWhite": "\u003csvg viewBox=\"6.386270046234131 3.7419400215148926 18.227430820465088 25.258059978485107\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\u003cpath d=\"M6.38627 24.7904L13.2215 23.738V12.1613L6.38627 24.7904Z\" fill=\"white\"/\u003e\u003cpath d=\"M6.38627 25.8427H24.6137L13.2215 29L6.38627 25.8427Z\" fill=\"white\"/\u003e\u003cpath d=\"M14.3608 23.7379L24.6137 24.7904L14.3608 3.74194V23.7379Z\" fill=\"white\"/\u003e\u003c/svg\u003e"
  },
  "component": {
   "kind": "DestinationRule",
   "version": "networking.istio.io/v1alpha3",
   "schema": "{\n \"properties\": {\n  \"spec\": {\n   \"description\": \"Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html\",\n   \"properties\": {\n    \"exportTo\": {\n     \"description\": \"A list of namespaces to which this destination rule is exported.\",\n     \"items\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"array\"\n    },\n    \"host\": {\n     \"description\": \"The name of a service from the service registry.\",\n     \"type\": \"string\"\n    },\n    \"subsets\": {\n     \"description\": \"One or more named sets that represent individual versions of a service.\",\n     \"items\": {\n      \"properties\": {\n       \"labels\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Labels apply a filter over the endpoints of a service in the service registry.\",\n        \"type\": \"object\"\n       },\n       \"name\": {\n        \"description\": \"Name of the subset.\",\n        \"type\": \"string\"\n       },\n       \"trafficPolicy\": {\n        \"description\": \"Traffic policies that apply to this subset.\",\n        \"properties\": {\n         \"connectionPool\": {\n          \"properties\": {\n           \"http\": {\n            \"description\": \"HTTP connection pool settings.\",\n            \"properties\": {\n             \"h2UpgradePolicy\": {\n              \"description\": \"Specify if http1.1 connection should be upgraded to http2 for the associated destination.\",\n              \"enum\": [\n               \"DEFAULT\",\n               \"DO_NOT_UPGRADE\",\n               \"UPGRADE\"\n              ],\n              \"type\": \"string\"\n             },\n             \"http1MaxPendingRequests\": {\n              \"description\": \"Maximum number of requests that will be queued while waiting for a ready connection pool connection.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"http2MaxRequests\": {\n              \"description\": \"Maximum number of active requests to a destination.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"idleTimeout\": {\n              \"description\": \"The idle timeout for upstream connection pool connections.\",\n              \"type\": \"string\"\n             },\n             \"maxConcurrentStreams\": {\n              \"description\": \"The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"maxRequestsPerConnection\": {\n              \"description\": \"Maximum number of requests per connection to a backend.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"maxRetries\": {\n              \"description\": \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"useClientProtocol\": {\n              \"description\": \"If set to true, client protocol will be preserved while initiating connection to backend.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"tcp\": {\n            \"description\": \"Settings common to both HTTP and TCP upstream connections.\",\n            \"properties\": {\n             \"connectTimeout\": {\n              \"description\": \"TCP connection timeout.\",\n              \"type\": \"string\"\n             },\n             \"idleTimeout\": {\n              \"description\": \"The idle timeout for TCP connections.\",\n              \"type\": \"string\"\n             },\n             \"maxConnectionDuration\": {\n              \"description\": \"The maximum duration of a connection.\",\n              \"type\": \"string\"\n             },\n             \"maxConnections\": {\n              \"description\": \"Maximum number of HTTP1 /TCP connections to a destination host.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"tcpKeepalive\": {\n              \"description\": \"If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\",\n              \"properties\": {\n               \"interval\": {\n                \"description\": \"The time duration between keep-alive probes.\",\n                \"type\": \"string\"\n               },\n               \"probes\": {\n                \"description\": \"Maximum number of keepalive probes to send without response before deciding the connection is dead.\",\n                \"type\": \"integer\"\n               },\n               \"time\": {\n                \"description\": \"The time duration a connection needs to be idle before keep-alive probes start being sent.\",\n                \"type\": \"string\"\n               }\n              },\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"loadBalancer\": {\n          \"description\": \"Settings controlling the load balancer algorithms.\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"simple\"\n               ]\n              },\n              {\n               \"required\": [\n                \"consistentHash\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"simple\"\n            ]\n           },\n           {\n            \"required\": [\n             \"consistentHash\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"consistentHash\": {\n            \"allOf\": [\n             {\n              \"oneOf\": [\n               {\n                \"not\": {\n                 \"anyOf\": [\n                  {\n                   \"required\": [\n                    \"httpHeaderName\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpCookie\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"useSourceIp\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpQueryParameterName\"\n                   ]\n                  }\n                 ]\n                }\n               },\n               {\n                \"required\": [\n                 \"httpHeaderName\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpCookie\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"useSourceIp\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpQueryParameterName\"\n                ]\n               }\n              ]\n             },\n             {\n              \"oneOf\": [\n               {\n                \"not\": {\n                 \"anyOf\": [\n                  {\n                   \"required\": [\n                    \"ringHash\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"maglev\"\n                   ]\n                  }\n                 ]\n                }\n               },\n               {\n                \"required\": [\n                 \"ringHash\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"maglev\"\n                ]\n               }\n              ]\n             }\n            ],\n            \"properties\": {\n             \"httpCookie\": {\n              \"description\": \"Hash based on HTTP cookie.\",\n              \"properties\": {\n               \"name\": {\n                \"description\": \"Name of the cookie.\",\n                \"type\": \"string\"\n               },\n               \"path\": {\n                \"description\": \"Path to set for the cookie.\",\n                \"type\": \"string\"\n               },\n               \"ttl\": {\n                \"description\": \"Lifetime of the cookie.\",\n                \"type\": \"string\"\n               }\n              },\n              \"required\": [\n               \"name\"\n              ],\n              \"type\": \"object\"\n             },\n             \"httpHeaderName\": {\n              \"description\": \"Hash based on a specific HTTP header.\",\n              \"type\": \"string\"\n             },\n             \"httpQueryParameterName\": {\n              \"description\": \"Hash based on a specific HTTP query parameter.\",\n              \"type\": \"string\"\n             },\n             \"maglev\": {\n              \"description\": \"The Maglev load balancer implements consistent hashing to backend hosts.\",\n              \"properties\": {\n               \"tableSize\": {\n                \"description\": \"The table size for Maglev hashing.\",\n                \"type\": \"integer\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"minimumRingSize\": {\n              \"description\": \"Deprecated.\",\n              \"type\": \"integer\"\n             },\n             \"ringHash\": {\n              \"description\": \"The ring/modulo hash load balancer implements consistent hashing to backend hosts.\",\n              \"properties\": {\n               \"minimumRingSize\": {\n                \"description\": \"The minimum number of virtual nodes to use for the hash ring.\",\n                \"type\": \"integer\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"useSourceIp\": {\n              \"description\": \"Hash based on the source IP address.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"localityLbSetting\": {\n            \"properties\": {\n             \"distribute\": {\n              \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n              \"items\": {\n               \"properties\": {\n                \"from\": {\n                 \"description\": \"Originating locality, '/' separated, e.g.\",\n                 \"type\": \"string\"\n                },\n                \"to\": {\n                 \"additionalProperties\": {\n                  \"type\": \"integer\"\n                 },\n                 \"description\": \"Map of upstream localities to traffic distribution weights.\",\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"enabled\": {\n              \"description\": \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.\",\n              \"nullable\": true,\n              \"type\": \"boolean\"\n             },\n             \"failover\": {\n              \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n              \"items\": {\n               \"properties\": {\n                \"from\": {\n                 \"description\": \"Originating region.\",\n                 \"type\": \"string\"\n                },\n                \"to\": {\n                 \"description\": \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n                 \"type\": \"string\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"failoverPriority\": {\n              \"description\": \"failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"simple\": {\n            \"enum\": [\n             \"UNSPECIFIED\",\n             \"LEAST_CONN\",\n             \"RANDOM\",\n             \"PASSTHROUGH\",\n             \"ROUND_ROBIN\",\n             \"LEAST_REQUEST\"\n            ],\n            \"type\": \"string\"\n           },\n           \"warmupDurationSecs\": {\n            \"description\": \"Represents the warmup duration of Service.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"outlierDetection\": {\n          \"properties\": {\n           \"baseEjectionTime\": {\n            \"description\": \"Minimum ejection duration.\",\n            \"type\": \"string\"\n           },\n           \"consecutive5xxErrors\": {\n            \"description\": \"Number of 5xx errors before a host is ejected from the connection pool.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"consecutiveErrors\": {\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"consecutiveGatewayErrors\": {\n            \"description\": \"Number of gateway errors before a host is ejected from the connection pool.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"consecutiveLocalOriginFailures\": {\n            \"description\": \"The number of consecutive locally originated failures before ejection occurs.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"interval\": {\n            \"description\": \"Time interval between ejection sweep analysis.\",\n            \"type\": \"string\"\n           },\n           \"maxEjectionPercent\": {\n            \"description\": \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.\",\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"minHealthPercent\": {\n            \"description\": \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.\",\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"splitExternalLocalOriginErrors\": {\n            \"description\": \"Determines whether to distinguish local origin failures from external errors.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"portLevelSettings\": {\n          \"description\": \"Traffic policies specific to individual ports.\",\n          \"items\": {\n           \"properties\": {\n            \"connectionPool\": {\n             \"properties\": {\n              \"http\": {\n               \"description\": \"HTTP connection pool settings.\",\n               \"properties\": {\n                \"h2UpgradePolicy\": {\n                 \"description\": \"Specify if http1.1 connection should be upgraded to http2 for the associated destination.\",\n                 \"enum\": [\n                  \"DEFAULT\",\n                  \"DO_NOT_UPGRADE\",\n                  \"UPGRADE\"\n                 ],\n                 \"type\": \"string\"\n                },\n                \"http1MaxPendingRequests\": {\n                 \"description\": \"Maximum number of requests that will be queued while waiting for a ready connection pool connection.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"http2MaxRequests\": {\n                 \"description\": \"Maximum number of active requests to a destination.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"idleTimeout\": {\n                 \"description\": \"The idle timeout for upstream connection pool connections.\",\n                 \"type\": \"string\"\n                },\n                \"maxConcurrentStreams\": {\n                 \"description\": \"The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"maxRequestsPerConnection\": {\n                 \"description\": \"Maximum number of requests per connection to a backend.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"maxRetries\": {\n                 \"description\": \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"useClientProtocol\": {\n                 \"description\": \"If set to true, client protocol will be preserved while initiating connection to backend.\",\n                 \"type\": \"boolean\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"tcp\": {\n               \"description\": \"Settings common to both HTTP and TCP upstream connections.\",\n               \"properties\": {\n                \"connectTimeout\": {\n                 \"description\": \"TCP connection timeout.\",\n                 \"type\": \"string\"\n                },\n                \"idleTimeout\": {\n                 \"description\": \"The idle timeout for TCP connections.\",\n                 \"type\": \"string\"\n                },\n                \"maxConnectionDuration\": {\n                 \"description\": \"The maximum duration of a connection.\",\n                 \"type\": \"string\"\n                },\n                \"maxConnections\": {\n                 \"description\": \"Maximum number of HTTP1 /TCP connections to a destination host.\",\n                 \"format\": \"int32\",\n                 \"type\": \"integer\"\n                },\n                \"tcpKeepalive\": {\n                 \"description\": \"If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\",\n                 \"properties\": {\n                  \"interval\": {\n                   \"description\": \"The time duration between keep-alive probes.\",\n                   \"type\": \"string\"\n                  },\n                  \"probes\": {\n                   \"description\": \"Maximum number of keepalive probes to send without response before deciding the connection is dead.\",\n                   \"type\": \"integer\"\n                  },\n                  \"time\": {\n                   \"description\": \"The time duration a connection needs to be idle before keep-alive probes start being sent.\",\n                   \"type\": \"string\"\n                  }\n                 },\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"loadBalancer\": {\n             \"description\": \"Settings controlling the load balancer algorithms.\",\n             \"oneOf\": [\n              {\n               \"not\": {\n                \"anyOf\": [\n                 {\n                  \"required\": [\n                   \"simple\"\n                  ]\n                 },\n                 {\n                  \"required\": [\n                   \"consistentHash\"\n                  ]\n                 }\n                ]\n               }\n              },\n              {\n               \"required\": [\n                \"simple\"\n               ]\n              },\n              {\n               \"required\": [\n                \"consistentHash\"\n               ]\n              }\n             ],\n             \"properties\": {\n              \"consistentHash\": {\n               \"allOf\": [\n                {\n                 \"oneOf\": [\n                  {\n                   \"not\": {\n                    \"anyOf\": [\n                     {\n                      \"required\": [\n                       \"httpHeaderName\"\n                      ]\n                     },\n                     {\n                      \"required\": [\n                       \"httpCookie\"\n                      ]\n                     },\n                     {\n                      \"required\": [\n                       \"useSourceIp\"\n                      ]\n                     },\n                     {\n                      \"required\": [\n                       \"httpQueryParameterName\"\n                      ]\n                     }\n                    ]\n                   }\n                  },\n                  {\n                   \"required\": [\n                    \"httpHeaderName\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpCookie\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"useSourceIp\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpQueryParameterName\"\n                   ]\n                  }\n                 ]\n                },\n                {\n                 \"oneOf\": [\n                  {\n                   \"not\": {\n                    \"anyOf\": [\n                     {\n                      \"required\": [\n                       \"ringHash\"\n                      ]\n                     },\n                     {\n                      \"required\": [\n                       \"maglev\"\n                      ]\n                     }\n                    ]\n                   }\n                  },\n                  {\n                   \"required\": [\n                    \"ringHash\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"maglev\"\n                   ]\n                  }\n                 ]\n                }\n               ],\n               \"properties\": {\n                \"httpCookie\": {\n                 \"description\": \"Hash based on HTTP cookie.\",\n                 \"properties\": {\n                  \"name\": {\n                   \"description\": \"Name of the cookie.\",\n                   \"type\": \"string\"\n                  },\n                  \"path\": {\n                   \"description\": \"Path to set for the cookie.\",\n                   \"type\": \"string\"\n                  },\n                  \"ttl\": {\n                   \"description\": \"Lifetime of the cookie.\",\n                   \"type\": \"string\"\n                  }\n                 },\n                 \"required\": [\n                  \"name\"\n                 ],\n                 \"type\": \"object\"\n                },\n                \"httpHeaderName\": {\n                 \"description\": \"Hash based on a specific HTTP header.\",\n                 \"type\": \"string\"\n                },\n                \"httpQueryParameterName\": {\n                 \"description\": \"Hash based on a specific HTTP query parameter.\",\n                 \"type\": \"string\"\n                },\n                \"maglev\": {\n                 \"description\": \"The Maglev load balancer implements consistent hashing to backend hosts.\",\n                 \"properties\": {\n                  \"tableSize\": {\n                   \"description\": \"The table size for Maglev hashing.\",\n                   \"type\": \"integer\"\n                  }\n                 },\n                 \"type\": \"object\"\n                },\n                \"minimumRingSize\": {\n                 \"description\": \"Deprecated.\",\n                 \"type\": \"integer\"\n                },\n                \"ringHash\": {\n                 \"description\": \"The ring/modulo hash load balancer implements consistent hashing to backend hosts.\",\n                 \"properties\": {\n                  \"minimumRingSize\": {\n                   \"description\": \"The minimum number of virtual nodes to use for the hash ring.\",\n                   \"type\": \"integer\"\n                  }\n                 },\n                 \"type\": \"object\"\n                },\n                \"useSourceIp\": {\n                 \"description\": \"Hash based on the source IP address.\",\n                 \"type\": \"boolean\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"localityLbSetting\": {\n               \"properties\": {\n                \"distribute\": {\n                 \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n                 \"items\": {\n                  \"properties\": {\n                   \"from\": {\n                    \"description\": \"Originating locality, '/' separated, e.g.\",\n                    \"type\": \"string\"\n                   },\n                   \"to\": {\n                    \"additionalProperties\": {\n                     \"type\": \"integer\"\n                    },\n                    \"description\": \"Map of upstream localities to traffic distribution weights.\",\n                    \"type\": \"object\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"enabled\": {\n                 \"description\": \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.\",\n                 \"nullable\": true,\n                 \"type\": \"boolean\"\n                },\n                \"failover\": {\n                 \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n                 \"items\": {\n                  \"properties\": {\n                   \"from\": {\n                    \"description\": \"Originating region.\",\n                    \"type\": \"string\"\n                   },\n                   \"to\": {\n                    \"description\": \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n                    \"type\": \"string\"\n                   }\n                  },\n                  \"type\": \"object\"\n                 },\n                 \"type\": \"array\"\n                },\n                \"failoverPriority\": {\n                 \"description\": \"failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"simple\": {\n               \"enum\": [\n                \"UNSPECIFIED\",\n                \"LEAST_CONN\",\n                \"RANDOM\",\n                \"PASSTHROUGH\",\n                \"ROUND_ROBIN\",\n                \"LEAST_REQUEST\"\n               ],\n               \"type\": \"string\"\n              },\n              \"warmupDurationSecs\": {\n               \"description\": \"Represents the warmup duration of Service.\",\n               \"type\": \"string\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"outlierDetection\": {\n             \"properties\": {\n              \"baseEjectionTime\": {\n               \"description\": \"Minimum ejection duration.\",\n               \"type\": \"string\"\n              },\n              \"consecutive5xxErrors\": {\n               \"description\": \"Number of 5xx errors before a host is ejected from the connection pool.\",\n               \"nullable\": true,\n               \"type\": \"integer\"\n              },\n              \"consecutiveErrors\": {\n               \"format\": \"int32\",\n               \"type\": \"integer\"\n              },\n              \"consecutiveGatewayErrors\": {\n               \"description\": \"Number of gateway errors before a host is ejected from the connection pool.\",\n               \"nullable\": true,\n               \"type\": \"integer\"\n              },\n              \"consecutiveLocalOriginFailures\": {\n               \"description\": \"The number of consecutive locally originated failures before ejection occurs.\",\n               \"nullable\": true,\n               \"type\": \"integer\"\n              },\n              \"interval\": {\n               \"description\": \"Time interval between ejection sweep analysis.\",\n               \"type\": \"string\"\n              },\n              \"maxEjectionPercent\": {\n               \"description\": \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.\",\n               \"format\": \"int32\",\n               \"type\": \"integer\"\n              },\n              \"minHealthPercent\": {\n               \"description\": \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.\",\n               \"format\": \"int32\",\n               \"type\": \"integer\"\n              },\n              \"splitExternalLocalOriginErrors\": {\n               \"description\": \"Determines whether to distinguish local origin failures from external errors.\",\n               \"type\": \"boolean\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"port\": {\n             \"description\": \"Specifies the number of a port on the destination service on which this policy is being applied.\",\n             \"properties\": {\n              \"number\": {\n               \"type\": \"integer\"\n              }\n             },\n             \"type\": \"object\"\n            },\n            \"tls\": {\n             \"description\": \"TLS related settings for connections to the upstream service.\",\n             \"properties\": {\n              \"caCertificates\": {\n               \"description\": \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.\",\n               \"type\": \"string\"\n              },\n              \"clientCertificate\": {\n               \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n               \"type\": \"string\"\n              },\n              \"credentialName\": {\n               \"description\": \"The name of the secret that holds the TLS certs for the client including the CA certificates.\",\n               \"type\": \"string\"\n              },\n              \"insecureSkipVerify\": {\n               \"description\": \"`insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.\",\n               \"nullable\": true,\n               \"type\": \"boolean\"\n              },\n              \"mode\": {\n               \"description\": \"Indicates whether connections to this port should be secured using TLS.\",\n               \"enum\": [\n                \"DISABLE\",\n                \"SIMPLE\",\n                \"MUTUAL\",\n                \"ISTIO_MUTUAL\"\n               ],\n               \"type\": \"string\"\n              },\n              \"privateKey\": {\n               \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n               \"type\": \"string\"\n              },\n              \"sni\": {\n               \"description\": \"SNI string to present to the server during TLS handshake.\",\n               \"type\": \"string\"\n              },\n              \"subjectAltNames\": {\n               \"description\": \"A list of alternate names to verify the subject identity in the certificate.\",\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"type\": \"object\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"type\": \"array\"\n         },\n         \"proxyProtocol\": {\n          \"description\": \"The upstream PROXY protocol settings.\",\n          \"properties\": {\n           \"version\": {\n            \"description\": \"The PROXY protocol version to use.\",\n            \"enum\": [\n             \"V1\",\n             \"V2\"\n            ],\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"tls\": {\n          \"description\": \"TLS related settings for connections to the upstream service.\",\n          \"properties\": {\n           \"caCertificates\": {\n            \"description\": \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.\",\n            \"type\": \"string\"\n           },\n           \"clientCertificate\": {\n            \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n            \"type\": \"string\"\n           },\n           \"credentialName\": {\n            \"description\": \"The name of the secret that holds the TLS certs for the client including the CA certificates.\",\n            \"type\": \"string\"\n           },\n           \"insecureSkipVerify\": {\n            \"description\": \"`insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.\",\n            \"nullable\": true,\n            \"type\": \"boolean\"\n           },\n           \"mode\": {\n            \"description\": \"Indicates whether connections to this port should be secured using TLS.\",\n            \"enum\": [\n             \"DISABLE\",\n             \"SIMPLE\",\n             \"MUTUAL\",\n             \"ISTIO_MUTUAL\"\n            ],\n            \"type\": \"string\"\n           },\n           \"privateKey\": {\n            \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n            \"type\": \"string\"\n           },\n           \"sni\": {\n            \"description\": \"SNI string to present to the server during TLS handshake.\",\n            \"type\": \"string\"\n           },\n           \"subjectAltNames\": {\n            \"description\": \"A list of alternate names to verify the subject identity in the certificate.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"tunnel\": {\n          \"description\": \"Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.\",\n          \"properties\": {\n           \"protocol\": {\n            \"description\": \"Specifies which protocol to use for tunneling the downstream connection.\",\n            \"type\": \"string\"\n           },\n           \"targetHost\": {\n            \"description\": \"Specifies a host to which the downstream connection is tunneled.\",\n            \"type\": \"string\"\n           },\n           \"targetPort\": {\n            \"description\": \"Specifies a port to which the downstream connection is tunneled.\",\n            \"type\": \"integer\"\n           }\n          },\n          \"required\": [\n           \"targetHost\",\n           \"targetPort\"\n          ],\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"required\": [\n       \"name\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"trafficPolicy\": {\n     \"description\": \"Traffic policies to apply (load balancing policy, connection pool sizes, outlier detection).\",\n     \"properties\": {\n      \"connectionPool\": {\n       \"properties\": {\n        \"http\": {\n         \"description\": \"HTTP connection pool settings.\",\n         \"properties\": {\n          \"h2UpgradePolicy\": {\n           \"description\": \"Specify if http1.1 connection should be upgraded to http2 for the associated destination.\",\n           \"enum\": [\n            \"DEFAULT\",\n            \"DO_NOT_UPGRADE\",\n            \"UPGRADE\"\n           ],\n           \"type\": \"string\"\n          },\n          \"http1MaxPendingRequests\": {\n           \"description\": \"Maximum number of requests that will be queued while waiting for a ready connection pool connection.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"http2MaxRequests\": {\n           \"description\": \"Maximum number of active requests to a destination.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"idleTimeout\": {\n           \"description\": \"The idle timeout for upstream connection pool connections.\",\n           \"type\": \"string\"\n          },\n          \"maxConcurrentStreams\": {\n           \"description\": \"The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"maxRequestsPerConnection\": {\n           \"description\": \"Maximum number of requests per connection to a backend.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"maxRetries\": {\n           \"description\": \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"useClientProtocol\": {\n           \"description\": \"If set to true, client protocol will be preserved while initiating connection to backend.\",\n           \"type\": \"boolean\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"tcp\": {\n         \"description\": \"Settings common to both HTTP and TCP upstream connections.\",\n         \"properties\": {\n          \"connectTimeout\": {\n           \"description\": \"TCP connection timeout.\",\n           \"type\": \"string\"\n          },\n          \"idleTimeout\": {\n           \"description\": \"The idle timeout for TCP connections.\",\n           \"type\": \"string\"\n          },\n          \"maxConnectionDuration\": {\n           \"description\": \"The maximum duration of a connection.\",\n           \"type\": \"string\"\n          },\n          \"maxConnections\": {\n           \"description\": \"Maximum number of HTTP1 /TCP connections to a destination host.\",\n           \"format\": \"int32\",\n           \"type\": \"integer\"\n          },\n          \"tcpKeepalive\": {\n           \"description\": \"If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\",\n           \"properties\": {\n            \"interval\": {\n             \"description\": \"The time duration between keep-alive probes.\",\n             \"type\": \"string\"\n            },\n            \"probes\": {\n             \"description\": \"Maximum number of keepalive probes to send without response before deciding the connection is dead.\",\n             \"type\": \"integer\"\n            },\n            \"time\": {\n             \"description\": \"The time duration a connection needs to be idle before keep-alive probes start being sent.\",\n             \"type\": \"string\"\n            }\n           },\n           \"type\": \"object\"\n          }\n         },\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"loadBalancer\": {\n       \"description\": \"Settings controlling the load balancer algorithms.\",\n       \"oneOf\": [\n        {\n         \"not\": {\n          \"anyOf\": [\n           {\n            \"required\": [\n             \"simple\"\n            ]\n           },\n           {\n            \"required\": [\n             \"consistentHash\"\n            ]\n           }\n          ]\n         }\n        },\n        {\n         \"required\": [\n          \"simple\"\n         ]\n        },\n        {\n         \"required\": [\n          \"consistentHash\"\n         ]\n        }\n       ],\n       \"properties\": {\n        \"consistentHash\": {\n         \"allOf\": [\n          {\n           \"oneOf\": [\n            {\n             \"not\": {\n              \"anyOf\": [\n               {\n                \"required\": [\n                 \"httpHeaderName\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpCookie\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"useSourceIp\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpQueryParameterName\"\n                ]\n               }\n              ]\n             }\n            },\n            {\n             \"required\": [\n              \"httpHeaderName\"\n             ]\n            },\n            {\n             \"required\": [\n              \"httpCookie\"\n             ]\n            },\n            {\n             \"required\": [\n              \"useSourceIp\"\n             ]\n            },\n            {\n             \"required\": [\n              \"httpQueryParameterName\"\n             ]\n            }\n           ]\n          },\n          {\n           \"oneOf\": [\n            {\n             \"not\": {\n              \"anyOf\": [\n               {\n                \"required\": [\n                 \"ringHash\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"maglev\"\n                ]\n               }\n              ]\n             }\n            },\n            {\n             \"required\": [\n              \"ringHash\"\n             ]\n            },\n            {\n             \"required\": [\n              \"maglev\"\n             ]\n            }\n           ]\n          }\n         ],\n         \"properties\": {\n          \"httpCookie\": {\n           \"description\": \"Hash based on HTTP cookie.\",\n           \"properties\": {\n            \"name\": {\n             \"description\": \"Name of the cookie.\",\n             \"type\": \"string\"\n            },\n            \"path\": {\n             \"description\": \"Path to set for the cookie.\",\n             \"type\": \"string\"\n            },\n            \"ttl\": {\n             \"description\": \"Lifetime of the cookie.\",\n             \"type\": \"string\"\n            }\n           },\n           \"required\": [\n            \"name\"\n           ],\n           \"type\": \"object\"\n          },\n          \"httpHeaderName\": {\n           \"description\": \"Hash based on a specific HTTP header.\",\n           \"type\": \"string\"\n          },\n          \"httpQueryParameterName\": {\n           \"description\": \"Hash based on a specific HTTP query parameter.\",\n           \"type\": \"string\"\n          },\n          \"maglev\": {\n           \"description\": \"The Maglev load balancer implements consistent hashing to backend hosts.\",\n           \"properties\": {\n            \"tableSize\": {\n             \"description\": \"The table size for Maglev hashing.\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"minimumRingSize\": {\n           \"description\": \"Deprecated.\",\n           \"type\": \"integer\"\n          },\n          \"ringHash\": {\n           \"description\": \"The ring/modulo hash load balancer implements consistent hashing to backend hosts.\",\n           \"properties\": {\n            \"minimumRingSize\": {\n             \"description\": \"The minimum number of virtual nodes to use for the hash ring.\",\n             \"type\": \"integer\"\n            }\n           },\n           \"type\": \"object\"\n          },\n          \"useSourceIp\": {\n           \"description\": \"Hash based on the source IP address.\",\n           \"type\": \"boolean\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"localityLbSetting\": {\n         \"properties\": {\n          \"distribute\": {\n           \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n           \"items\": {\n            \"properties\": {\n             \"from\": {\n              \"description\": \"Originating locality, '/' separated, e.g.\",\n              \"type\": \"string\"\n             },\n             \"to\": {\n              \"additionalProperties\": {\n               \"type\": \"integer\"\n              },\n              \"description\": \"Map of upstream localities to traffic distribution weights.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          },\n          \"enabled\": {\n           \"description\": \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.\",\n           \"nullable\": true,\n           \"type\": \"boolean\"\n          },\n          \"failover\": {\n           \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n           \"items\": {\n            \"properties\": {\n             \"from\": {\n              \"description\": \"Originating region.\",\n              \"type\": \"string\"\n             },\n             \"to\": {\n              \"description\": \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n              \"type\": \"string\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"type\": \"array\"\n          },\n          \"failoverPriority\": {\n           \"description\": \"failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.\",\n           \"items\": {\n            \"type\": \"string\"\n           },\n           \"type\": \"array\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"simple\": {\n         \"enum\": [\n          \"UNSPECIFIED\",\n          \"LEAST_CONN\",\n          \"RANDOM\",\n          \"PASSTHROUGH\",\n          \"ROUND_ROBIN\",\n          \"LEAST_REQUEST\"\n         ],\n         \"type\": \"string\"\n        },\n        \"warmupDurationSecs\": {\n         \"description\": \"Represents the warmup duration of Service.\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"outlierDetection\": {\n       \"properties\": {\n        \"baseEjectionTime\": {\n         \"description\": \"Minimum ejection duration.\",\n         \"type\": \"string\"\n        },\n        \"consecutive5xxErrors\": {\n         \"description\": \"Number of 5xx errors before a host is ejected from the connection pool.\",\n         \"nullable\": true,\n         \"type\": \"integer\"\n        },\n        \"consecutiveErrors\": {\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"consecutiveGatewayErrors\": {\n         \"description\": \"Number of gateway errors before a host is ejected from the connection pool.\",\n         \"nullable\": true,\n         \"type\": \"integer\"\n        },\n        \"consecutiveLocalOriginFailures\": {\n         \"description\": \"The number of consecutive locally originated failures before ejection occurs.\",\n         \"nullable\": true,\n         \"type\": \"integer\"\n        },\n        \"interval\": {\n         \"description\": \"Time interval between ejection sweep analysis.\",\n         \"type\": \"string\"\n        },\n        \"maxEjectionPercent\": {\n         \"description\": \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"minHealthPercent\": {\n         \"description\": \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.\",\n         \"format\": \"int32\",\n         \"type\": \"integer\"\n        },\n        \"splitExternalLocalOriginErrors\": {\n         \"description\": \"Determines whether to distinguish local origin failures from external errors.\",\n         \"type\": \"boolean\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"portLevelSettings\": {\n       \"description\": \"Traffic policies specific to individual ports.\",\n       \"items\": {\n        \"properties\": {\n         \"connectionPool\": {\n          \"properties\": {\n           \"http\": {\n            \"description\": \"HTTP connection pool settings.\",\n            \"properties\": {\n             \"h2UpgradePolicy\": {\n              \"description\": \"Specify if http1.1 connection should be upgraded to http2 for the associated destination.\",\n              \"enum\": [\n               \"DEFAULT\",\n               \"DO_NOT_UPGRADE\",\n               \"UPGRADE\"\n              ],\n              \"type\": \"string\"\n             },\n             \"http1MaxPendingRequests\": {\n              \"description\": \"Maximum number of requests that will be queued while waiting for a ready connection pool connection.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"http2MaxRequests\": {\n              \"description\": \"Maximum number of active requests to a destination.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"idleTimeout\": {\n              \"description\": \"The idle timeout for upstream connection pool connections.\",\n              \"type\": \"string\"\n             },\n             \"maxConcurrentStreams\": {\n              \"description\": \"The maximum number of concurrent streams allowed for a peer on one HTTP/2 connection.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"maxRequestsPerConnection\": {\n              \"description\": \"Maximum number of requests per connection to a backend.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"maxRetries\": {\n              \"description\": \"Maximum number of retries that can be outstanding to all hosts in a cluster at a given time.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"useClientProtocol\": {\n              \"description\": \"If set to true, client protocol will be preserved while initiating connection to backend.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"tcp\": {\n            \"description\": \"Settings common to both HTTP and TCP upstream connections.\",\n            \"properties\": {\n             \"connectTimeout\": {\n              \"description\": \"TCP connection timeout.\",\n              \"type\": \"string\"\n             },\n             \"idleTimeout\": {\n              \"description\": \"The idle timeout for TCP connections.\",\n              \"type\": \"string\"\n             },\n             \"maxConnectionDuration\": {\n              \"description\": \"The maximum duration of a connection.\",\n              \"type\": \"string\"\n             },\n             \"maxConnections\": {\n              \"description\": \"Maximum number of HTTP1 /TCP connections to a destination host.\",\n              \"format\": \"int32\",\n              \"type\": \"integer\"\n             },\n             \"tcpKeepalive\": {\n              \"description\": \"If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.\",\n              \"properties\": {\n               \"interval\": {\n                \"description\": \"The time duration between keep-alive probes.\",\n                \"type\": \"string\"\n               },\n               \"probes\": {\n                \"description\": \"Maximum number of keepalive probes to send without response before deciding the connection is dead.\",\n                \"type\": \"integer\"\n               },\n               \"time\": {\n                \"description\": \"The time duration a connection needs to be idle before keep-alive probes start being sent.\",\n                \"type\": \"string\"\n               }\n              },\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"loadBalancer\": {\n          \"description\": \"Settings controlling the load balancer algorithms.\",\n          \"oneOf\": [\n           {\n            \"not\": {\n             \"anyOf\": [\n              {\n               \"required\": [\n                \"simple\"\n               ]\n              },\n              {\n               \"required\": [\n                \"consistentHash\"\n               ]\n              }\n             ]\n            }\n           },\n           {\n            \"required\": [\n             \"simple\"\n            ]\n           },\n           {\n            \"required\": [\n             \"consistentHash\"\n            ]\n           }\n          ],\n          \"properties\": {\n           \"consistentHash\": {\n            \"allOf\": [\n             {\n              \"oneOf\": [\n               {\n                \"not\": {\n                 \"anyOf\": [\n                  {\n                   \"required\": [\n                    \"httpHeaderName\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpCookie\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"useSourceIp\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"httpQueryParameterName\"\n                   ]\n                  }\n                 ]\n                }\n               },\n               {\n                \"required\": [\n                 \"httpHeaderName\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpCookie\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"useSourceIp\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"httpQueryParameterName\"\n                ]\n               }\n              ]\n             },\n             {\n              \"oneOf\": [\n               {\n                \"not\": {\n                 \"anyOf\": [\n                  {\n                   \"required\": [\n                    \"ringHash\"\n                   ]\n                  },\n                  {\n                   \"required\": [\n                    \"maglev\"\n                   ]\n                  }\n                 ]\n                }\n               },\n               {\n                \"required\": [\n                 \"ringHash\"\n                ]\n               },\n               {\n                \"required\": [\n                 \"maglev\"\n                ]\n               }\n              ]\n             }\n            ],\n            \"properties\": {\n             \"httpCookie\": {\n              \"description\": \"Hash based on HTTP cookie.\",\n              \"properties\": {\n               \"name\": {\n                \"description\": \"Name of the cookie.\",\n                \"type\": \"string\"\n               },\n               \"path\": {\n                \"description\": \"Path to set for the cookie.\",\n                \"type\": \"string\"\n               },\n               \"ttl\": {\n                \"description\": \"Lifetime of the cookie.\",\n                \"type\": \"string\"\n               }\n              },\n              \"required\": [\n               \"name\"\n              ],\n              \"type\": \"object\"\n             },\n             \"httpHeaderName\": {\n              \"description\": \"Hash based on a specific HTTP header.\",\n              \"type\": \"string\"\n             },\n             \"httpQueryParameterName\": {\n              \"description\": \"Hash based on a specific HTTP query parameter.\",\n              \"type\": \"string\"\n             },\n             \"maglev\": {\n              \"description\": \"The Maglev load balancer implements consistent hashing to backend hosts.\",\n              \"properties\": {\n               \"tableSize\": {\n                \"description\": \"The table size for Maglev hashing.\",\n                \"type\": \"integer\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"minimumRingSize\": {\n              \"description\": \"Deprecated.\",\n              \"type\": \"integer\"\n             },\n             \"ringHash\": {\n              \"description\": \"The ring/modulo hash load balancer implements consistent hashing to backend hosts.\",\n              \"properties\": {\n               \"minimumRingSize\": {\n                \"description\": \"The minimum number of virtual nodes to use for the hash ring.\",\n                \"type\": \"integer\"\n               }\n              },\n              \"type\": \"object\"\n             },\n             \"useSourceIp\": {\n              \"description\": \"Hash based on the source IP address.\",\n              \"type\": \"boolean\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"localityLbSetting\": {\n            \"properties\": {\n             \"distribute\": {\n              \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n              \"items\": {\n               \"properties\": {\n                \"from\": {\n                 \"description\": \"Originating locality, '/' separated, e.g.\",\n                 \"type\": \"string\"\n                },\n                \"to\": {\n                 \"additionalProperties\": {\n                  \"type\": \"integer\"\n                 },\n                 \"description\": \"Map of upstream localities to traffic distribution weights.\",\n                 \"type\": \"object\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"enabled\": {\n              \"description\": \"enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.\",\n              \"nullable\": true,\n              \"type\": \"boolean\"\n             },\n             \"failover\": {\n              \"description\": \"Optional: only one of distribute, failover or failoverPriority can be set.\",\n              \"items\": {\n               \"properties\": {\n                \"from\": {\n                 \"description\": \"Originating region.\",\n                 \"type\": \"string\"\n                },\n                \"to\": {\n                 \"description\": \"Destination region the traffic will fail over to when endpoints in the 'from' region becomes unhealthy.\",\n                 \"type\": \"string\"\n                }\n               },\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"failoverPriority\": {\n              \"description\": \"failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.\",\n              \"items\": {\n               \"type\": \"string\"\n              },\n              \"type\": \"array\"\n             }\n            },\n            \"type\": \"object\"\n           },\n           \"simple\": {\n            \"enum\": [\n             \"UNSPECIFIED\",\n             \"LEAST_CONN\",\n             \"RANDOM\",\n             \"PASSTHROUGH\",\n             \"ROUND_ROBIN\",\n             \"LEAST_REQUEST\"\n            ],\n            \"type\": \"string\"\n           },\n           \"warmupDurationSecs\": {\n            \"description\": \"Represents the warmup duration of Service.\",\n            \"type\": \"string\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"outlierDetection\": {\n          \"properties\": {\n           \"baseEjectionTime\": {\n            \"description\": \"Minimum ejection duration.\",\n            \"type\": \"string\"\n           },\n           \"consecutive5xxErrors\": {\n            \"description\": \"Number of 5xx errors before a host is ejected from the connection pool.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"consecutiveErrors\": {\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"consecutiveGatewayErrors\": {\n            \"description\": \"Number of gateway errors before a host is ejected from the connection pool.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"consecutiveLocalOriginFailures\": {\n            \"description\": \"The number of consecutive locally originated failures before ejection occurs.\",\n            \"nullable\": true,\n            \"type\": \"integer\"\n           },\n           \"interval\": {\n            \"description\": \"Time interval between ejection sweep analysis.\",\n            \"type\": \"string\"\n           },\n           \"maxEjectionPercent\": {\n            \"description\": \"Maximum % of hosts in the load balancing pool for the upstream service that can be ejected.\",\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"minHealthPercent\": {\n            \"description\": \"Outlier detection will be enabled as long as the associated load balancing pool has at least min_health_percent hosts in healthy mode.\",\n            \"format\": \"int32\",\n            \"type\": \"integer\"\n           },\n           \"splitExternalLocalOriginErrors\": {\n            \"description\": \"Determines whether to distinguish local origin failures from external errors.\",\n            \"type\": \"boolean\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"port\": {\n          \"description\": \"Specifies the number of a port on the destination service on which this policy is being applied.\",\n          \"properties\": {\n           \"number\": {\n            \"type\": \"integer\"\n           }\n          },\n          \"type\": \"object\"\n         },\n         \"tls\": {\n          \"description\": \"TLS related settings for connections to the upstream service.\",\n          \"properties\": {\n           \"caCertificates\": {\n            \"description\": \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.\",\n            \"type\": \"string\"\n           },\n           \"clientCertificate\": {\n            \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n            \"type\": \"string\"\n           },\n           \"credentialName\": {\n            \"description\": \"The name of the secret that holds the TLS certs for the client including the CA certificates.\",\n            \"type\": \"string\"\n           },\n           \"insecureSkipVerify\": {\n            \"description\": \"`insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.\",\n            \"nullable\": true,\n            \"type\": \"boolean\"\n           },\n           \"mode\": {\n            \"description\": \"Indicates whether connections to this port should be secured using TLS.\",\n            \"enum\": [\n             \"DISABLE\",\n             \"SIMPLE\",\n             \"MUTUAL\",\n             \"ISTIO_MUTUAL\"\n            ],\n            \"type\": \"string\"\n           },\n           \"privateKey\": {\n            \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n            \"type\": \"string\"\n           },\n           \"sni\": {\n            \"description\": \"SNI string to present to the server during TLS handshake.\",\n            \"type\": \"string\"\n           },\n           \"subjectAltNames\": {\n            \"description\": \"A list of alternate names to verify the subject identity in the certificate.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"proxyProtocol\": {\n       \"description\": \"The upstream PROXY protocol settings.\",\n       \"properties\": {\n        \"version\": {\n         \"description\": \"The PROXY protocol version to use.\",\n         \"enum\": [\n          \"V1\",\n          \"V2\"\n         ],\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"tls\": {\n       \"description\": \"TLS related settings for connections to the upstream service.\",\n       \"properties\": {\n        \"caCertificates\": {\n         \"description\": \"OPTIONAL: The path to the file containing certificate authority certificates to use in verifying a presented server certificate.\",\n         \"type\": \"string\"\n        },\n        \"clientCertificate\": {\n         \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n         \"type\": \"string\"\n        },\n        \"credentialName\": {\n         \"description\": \"The name of the secret that holds the TLS certs for the client including the CA certificates.\",\n         \"type\": \"string\"\n        },\n        \"insecureSkipVerify\": {\n         \"description\": \"`insecureSkipVerify` specifies whether the proxy should skip verifying the CA signature and SAN for the server certificate corresponding to the host.\",\n         \"nullable\": true,\n         \"type\": \"boolean\"\n        },\n        \"mode\": {\n         \"description\": \"Indicates whether connections to this port should be secured using TLS.\",\n         \"enum\": [\n          \"DISABLE\",\n          \"SIMPLE\",\n          \"MUTUAL\",\n          \"ISTIO_MUTUAL\"\n         ],\n         \"type\": \"string\"\n        },\n        \"privateKey\": {\n         \"description\": \"REQUIRED if mode is `MUTUAL`.\",\n         \"type\": \"string\"\n        },\n        \"sni\": {\n         \"description\": \"SNI string to present to the server during TLS handshake.\",\n         \"type\": \"string\"\n        },\n        \"subjectAltNames\": {\n         \"description\": \"A list of alternate names to verify the subject identity in the certificate.\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"tunnel\": {\n       \"description\": \"Configuration of tunneling TCP over other transport or application layers for the host configured in the DestinationRule.\",\n       \"properties\": {\n        \"protocol\": {\n         \"description\": \"Specifies which protocol to use for tunneling the downstream connection.\",\n         \"type\": \"string\"\n        },\n        \"targetHost\": {\n         \"description\": \"Specifies a host to which the downstream connection is tunneled.\",\n         \"type\": \"string\"\n        },\n        \"targetPort\": {\n         \"description\": \"Specifies a port to which the downstream connection is tunneled.\",\n         \"type\": \"integer\"\n        }\n       },\n       \"required\": [\n        \"targetHost\",\n        \"targetPort\"\n       ],\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"workloadSelector\": {\n     \"description\": \"Criteria used to select the specific set of pods/VMs on which this `DestinationRule` configuration should be applied.\",\n     \"properties\": {\n      \"matchLabels\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"One or more labels that indicate a specific set of pods/VMs on which a policy should be applied.\",\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    }\n   },\n   \"required\": [\n    \"host\"\n   ],\n   \"type\": \"object\"\n  }\n },\n \"title\": \"Destination Rule\",\n \"type\": \"object\"\n}"
  }
 }