{
  "apiVersion": "core.meshery.io/v1alpha1",
  "kind": "Hierarchical",
  "metadata": {
    "description": "A hierarchical inventory relationship in which the configuration of (parent) component is patched with the configuration of other (child) component. Eg: The configuration of the EnvoyFilter (parent) component is patched with the configuration as received from WASMFilter (child) component."
  },
  "model": {
    "name": "kubernetes",
    "version": "v1.25.2",
    "displayName": "Kubernetes",
    "category": {
      "name": "Orchestration \u0026 Management",
      "metadata": null
    },
    "metadata": {}
  },
  "subType": "Inventory",
  "evaluationQuery": "heirarchical_inventory_relationship",
  "selectors": [
    {
      "allow": {
        "from": [
          {
            "kind": "WASMFilter",
            "model": "istio-base",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "settings",
                  "config"
                ],
                [
                  "settings",
                  "wasm-filter"
                ]
              ],
              "description": "WASM filter configuration to be applied to Envoy Filter."
            }
          }
        ],
        "to": [
          {
            "kind": "EnvoyFilter",
            "model": "istio-base",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "configPatches",
                  "_",
                  "patch",
                  "value"
                ]
              ],
              "description": "Receive the WASM filter configuration."
            }
          },
          {
            "kind": "WasmPlugin",
            "model": "istio-base",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "pluginConfig"
                ],
                [
                  "settings",
                  "spec",
                  "url"
                ]
              ],
              "description": "Receive the WASM filter configuration."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "ConfigMap",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ]
              ],
              "description": "In Kubernetes, ConfigMaps are a versatile resource that can be referenced by various other resources to provide configuration data to applications or other Kubnernetes resources.\n\nBy referencing ConfigMaps in these various contexts, you can centralize and manage configuration data more efficiently, allowing for easier updates, versioning, and maintenance of configurations in a Kubernetes environment."
            }
          }
        ],
        "to": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "Deployments can reference ConfigMaps to inject configuration data into the Pods they manage. This is useful for maintaining consistent configuration across replica sets.\n\nThe keys from the ConfigMap will be exposed as environment variables to the containers within the pods managed by the Deployment."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "StatefulSets can use ConfigMaps to provide configuration data to their pods in a similar way to Deployments.\n\nConfigMaps can be referenced in the Pod template specification of a StatefulSet to provide configuration data to each pod in a consistent manner."
            }
          },
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "DaemonSets, which ensure that a copy of a pod runs on each node, can utilize ConfigMaps to supply configuration data to their pods.\n\nThe keys from the ConfigMap will be exposed as environment variables to the containers within the pods managed by the DaemonSet."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "When deploying applications using ReplicaSets, you may need to configure each replica with specific settings, such as environment variables or configuration files. ConfigMaps can be referenced in the Pod template specification of a ReplicaSet to provide configuration data to each replica pod.DaemonSets, which ensure that a copy of a pod runs on each node, can utilize ConfigMaps to supply configuration data to their pods.\n\nThe keys from the ConfigMap will be exposed as environment variables to the containers within the pods managed by the ReplicaSet."
            }
          },
          {
            "kind": "Pod",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "ConfigMaps can be referenced in the Pod specification to inject configuration data into the Pod's environment.\n\nThe keys from the ConfigMap will be exposed as environment variables to the container within the Pod."
            }
          },
          {
            "kind": "Job",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "ConfigMaps can be referenced in the Pod template specification within the Job definition to inject configuration data into the pods.\n\nThe keys from the ConfigMap will be exposed as environment variables to the container within the pod created by the Job."
            }
          },
          {
            "kind": "CronJob",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "jobTemplate",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "configMapRef",
                  "name"
                ]
              ],
              "description": "ConfigMaps can be referenced in the Pod template specification within the CronJob definition to inject configuration data into the pods.\n\nThe keys from the ConfigMap will be exposed as environment variables to the container within the pod created by the CronJob."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "Pod",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A Pod establishes an inventory relationship with Events. Pod specifications are patched with Event specifications to enable monitoring of Pod-related events, providing insights into their lifecycle and behavior within the cluster."
            }
          },
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A Deployment establishes an inventory relationship with Events. Deployment specifications are patched with Event specifications so that the Deployment can be monitored for events."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A StatefulSet forms an inventory relationship with Events. StatefulSet configurations are integrated with Event specifications, facilitating the monitoring of StatefulSet events such as scaling, updates, and state transitions for effective management of stateful applications."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A ReplicaSet establishes an inventory relationship with Events. ReplicaSet configurations are synchronized with Event specifications, allowing the monitoring of ReplicaSet events such as pod creation, deletion, and scaling activities to maintain desired pod replicas."
            }
          },
          {
            "kind": "Service",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A Service maintains an inventory relationship with Events. Service definitions are aligned with Event specifications, enabling the monitoring of Service-related events such as service creation, endpoint updates, and load balancing activities to ensure seamless communication within the cluster."
            }
          },
          {
            "kind": "ConfigMap",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A ConfigMap forms an inventory relationship with Events. ConfigMap specifications are patched with Event specifications, allowing the monitoring of ConfigMap events such as creation, updates, and usage, enabling dynamic configuration management within the cluster."
            }
          },
          {
            "kind": "Secret",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ],
                [
                  "namespace"
                ],
                [
                  "kind"
                ],
                [
                  "apiVersion"
                ]
              ],
              "description": "A Secret establishes an inventory relationship with Events. Secret configurations are synchronized with Event specifications, facilitating the monitoring of Secret events such as creation, updates, and usage, ensuring secure handling of sensitive information within the cluster."
            }
          }
        ],
        "to": [
          {
            "kind": "Event",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "regarding", "name"],
                ["settings", "regarding", "namespace"],
                ["settings", "regarding", "kind"],
                ["settings", "regarding", "apiVersion"]
              ],
              "description": "In Kubernetes, Events serve as a crucial mechanism for observing and tracking the state changes and activities within the cluster. They offer valuable information about resource creation, updates, errors, and other significant occurrences, aiding administrators and developers in troubleshooting, monitoring, and maintaining the health and performance of their applications."
            }
          }
        ]
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "Secret",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ]
              ],
              "description": "In Kubernetes, Secrets are versatile resources that can be referenced by various other resources to provide configuration data to applications or other Kubernetes resources securely.\n\nBy referencing Secrets in these various contexts, you can centralize and manage configuration data more efficiently, allowing for easier updates, versioning, and maintenance of configurations in a Kubernetes environment."
            }
          }
        ],
        "to": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "Deployments can reference Secrets to inject confidential configuration data into the Pods they manage. This is useful for maintaining consistent configuration across replica sets.\n\nThe keys from the Secret will be exposed as environment variables to the containers within the pods managed by the Deployment."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "StatefulSets can use Secrets to provide confidential configuration data to their pods in a similar way to Deployments.\n\nSecrets can be referenced in the Pod template specification of a StatefulSet to provide configuration data to each pod in a consistent manner."
            }
          },
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "DaemonSets, which ensure that a copy of a pod runs on each node, can utilize Secret to supply confidential configuration data to their pods.\n\nThe keys from the Secret will be exposed as environment variables to the containers within the pods managed by the DaemonSet."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "When deploying applications using ReplicaSets, you may need to configure each replica with specific settings, such as environment variables or configuration files. Secrets can be referenced in the Pod template specification of a ReplicaSet to provide configuration data to each replica pod."
            }
          },
          {
            "kind": "Pod",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "Secret can be referenced in the Pod specification to inject confidential configuration data into the Pod's environment.\n\nThe keys from the Secret will be exposed as environment variables to the container within the Pod."
            }
          },
          {
            "kind": "Job",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "Secret can be referenced in the Pod template specification within the Job definition to inject confidential configuration data into the pods.\n\nThe keys from the Secret will be exposed as environment variables to the container within the pod created by the Job."
            }
          },
          {
            "kind": "CronJob",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "jobTemplate",
                  "spec",
                  "template",
                  "spec",
                  "containers",
                  "_",
                  "envFrom",
                  "0",
                  "secretRef",
                  "name"
                ]
              ],
              "description": "Secret can be referenced in the Pod template specification within the CronJob definition to inject confidential configuration data into the pods.\n\nThe keys from the Secret will be exposed as environment variables to the container within the pod created by the CronJob."
            }
          }
        ]
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "CSIDriver",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "name"
                ]
              ],
              "description": "CSI drivers are responsible for the actual operations of a CSI volume. They are responsible for communicating with the external storage provider and exposing the volume to the kubelet.\n\nCSI drivers are installed on the cluster as a CustomResourceDefinition (CRD) and a DaemonSet. The CRD is used to create a CSIDriver object, which is used to configure the CSI driver. The DaemonSet is used to deploy the CSI driver to each node in the cluster."
            }
          }
        ],
        "to": [
          {
            "kind": "Pod",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "CronJob",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "jobTemplate",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          },
          {
            "kind": "Job",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "template",
                  "spec",
                  "volumes",
                  "_",
                  "csi",
                  "driver"
                ]
              ],
              "description": "CSI drivers are used to provide persistent storage to Pods. The CSI driver is configured in the Pod specification.\n\nThe CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation. The CSI driver is configured in the Pod specification using the csi.volume.kubernetes.io annotation."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["apiVersion"], 
                ["name"], 
                ["type"]
              ],
              "description": "Allow Horizontal Pod Autoscaler to scale based on observed metrics for Deployments."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["apiVersion"], 
                ["name"], 
                ["type"]
              ],
              "description": "Allow Horizontal Pod Autoscaler to scale based on observed metrics for StatefulSet."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["apiVersion"], 
                ["name"], 
                ["type"]
              ],
              "description": "Allow Horizontal Pod Autoscaler to scale based on observed metrics for ReplicaSet."
            }
          }
        ],
        "to": [
          {
            "kind": "HorizontalPodAutoscaler",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "scaleTargetRef", "apiVersion"], 
                ["settings", "spec", "scaleTargetRef", "name"], 
                ["settings", "spec", "scaleTargetRef", "kind"]
              ],
              "description": "Horizontal Pod Autoscaler automatically scales the number of pods in a replication controller, deployment, replica set or stateful set based on observed CPU utilization (or, with custom metrics support, on some other application-provided metrics). Horizontal Pod Autoscaling does not apply to objects that can't be scaled, for example, DaemonSets."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"],
                ["kind"],
                ["apiVersion"]
              ],
              "description": "A Deployment in Kubernetes orchestrates the rollout and management of application replicas. By integrating leases into Deployment strategies, Kubernetes maintains control over the deployment process, orchestrating rolling updates or rollbacks with precision and reliability, thus ensuring seamless transitions and high availability of your application."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"],
                ["kind"],
                ["apiVersion"]
              ],
              "description": "A StatefulSet in Kubernetes is designed for managing stateful applications, providing stable, unique network identifiers, and persistent storage. By integrating leases within StatefulSets, Kubernetes guarantees precise ordering during updates or scaling events, maintaining the integrity of the application's state across pods and ensuring data consistency and reliability throughout the cluster."
            }
          },  
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"],
                ["kind"],
                ["apiVersion"]
              ],
              "description": " A DaemonSet in Kubernetes ensures that a copy of a pod runs on all or certain nodes in the cluster. By incorporating leases within the DaemonSet configuration, Kubernetes ensures that each node hosts exactly one instance of the designated pod, maintaining uniformity and consistency across the cluster while efficiently managing resources and updates."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"],
                ["kind"],
                ["apiVersion"]
              ],
              "description": "ReplicaSets in Kubernetes ensure a specified number of pod replicas are running at any given time. By incorporating leases within ReplicaSets, Kubernetes ensures fault tolerance and scalability by automatically replacing failed or terminated pods, maintaining the desired replica count and preserving the availability and performance of your application."
            }
          }
        ],
        "to": [
          {
            "kind": "Lease",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["ownerReferences", "_", "name"],
                ["ownerReferences", "_", "kind"],
                ["ownerReferences", "_", "apiVersion"]
              ],
              "description": "A Lease is a mechanism used for coordinating activities between multiple instances of a controller, ensuring that only one instance is actively performing certain tasks at any given time."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "ReplicationController",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec"]
              ],
              "description": "In Kubernetes, Replication Controllers  are used to ensure that a specified number of pod replicas are running at any given time."
            }
          }
        ],
        "to": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec"]
              ],
              "description": "A Deployment manages a set of identical Pods, often referred to as a ReplicaSet. Replication Controller provides declarative updates to applications, managing the deployment and scaling of Pods."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec"]
              ],
              "description": "ReplicaSet use Replication Controllers internally to manage the desired number of replicas. Replication Controllers ensure that if a Pod fails or is deleted, a new Pod is created to maintain the desired number of replicas. "
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec"]
              ],
              "description": "A StatefulSet manages the deployment and scaling of a set of Pods, and provides guarantees about the ordering and uniqueness of these Pods. StatefulSets are used for stateful applications, such as databases."
            }
          },
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec"]
              ],
              "description": "A DaemonSet ensures that all (or some) nodes run a copy of a Pod. It's typically used for running system daemons or agents on every node in a Kubernetes cluster."
            }
          }
        ],
        "deny": {
          "from": [],
          "to": []
        }
      }
    },
    {
      "allow": {
        "from":[
          {
            "kind": "PodTemplate",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "template"]
              ],
              "description": "A Pod template is a blueprint defining the configuration for creating Kubernetes pods, encapsulating specifications for containers, volumes, and other settings"
            }
          }
        ],
        "to": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "template"]
              ],
              "description": "Deployments use pod templates to define the desired state of pods, enabling easy scaling, rolling updates, and self-healing of applications within Kubernetes clusters, ensuring consistency and reliability during deployment operations."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "template"]
              ],
              "description": "StatefulSets utilize pod templates to maintain stateful applications' unique identities and ordered scaling behaviors, ensuring persistent storage and network identifiers, crucial for databases and distributed systems' reliable operation."
            }
          },
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "template"]
              ],
              "description": "DaemonSets utilize pod templates to ensure specific pods run on designated nodes within the cluster, facilitating the deployment of essential system services such as logging, monitoring, and networking across the Kubernetes infrastructure, enhancing cluster management and operational efficiency."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "template"]
              ],
              "description": "ReplicaSets leverage pod templates to ensure the desired number of identical pod replicas are running, providing fault tolerance and high availability for applications by automatically managing pod lifecycle based on defined specifications."
            }
          },
          {
            "kind": "Job",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "template"]
              ],
              "description": "Jobs use pod templates to specify the container images, commands, and resources required for executing batch processing tasks reliably within Kubernetes clusters, ensuring consistency and repeatability in job execution."
            }
          }, 
          {
            "kind": "CronJob",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "jobTemplate", "spec", "template"]
              ],
              "description":"CronJobs employ pod templates to define periodic or scheduled tasks' configurations, automating the creation and execution of pods based on defined schedules, enabling efficient handling of repetitive tasks within Kubernetes clusters."
            }
          }
        ],
        "deny": {
          "from": [],
          "to": []
        }
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "ControllerRevision",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                [
                  "settings", "revision"
                ]
              ],
              "description": "ControllerRevisions are used to store the historical state of a ReplicaSet, Deployment, StatefulSet or Pod. They are used to rollback to a previous version of the resource.\n\nControllerRevisions are created when a ReplicaSet, Deployment, or StatefulSet is updated. They store the historical state of the resource, including the Pod template and the revision number."
            }
          }
        ],
        "to": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "revisionHistoryLimit"
                ]
              ],
              "description": "Deployments can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Deployment.\n\nThe revisionHistoryLimit field in the Deployment specification is used to configure the number of ControllerRevisions to store."
            }
          },
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "revisionHistoryLimit"
                ]
              ],
              "description": "StatefulSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the StatefulSet.\n\nThe revisionHistoryLimit field in the StatefulSet specification is used to configure the number of ControllerRevisions to store."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "spec",
                  "revisionHistoryLimit"
                ]
              ],
              "description": "ReplicaSets can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the ReplicaSet.\n\nThe revisionHistoryLimit field in the ReplicaSet specification is used to configure the number of ControllerRevisions to store."
            }
          },
          {
            "kind": "Pod",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                [
                  "settings",
                  "metadata",
                  "ownerReferences",
                  "_",
                  "controller",
                  "revisionHistoryLimit"
                ]
              ],
              "description": "Pods can be configured to store a certain number of ControllerRevisions. This is useful for rolling back to a previous version of the Pod.\n\nThe revisionHistoryLimit field in the Pod specification is used to configure the number of ControllerRevisions to store."
            }
          }
        ]
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "IngressClass",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"]
              ],
              "description": "IngressClass is a resource to specify class for Ingress to be used by the IngressController."
            }
          }
        ],
        "to": [
          {
            "kind": "Ingress",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "ingressClassName"]
              ],
              "description": "Ingress is a collection of rules that allow inbound connections to reach the services. IngressClass configures the class of Ingress resource which is then used by the Ingress Controller."
            }
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from": [
          {
            "kind": "Deployment",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec", "selector", "labels"]
              ], 
              "description": " Deployments manage ReplicaSets and provide features such as rolling updates and rollback functionality. PDBs can be associated with Deployments to maintain availability during updates and ensure a minimum number of pods are available during the transition."
            }
          },
          {
            "kind": "ReplicaSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec", "selector", "labels"]
              ],
              "description": "ReplicaSets ensure a specified number of pod replicas are running at any given time. PDBs can be applied to ReplicaSets to enforce constraints on how many pods can be disrupted at once during scaling operations or node maintenance."
            }
          }, 
          {
            "kind": "StatefulSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec", "selector", "labels"]
              ],
              "description": "StatefulSets are used for stateful applications that require stable, unique network identifiers and persistent storage. PDBs can be used with StatefulSets to control pod disruptions and ensure data integrity during maintenance or scaling."
            }
          }, 
          {
            "kind": "DaemonSet",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec", "selector", "labels"]
              ],
              "description": "DaemonSets ensure that a copy of a pod runs on each node in the cluster. PDBs can be used to prevent too many pods from being disrupted simultaneously during node maintenance or upgrades, ensuring that essential services provided by DaemonSets remain available."
            }
          }
        ],
        "to": [
          {
            "kind": "PodDisruptionBudget",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "selector", "matchLabels"]
              ]
            },
            "description": "In Kubernetes, Pod Distribution Budgets (PDBs) are used to ensure that a certain number or percentage of pods are running on particular nodes or within particular zones."
          }
        ]
      },
      "deny": {
        "from": [],
        "to": []
      }
    },
    {
      "allow": {
        "from":[
          {
            "kind": "Job",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["settings", "spec"]
              ],
              "description": "A Job in Kubernetes is a resource used to run pods to completion. A job can be scheduled to run at a specific time/interval using CronJob."
            }
          }
        ],
        "to": [
          {
            "kind": "CronJob",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "jobTemplate", "spec"]
              ],
              "description": "A CronJob in Kubernetes schedules and manages the execution of Jobs based on a time or schedule specification."
            }
          }
        ],
        "deny": {
          "from": [],
          "to": []
        }
      }
    },
    {
      "allow": {
        "from":[
          {
            "kind": "StorageClass",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatorRef": [
                ["name"]
              ],
              "description": "StorageClass is used in conjunction with PVC that allow Pods to dynamically request a new storage."
            }
          }
        ],
        "to": [
          {
            "kind": "PersistentVolumeClaim",
            "model": "kubernetes",
            "patch": {
              "patchStrategy": "replace",
              "mutatedRef": [
                ["settings", "spec", "storageClassName"]
              ],
              "description": "A PersistentVolumeClaim in Kubernetes requests storage from a StorageClass, defining the requirements for dynamically provisioned volumes."
            }
          }
        ],
        "deny": {
          "from": [],
          "to": []
        }
      }
    }
  ]
}
