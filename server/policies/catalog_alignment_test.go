package policies

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/meshery/meshkit/logger"
	"github.com/open-policy-agent/opa/v1/rego"
	"github.com/open-policy-agent/opa/v1/storage/inmem"
)

// catalogEntry identifies one design in the Meshery Catalog.
type catalogEntry struct {
	id      string // catalog folder UUID
	version string // catalog folder version
	name    string // human-readable name (used as filename)
}

// catalogDesigns returns 73 catalog designs that have relationships.
func catalogDesigns() []catalogEntry {
	return []catalogEntry{
		{"0e64cfa4-c8a4-4155-a8b1-bf21aa9e5107", "0.0.14", "3-Tier-Architecture"},
		{"1abccf09-dcb8-46e4-8cac-f9e33c27516d", "0.0.1", "AWS-RDS-Controller"},
		{"37792455-294f-481b-a7a8-13e79ca835ca", "0.0.1", "AWS-cloudfront-controller"},
		{"075ec9ba-6ad7-4421-a09c-3b8edd5fb4a6", "0.0.1", "Accelerated-mTLS-handshake-for-Envoy-data-planes"},
		{"0b6b1ff8-cb2e-41d4-baff-e0a053f7e4d9", "0.0.1", "Apache-Airflow"},
		{"2b8ca8e9-b964-4102-8ee7-dbb2f1fbed49", "0.0.1", "Autogenerated"},
		{"3ec30961-1aba-4db7-86c5-7556de5d90ca", "0.0.1", "Busybox-single-fresh"},
		{"294946e9-2079-4e6e-8a44-489fbdcf9e3f", "0.0.15", "Complete-Kubernetes-Application-Pattern"},
		{"28715e69-c6c1-4f96-bfa2-05113b00bae0", "0.0.1", "CryptoMB-TLS-handshake-acceleration-for-Istio"},
		{"0aa86dd0-415c-4bf8-ae76-832560470b74", "0.0.1", "DaemonSet-GKE-Autopilot"},
		{"31ed2484-4aeb-4dcc-aa98-b61933d371cc", "0.0.1", "Delay-Action-for-Chaos-Mesh"},
		{"3afb9cdf-4a37-4db2-a9f9-2e2b8769ec3e", "0.0.11", "Deploy-Meshery-using-Meshery"},
		{"147e429b-fe51-45b3-a275-a5940cb91882", "0.0.42", "Deployable-simple-web-architecture-design"},
		{"28980b0e-fb2f-4b18-8a79-47c45b477ca3", "0.0.16", "Double-Bubble-Map"},
		{"397e88c7-38d9-4499-85b2-73696f0b195a", "0.0.54", "Edge-Firewall-relationship"},
		{"57f4628b-798e-4f72-be0e-03b42683b27b", "0.0.3", "Edge-Relationships-diff"},
		{"37422db6-b585-4b1a-baaa-d307d33d5ebf", "0.0.116", "Edge-mount-relationship"},
		{"3cf2d3a4-460f-44a0-8efc-bfc5b5ae661c", "0.0.34", "Exam-Portal-with-Real-Time-Leaderboard-AWS"},
		{"1f79b0c6-2efe-4ee9-b08c-e1bd07a3926b", "0.0.1", "Example-Edge-Network"},
		{"02413809-9fbf-4649-ae22-3d0947d264c6", "0.0.1", "Example-Labels-and-Annotations"},
		{"08379ae3-cd9e-4b55-a190-91a47a1ff638", "0.0.1", "Fault-tolerant-batch-GKE"},
		{"070b4569-2b26-4e13-93f7-9992fdf1e6fd", "0.0.332", "GCP-DataMesh"},
		{"107f4fc2-0655-4d00-be3d-164947159647", "0.0.1", "Hello-Kubernetes-Tutorial"},
		{"3255f170-e2b1-48e8-bbed-40d4e0198a90", "0.0.4", "Hierarchical-Parent-Inventory-Relationship"},
		{"3ec9ec04-1a16-4814-ba1d-12c61b356bc3", "0.0.33", "Hierarchical-Parent-Matchlabels-Relationship"},
		{"1fa80124-d38d-41d1-a768-0fcb7cdae31e", "0.0.1", "HorizontalPodAutoscaler"},
		{"06ef6097-8f21-4a76-b025-0c9271168814", "0.0.1", "Istio-Operator"},
		{"32f10b2a-82eb-4ab9-b1f7-4f8c7f888011", "0.0.1", "Jaeger-operator"},
		{"1a9cfdfb-daaf-4c19-be93-6d9bc0f7b94d", "0.0.144", "K8s-Workload-Controllers"},
		{"0e426f91-14df-4f70-b6cc-ed3624d53ccd", "0.0.1", "Key-cloak-operator"},
		{"23d03e32-4232-40f1-b953-0416e47b9b5d", "0.0.1", "Kubernetes-Engine-Training-Example"},
		{"287dc0fe-6497-4483-b54e-178eb8d65da8", "0.0.1", "Kubernetes-cronjob"},
		{"336465da-5ead-418c-baee-a369fb5581e9", "0.0.65", "Kubernetes-service-Design"},
		{"210422ee-a1c4-4844-9591-bab374608cba", "0.0.1", "Litmus-Chaos-Operator"},
		{"2197b9bf-c48d-4394-873e-680a2ae35ed2", "0.0.91", "LoxiLB-K8S-External-Load-Balancer"},
		{"2d0a36b9-8170-4076-8aea-4fa6b28caf31", "0.0.166", "Match-Labels-Relationship"},
		{"081aa52c-7921-48dd-b81e-03f4ebfc70b5", "0.0.1", "Minecraft-App"},
		{"22df0361-9be1-4e48-a3fb-f782ce900cbd", "0.0.54", "Namespaces-in-kubernetes"},
		{"100a9ac6-9cb2-47e3-b960-6429674cdb04", "0.0.8", "Observable-K8s-Workloads"},
		{"3e85b81b-f366-4afc-a24f-763a4cf66a8b", "0.0.3", "Online-Polling-Application"},
		{"10caf581-6498-4a1f-a00a-76011b60af48", "0.0.643", "Oracle-e-commerce-microservices-on-kubernetes"},
		{"2649785a-6cb1-4671-b625-a790ac375043", "0.0.1", "Persistence-volume-claim"},
		{"17c46515-50ef-436c-9383-451e13348ddd", "0.0.1", "Pod-Multi-Containers"},
		{"0194ff83-0a43-4b83-9c75-b8f0f32da6b7", "0.0.1", "Pod-Readiness"},
		{"05ff8dbb-2552-4a23-a6a8-318fe412bf30", "0.0.1", "Pod-Resource-Request"},
		{"307373c2-a096-4b52-841e-fc18c3a5d17f", "0.0.21", "Redis-PHP-Guestbook"},
		{"189a3e71-8be9-4e64-9fed-150a9b1060de", "0.0.1", "Resilient-Web-App"},
		{"205a4fe3-1daf-4150-9062-3e7c81dde143", "0.0.1", "Simple-Kubernetes-Pod"},
		{"2a5bf8bd-d53a-4d8a-ba59-da43b0948b44", "0.0.5", "URL-Shortener-Application"},
		{"2f7597bd-9713-461e-b64f-c571415d2a86", "0.0.11", "VPC-WORKFLOW-DESIGN"},
		{"3039deb0-7a26-4f4c-ab4c-a4c45a4f281c", "0.0.4", "Weather-Forecasting-App"},
		{"2df29b2b-7e5e-4d8b-a5b3-3dea569f4d25", "0.0.1", "WordPress-and-MySQL-with-Persistent-Volume"},
		{"10919143-fe49-419d-9022-7906e75fe1bf", "0.0.75", "clickhouse-otel-hyperdx-arch"},
		{"13e803b7-596c-4620-bdc4-4d3a28a027a2", "0.0.20", "container-alias-relationship"},
		{"0a2d8c39-df40-490b-94b7-75d0fb7fc207", "0.0.1", "default-ns"},
		{"1f3c7dcd-e49a-4bf7-985a-661d6c64d8d7", "0.0.1", "doks-nginx-deployment"},
		{"045bdba0-bc55-4bf8-8e54-1ae05ebd671c", "0.0.7", "example-project"},
		{"129c524b-ead9-4170-b236-a1c9dd274ece", "0.0.1", "gitlab-runner-deployment"},
		{"3a38cc90-e998-4f2a-9747-17f2d7ddf313", "0.0.1", "grafana-deployment"},
		{"28e09dc6-de75-4c61-8531-e6e3744f7e98", "0.0.2", "hierarchical-parent-namespace-relationship"},
		{"1c9730ce-b481-41c3-92ed-8044e1203f17", "0.0.3", "katib-242"},
		{"3e027027-05dc-4c10-9bd0-287cb34c2b09", "0.0.8", "kibana-helm-design-fixed"},
		{"3b2a210d-77b4-4267-bc8e-bc32758edf76", "0.0.1", "meshery-cilium-deployment"},
		{"34fe3846-4b90-4558-914c-8e57caefd52f", "0.0.2", "meshery-design-fixturejson"},
		{"114c94c9-052b-46a2-86fe-4cdd2e88c746", "0.0.1", "my-first-app-design"},
		{"2512c0cb-385d-40de-b1f5-bc4a67131538", "0.0.1", "my-sql-with-cinder-vol-plugin"},
		{"1e2478e0-7611-4d4f-a44f-ea02cebf7b91", "0.0.1", "postgreSQL-cluster"},
		{"2a42de8b-3c58-4571-b092-2fda29ecfb1a", "0.0.1", "prometheus-operator-crd-cluster-roles"},
		{"3c3439a0-d215-4a71-aa47-13a5f2d007b7", "0.0.1", "prometheus_kubernetes"},
		{"2aa761d3-cd30-419a-a441-2f042934116f", "0.0.2", "service-to-deployment-network"},
		{"34cc15a9-2cf7-4eb6-91b6-c9731e0984d8", "0.0.5", "sqlcl-liquibase-100tgz"},
		{"0ecab33d-6ac2-40ff-9ff9-76a706598cbe", "0.0.13", "test-design-account"},
		{"22e28213-8c94-49d5-b104-3b7feee84b5e", "0.0.1", "voting_app"},
	}
}

// divergenceCategory classifies why engines diverge.
type divergenceCategory string

const (
	catMatch          divergenceCategory = "MATCH"
	catOPACrash       divergenceCategory = "OPA_CRASH"
	catOPANoResult    divergenceCategory = "OPA_NO_RESULT"
	catLegacyPrepass  divergenceCategory = "LEGACY_PREPASS"
	catSetOrdering    divergenceCategory = "SET_ORDERING"
	catDeleteRetain   divergenceCategory = "DELETE_RETAIN"
	catRelCountDiff   divergenceCategory = "REL_COUNT_DIFF"
	catActionCountDif divergenceCategory = "ACTION_DIFF"
)

type designResult struct {
	name     string
	comps    int
	rels     int
	category divergenceCategory
	goRels   int
	opaRels  int
	goComps  int
	opaComps int
	opaErr   string
	detail   string
}

const catalogCacheDir = "testdata/catalog"

// ensureCatalogDesigns downloads catalog designs if not cached locally.
// Returns the directory containing JSON files.
func ensureCatalogDesigns(t *testing.T) string {
	t.Helper()
	dir := catalogCacheDir

	// Check if we already have cached files.
	if entries, err := os.ReadDir(dir); err == nil {
		jsonCount := 0
		for _, e := range entries {
			if strings.HasSuffix(e.Name(), ".json") {
				jsonCount++
			}
		}
		if jsonCount >= len(catalogDesigns()) {
			t.Logf("Using %d cached designs from %s", jsonCount, dir)
			return dir
		}
	}

	// Download missing designs.
	if err := os.MkdirAll(dir, 0o755); err != nil {
		t.Fatalf("mkdir %s: %v", dir, err)
	}

	client := &http.Client{Timeout: 30 * time.Second}
	designs := catalogDesigns()
	t.Logf("Downloading %d catalog designs...", len(designs))

	sem := make(chan struct{}, 10)
	var wg sync.WaitGroup
	var mu sync.Mutex
	downloaded := 0

	for _, d := range designs {
		path := filepath.Join(dir, d.name+".json")
		if _, err := os.Stat(path); err == nil {
			continue // already cached
		}

		wg.Add(1)
		go func(d catalogEntry, path string) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			url := fmt.Sprintf(
				"https://raw.githubusercontent.com/meshery/meshery.io/master/catalog/%s/%s/design.yml",
				d.id, d.version,
			)
			resp, err := client.Get(url)
			if err != nil || resp.StatusCode != http.StatusOK {
				return
			}
			defer resp.Body.Close()
			body, err := io.ReadAll(resp.Body)
			if err != nil {
				return
			}
			// Validate JSON
			var m map[string]any
			if json.Unmarshal(body, &m) != nil {
				return
			}
			os.WriteFile(path, body, 0o644)
			mu.Lock()
			downloaded++
			mu.Unlock()
		}(d, path)
	}
	wg.Wait()
	t.Logf("Downloaded %d new designs", downloaded)
	return dir
}

// loadCatalogDesigns reads all JSON files from the cache directory.
func loadCatalogDesigns(t *testing.T, dir string) []struct {
	name string
	data map[string]any
} {
	t.Helper()
	entries, err := os.ReadDir(dir)
	if err != nil {
		t.Fatalf("read dir: %v", err)
	}

	var designs []struct {
		name string
		data map[string]any
	}
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
			continue
		}
		raw, err := os.ReadFile(filepath.Join(dir, e.Name()))
		if err != nil {
			continue
		}
		var m map[string]any
		if json.Unmarshal(raw, &m) != nil {
			continue
		}
		designs = append(designs, struct {
			name string
			data map[string]any
		}{name: strings.TrimSuffix(e.Name(), ".json"), data: m})
	}

	sort.Slice(designs, func(i, j int) bool {
		return designs[i].name < designs[j].name
	})
	return designs
}

func relTypeDistribution(design map[string]any) map[string]int {
	dist := make(map[string]int)
	for _, r := range getMapSlice(design, "relationships") {
		rel, ok := r.(map[string]any)
		if !ok {
			continue
		}
		key := fmt.Sprintf("%s/%s/%s",
			strings.ToLower(getMapString(rel, "kind")),
			strings.ToLower(getMapString(rel, "type")),
			strings.ToLower(getMapString(rel, "subType")))
		dist[key]++
	}
	return dist
}

func hasRelType(relTypes map[string]int, subType string) bool {
	for k := range relTypes {
		if strings.HasSuffix(k, "/"+subType) {
			return true
		}
	}
	return false
}

func classifyDivergence(relTypes map[string]int, goRels, opaRels int, opaStatuses map[string]int) divergenceCategory {
	if opaRels == 0 && goRels > 0 {
		return catLegacyPrepass
	}
	if opaStatuses["deleted"] > 0 {
		return catDeleteRetain
	}
	if hasRelType(relTypes, "matchlabels") && opaRels < goRels {
		return catSetOrdering
	}
	if goRels != opaRels {
		return catRelCountDiff
	}
	return catActionCountDif
}

func countRelationships(design map[string]any) int {
	return len(getMapSlice(design, "relationships"))
}

func countComponents(design map[string]any) int {
	return len(getMapSlice(design, "components"))
}

func opaStatusDistribution(opaDesign any) map[string]int {
	dist := make(map[string]int)
	designMap, ok := opaDesign.(map[string]any)
	if !ok {
		return dist
	}
	rels, _ := designMap["relationships"].([]any)
	for _, r := range rels {
		rel, ok := r.(map[string]any)
		if !ok {
			continue
		}
		status := ""
		if s, ok := rel["status"].(string); ok {
			status = strings.ToLower(s)
		}
		if status == "" {
			status = "unknown"
		}
		dist[status]++
	}
	return dist
}

func opaRelCount(opaDesign any) int {
	designMap, ok := opaDesign.(map[string]any)
	if !ok {
		return 0
	}
	rels, _ := designMap["relationships"].([]any)
	return len(rels)
}

func opaCompCount(opaDesign any) int {
	designMap, ok := opaDesign.(map[string]any)
	if !ok {
		return 0
	}
	comps, _ := designMap["components"].([]any)
	return len(comps)
}

// TestCatalogAlignment downloads (if needed) and evaluates catalog designs
// through both Go and OPA engines, printing a summary table.
func TestCatalogAlignment(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping catalog alignment test in short mode")
	}
	dir := ensureCatalogDesigns(t)
	designs := loadCatalogDesigns(t, dir)
	if len(designs) == 0 {
		t.Fatal("no designs found")
	}

	log, _ := logger.New("catalog-alignment", logger.Options{Format: logger.SyslogLogFormat})
	goEngine := NewGoEngine(log)
	opaModules := loadOPAModules(t)

	var results []designResult

	for _, fd := range designs {
		design := fd.data
		comps := countComponents(design)
		rels := countRelationships(design)
		relTypes := relTypeDistribution(design)

		if rels == 0 {
			continue
		}

		// Go engine
		relsInScope := extractMapSlice(design, "relationships")
		goDesign, _ := goEngine.evaluate(deepCopyMap(design), relsInScope)
		goRelCount := countRelationships(goDesign)
		goCompCount := countComponents(goDesign)

		// OPA engine
		ctx := context.Background()
		opaData := map[string]any{"relationships": getMapSlice(design, "relationships")}
		store := inmem.NewFromObject(opaData)
		opts := append(opaModules,
			rego.Query("data.relationship_evaluation_policy.evaluate"),
			rego.Input(design),
			rego.Store(store),
		)
		r := rego.New(opts...)
		rs, err := r.Eval(ctx)

		if err != nil {
			shortErr := err.Error()
			if len(shortErr) > 60 {
				shortErr = shortErr[:60]
			}
			results = append(results, designResult{
				name: fd.name, comps: comps, rels: rels,
				category: catOPACrash, goRels: goRelCount, goComps: goCompCount,
				opaErr: shortErr,
			})
			continue
		}

		if len(rs) == 0 || len(rs[0].Expressions) == 0 {
			results = append(results, designResult{
				name: fd.name, comps: comps, rels: rels,
				category: catOPANoResult, goRels: goRelCount, goComps: goCompCount,
			})
			continue
		}

		opaResult, ok := rs[0].Expressions[0].Value.(map[string]any)
		if !ok {
			results = append(results, designResult{
				name: fd.name, comps: comps, rels: rels,
				category: catOPACrash, goRels: goRelCount, goComps: goCompCount,
				opaErr: "unexpected result type",
			})
			continue
		}

		opaRels := opaRelCount(opaResult["design"])
		opaComps := opaCompCount(opaResult["design"])
		opaStatuses := opaStatusDistribution(opaResult["design"])

		if goRelCount == opaRels && goCompCount == opaComps {
			results = append(results, designResult{
				name: fd.name, comps: comps, rels: rels,
				category: catMatch, goRels: goRelCount, opaRels: opaRels,
				goComps: goCompCount, opaComps: opaComps,
			})
			continue
		}

		cat := classifyDivergence(relTypes, goRelCount, opaRels, opaStatuses)
		results = append(results, designResult{
			name: fd.name, comps: comps, rels: rels,
			category: cat, goRels: goRelCount, opaRels: opaRels,
			goComps: goCompCount, opaComps: opaComps,
			detail: fmt.Sprintf("Go=%d OPA=%d", goRelCount, opaRels),
		})
	}

	// Print summary table.
	t.Logf("\n")
	t.Logf("%s", strings.Repeat("=", 120))
	t.Logf("%-40s %5s %5s %16s %8s %8s %s",
		"Design", "Comps", "Rels", "Category", "GoRels", "OPARels", "Detail")
	t.Logf("%s", strings.Repeat("-", 120))

	catCounts := make(map[divergenceCategory]int)
	for _, r := range results {
		catCounts[r.category]++
		detail := r.detail
		if r.opaErr != "" {
			detail = r.opaErr
		}
		name := r.name
		if len(name) > 39 {
			name = name[:36] + "..."
		}
		t.Logf("%-40s %5d %5d %16s %8d %8d %s",
			name, r.comps, r.rels, r.category, r.goRels, r.opaRels, detail)
	}

	t.Logf("%s", strings.Repeat("-", 120))
	t.Logf("Total: %d designs", len(results))

	type catEntry struct {
		cat   divergenceCategory
		count int
	}
	var catList []catEntry
	for c, n := range catCounts {
		catList = append(catList, catEntry{c, n})
	}
	sort.Slice(catList, func(i, j int) bool { return catList[i].count > catList[j].count })
	for _, e := range catList {
		label := ""
		switch e.cat {
		case catMatch:
			label = "Both engines agree"
		case catOPACrash:
			label = "OPA crashes (eval_conflict_error in patch_helper_rules.rego)"
		case catLegacyPrepass:
			label = "OPA legacy prepass deletes rels (evaluation.rego:76-198)"
		case catSetOrdering:
			label = "OPA set ordering breaks matchlabels (evaluation.rego:206)"
		case catDeleteRetain:
			label = "OPA retains deleted rels, Go removes them"
		case catRelCountDiff:
			label = "Relationship count differs (legacy prepass side-effect)"
		case catActionCountDif:
			label = "Action count differs"
		case catOPANoResult:
			label = "OPA returns no result"
		}
		t.Logf("  %-16s %3d  %s", e.cat, e.count, label)
	}
}
