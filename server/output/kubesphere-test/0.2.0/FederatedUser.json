{"kind":"FederatedUser","apiVersion":"v1alpha2","display-name":"Federated User","format":"JSON","metadata":{},"model":{"name":"kubesphere-test","version":"0.2.0","display-name":"","category":"","sub-category":""},"schema":"{\n \"properties\": {\n  \"placement\": {\n   \"properties\": {\n    \"clusterSelector\": {\n     \"properties\": {\n      \"matchLabels\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"object\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"clusters\": {\n     \"items\": {\n      \"properties\": {\n       \"name\": {\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"name\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"template\": {\n   \"properties\": {\n    \"metadata\": {\n     \"type\": \"object\"\n    },\n    \"spec\": {\n     \"description\": \"UserSpec defines the desired state of User\",\n     \"properties\": {\n      \"description\": {\n       \"description\": \"Description of the user.\",\n       \"type\": \"string\"\n      },\n      \"displayName\": {\n       \"type\": \"string\"\n      },\n      \"email\": {\n       \"description\": \"Unique email address(https://www.ietf.org/rfc/rfc5322.txt).\",\n       \"type\": \"string\"\n      },\n      \"groups\": {\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"lang\": {\n       \"description\": \"The preferred written or spoken language for the user.\",\n       \"type\": \"string\"\n      },\n      \"password\": {\n       \"description\": \"password will be encrypted by mutating admission webhook Password pattern is tricky here. The rule is simple: length between [6,64], at least one uppercase letter, one lowercase letter, one digit. The regexp in console(javascript) is quite straightforward: ^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)[^]{6,64}$ But in Go, we don't have ?= (back tracking) capability in regexp (also in CRD validation pattern) So we adopted an alternative scheme to achieve. Use 6 different regexp to combine to achieve the same effect. These six schemes enumerate the arrangement of numbers, uppercase letters, and lowercase letters that appear for the first time. - ^(.*[a-z].*[A-Z].*[0-9].*)$ stands for lowercase letter comes first, then followed by an uppercase letter, then a digit. - ^(.*[a-z].*[0-9].*[A-Z].*)$ stands for lowercase letter comes first, then followed by a digit, then an uppercase leeter. - ^(.*[A-Z].*[a-z].*[0-9].*)$ ... - ^(.*[A-Z].*[0-9].*[a-z].*)$ ... - ^(.*[0-9].*[a-z].*[A-Z].*)$ ... - ^(.*[0-9].*[A-Z].*[a-z].*)$ ... Last but not least, the bcrypt string is also included to match the encrypted password. ^(\\\\$2[ayb]\\\\$.{56})$\",\n       \"maxLength\": 64,\n       \"minLength\": 6,\n       \"pattern\": \"^(.*[a-z].*[A-Z].*[0-9].*)$|^(.*[a-z].*[0-9].*[A-Z].*)$|^(.*[A-Z].*[a-z].*[0-9].*)$|^(.*[A-Z].*[0-9].*[a-z].*)$|^(.*[0-9].*[a-z].*[A-Z].*)$|^(.*[0-9].*[A-Z].*[a-z].*)$|^(\\\\$2[ayb]\\\\$.{56})$\",\n       \"type\": \"string\"\n      }\n     },\n     \"required\": [\n      \"email\"\n     ],\n     \"type\": \"object\"\n    },\n    \"status\": {\n     \"description\": \"UserStatus defines the observed state of User\",\n     \"properties\": {\n      \"lastLoginTime\": {\n       \"description\": \"Last login attempt timestamp\",\n       \"format\": \"date-time\",\n       \"type\": \"string\"\n      },\n      \"lastTransitionTime\": {\n       \"format\": \"date-time\",\n       \"type\": \"string\"\n      },\n      \"reason\": {\n       \"type\": \"string\"\n      },\n      \"state\": {\n       \"description\": \"The user status\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    }\n   },\n   \"required\": [\n    \"spec\"\n   ],\n   \"type\": \"object\"\n  }\n },\n \"required\": [\n  \"placement\",\n  \"template\"\n ],\n \"title\": \"Federated User\",\n \"type\": \"object\"\n}"}